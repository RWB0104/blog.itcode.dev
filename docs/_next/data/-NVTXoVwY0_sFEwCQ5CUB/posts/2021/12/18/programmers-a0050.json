{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[프로그래머스 / JAVA] Level 1 약수의 합 (12928)","excerpt":"정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:13:33+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0049.md","content":"\r\n# 약수의 합\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [약수의 합](https://programmers.co.kr/learn/courses/30/lessons/12928)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수 `n`을 입력받아 `n`의 약수를 모두 더한 값을 리턴하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* `n`은 0 이상 3000이하인 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | return |\r\n| :---: | :----: |\r\n|  12   |   28   |\r\n|   5   |   6    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n약수를 구해서 값을 누적하면 된다. 약수 구하는 알고리즘은 아래와 같다.\r\n\r\n``` java\r\nfor (int i = 1; i <= Math.sqrt(n); i++)\r\n{\r\n\t// 나누어 떨어질 경우\r\n\tif (n % i == 0)\r\n\t{\r\n\t\t// n의 제곱근일 경우\r\n\t\tif (i * i == n)\r\n\t\t{\r\n\t\t\tanswer += i;\r\n\t\t}\r\n\t\t\r\n\t\t// n의 제곱근이 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tanswer += i;\r\n\t\t\tanswer += n / i;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`n`의 제곱근까지 돌면 약수를 모두 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 약수의 합 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 17:52:04\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 정수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 1; i <= Math.sqrt(n); i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어질 경우\r\n\t\t\tif (n % i == 0)\r\n\t\t\t{\r\n\t\t\t\t// n의 제곱근일 경우\r\n\t\t\t\tif (i * i == n)\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer += i;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// n의 제곱근이 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer += i;\r\n\t\t\t\t\tanswer += n / i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0049","2021","12","18","programmers-a0049"]},"next":{"header":{"title":"[프로그래머스 / JAVA] Level 1 자릿수 더하기 (12931)","excerpt":"자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요. 예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:31:11+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0051.md","content":"\r\n# 자릿수 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [자릿수 더하기](https://programmers.co.kr/learn/courses/30/lessons/12931)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `N`이 주어지면, `N`의 각 자릿수의 합을 구해서 return 하는 `solution` 함수를 만들어 주세요.\r\n예를들어 `N = 123`이면 1 + 2 + 3 = 6을 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `N`의 범위 : 100,000,000 이하의 자연수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   N   | answer |\r\n| :---: | :----: |\r\n|  123  |   6    |\r\n|  987  |   24   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n9 + 8 + 7 = 24이므로 24를 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자의 자릿수 별 숫자를 전부 더하는 알고리즘.\r\n\r\n숫자를 문자로 변환하여 한 글자씩 나누고, 나눈 글자를 숫자로 변환하여 값을 누적하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 자릿수 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 18:27:11\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tString[] numbers = String.valueOf(n).split(\"\");\r\n\t\t\r\n\t\tfor (String number : numbers)\r\n\t\t{\r\n\t\t\tanswer += Integer.parseInt(number);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0051","2021","12","18","programmers-a0051"]}},"group":[{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 3. 좌표계","excerpt":"1986년, NASA에서 우주왕복선 챌린저호를 발사했으나, 발사한 지 약 73초만에 폭발한 안타까운 사고가 있었다. 원인은 어이없게도 단위 실수. 국제적인 표준은 미터법임에도 불구하고, 미국을 포함한 몇몇 국가는 인치법을 표준으로 사용하고 있었다. 이러한 상황에서 우주선의 설계도 중 미터법으로 표기된 부품 O Ring을 인치법으로 제작했기 때문에 일어난 사고였다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-04T01:47:29+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer","OpenLayers","React(리액트)","TypeScript"],"group":"프로그래머스","comment":true,"publish":true},"name":"2022-03-04-gis-guide-for-programmer-3.md","content":"\n# 다 같은 좌표가 아니야!\n\n1986년, NASA에서 우주왕복선 챌린저호를 발사했으나, 발사한 지 약 73초만에 폭발한 안타까운 사고가 있었다.\n\n원인은 어이없게도 단위 실수. 국제적인 표준은 미터법임에도 불구하고, 미국을 포함한 몇몇 국가는 인치법을 표준으로 사용하고 있었다. 이러한 상황에서 우주선의 설계도 중 미터법으로 표기된 부품 O Ring을 인치법으로 제작했기 때문에 일어난 사고였다.\n\n<br />\n\n공간정보 또한 이와 비슷하게 좌표계라는 일종의 단위를 가지고 있다. 통상 공간정보의 좌표라고 하면 대부분 동경 127, 북위 37을 떠올린다.\n\n동경 127, 북위 37은 GPS에서 주로 사용하는 세계측지 중 하나인 `WGS-84` 좌표계다. 이와 같이 좌표계의 특성에 따라 표현되는 값도 다르며, 이를 구분하기 위해 EPSG:0000과 같이 EPSG 코드로 관리한다.\n\n방금 언급한 `WGS-84`의 코드는 `EPSG:4326`이다.\n\n|  EPSG 코드  |                     proj 인자                      |\n| :---------: | :------------------------------------------------: |\n| `EPSG:4326` | `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs` |\n\n이러한 체계를 좌표계라고 부르며, 공식적으론 프로젝션(Projection)이라 명칭한다. 프로젝션은 EPSG 코드와 proj 인자로 이루어진다.\n\nEPSG 코드는 좌표계의 명칭이며, proj 인자는 좌표계를 표현하는 수식으로 +proj=로 시작한다. 이 proj 인자는 좌표계의 표현 및 좌표계 변환에 사용된다.\n\nSHP의 prj 파일은 이 프로젝션에 대한 정보를 담고 있다.\n\n대부분의 데이터 제공자는 자신이 제공하는 공간정보 데이터에 대한 좌표계를 제공하니, 사용하기전에 이를 반드시 확인해야한다. <span class=\"red-500\">간혹 명시하지 않거나, 오기입하는 경우도 있으니 주의.</span>\n\n<br />\n<br />\n\n\n\n\n\n## 타원체\n\n좌표는 현재 위치를 특정 값으로 표시하는 것이다. 지구는 구(Sphere) 형태를 띄고 있으므로, 좌표를 정확하게 표시하기 위해선 이 구의 모양을 정의할 필요가 있다.\n\n지구는 구 형태지만, 실제로 엄밀한 구는 아니다. 아, 그렇다고 평평하다는 뜻은 더더욱 아니다.\n\n![image](https://user-images.githubusercontent.com/50317129/156601191-e161a593-ccee-4f06-b5c8-b2ffce88bdaf.png)\n\n아름다운 구 형태였다면 좋았겠지만, 아쉽게도 지구의 모양은 문제가 좀 많다. 구라고 부르기 애매한 수준. 혹자는 감자라고도 칭한다.\n\n어쨌든 완벽한 구 형태가 아니다보니, 좌표를 계산함에 있어서 여러 보정이 필요하다.\n\n<br />\n\n이런 지구의 현실을 반영하여 지구의 형태를 정의한 것을 타원체라고 한다. 좌표계마다 사용하는 타원체는 제각각이며, 어떤 타원체를 사용하냐에 따라 그 특성이 달라진다.\n\n* GRS80: 세계 타원체 표준. 국제측지학회, 지구물리학연합에서 채택함\n* WGS84: 미국에서 군사용 GPS를 개발하는 과정에서 사용하기 위해 정의한 타원체.\n  * GRS80과 WGS84는 거의 동일하며, 단반경 0.01mm 정도의 매우 근소한 차이를 가진다.\n* BESSEL: 특정 구역을 기준으로 정의한 타원체. 특정 구역까지는 정확하나, 구역에서 멀어질수록 오차가 심해진다.\n  * 대한민국은 일제강점기의 영향으로 이전까진 도쿄를 기준으로 정의된 BESSEL 타원체를 사용했다.\n\n타원체와 관련된 정보를 찾다보면 **ITRF-2000**이라는 키워드가 보일텐데, ITRF-2000은 하나로 정의된 타원체가 아니라, 세계 공통 타원체를 ITRF-2000이라 부른다. 즉, 현재 기준으로 `GRS80`과 동일하다.\n\n<br />\n\nGPS라는 걸출한 기술이 개발되기 전까지는 각 구역을 중심으로 타원체를 정의하는 `BESSEL` 타원체를 많이 사용했다. GPS 기술 이전에는 전 세계의 타원체를 정의할 수단이나 기술이 전무했기 때문.\n\n그 중 우리나라는 위에서 언급했다시피, 일제강점기의 영향으로 인해 일본에서 진행한 국토조사 사업을 통해 BESSEL 동경 타원체를 사용하게 됐다.\n\n`EPSG:2096(동부)`, `EPSG:2097(중부)`, `EPSG:2096(서부)` 등이 이에 해당되며, 오래된 공간 정보 데이터를 찾다 보면 이 좌표계들을 사용하는 걸 볼 수도 있다.\n\n다행히 현재는 국제 표준을 위해 `GRS80` 타원체를 사용하는 좌표계로 변경했다. 아래 후술할 `EPSG:5180(서부)`, `EPSG:5181(중부)`, `EPSG:5183(동부)` 등이 이에 해당한다.\n\n<br />\n<br />\n\n\n\n\n\n## 투영법\n\n여러분 머릿속에 지도를 떠올려보자. 종이든, 앱이든 상관없다. 생각해보면, 지구는 구지만, 지도는 평면이다. 물론 지구의 형태를 충실히 이행한 지구본이 있지만, 요즘의 지구본은 위치보다는 인테리어의 범주에 들어섰다. 단언컨데 여기서 그 누구도 위치를 찾기 위해 지구본을 들여다보지 않을 것이다.\n\n그말인즉슨, 우리에게 익숙한 지도를 만들기 위해선, 구를 평면화하는 작업이 필요하다. 어렸을 때 수학시간에 전개라는 개념을 배운 적이 있는가? 우유팩을 완전히 펼치는 과정을 생각하면 얼추 비슷하다.\n\n![image](https://user-images.githubusercontent.com/50317129/156607735-9b23d446-1bdc-4dd1-9105-455906f51fc4.png)\n\n이처럼 좌표계에서 구를 평면화하는 것을 투영법이라 부른다.\n\n* TM(Transverse Mercator): BESSEL 타원체를 기준으로 투영한 평면좌표계\n* UTM(Universal TM): GRS80(혹은 WGS84) 타원체를 기준으로 투영한 평면좌표계\n* UTM-K: 일반적인 UTM은 적도를 기준으로 하므로, 한국과 약간의 오차가 발생한다. 이를 보정하여 한국에 맞게 정의한 것이 UTM-K다.\n  * UTM 투영체는 GRS80 타원체를 기준으로 하는데, UTM-K 중 몇몇 좌표계는 BESSEL 타원체를 사용한다. 자세한 이유는 불명.\n\n좌표계를 보면 중부, 동부 등으로 나눠져있는데, 이는 오차를 최소화하기 위해 기준점을 나눈 것이다.\n\n타원체를 정의하고, 이를 평면화하는 과정에서 발생하는 오차를 최대한 줄이기 위해 투영 기준점을 잡고, 해당 위치를 기준으로 투영하는 것이다. 대한민국은 동부, 중부, 서부, 제주원점이 존재하며, 각 구역의 측위기준점을 기준으로 좌표계를 투영한다.\n\n<br />\n<br />\n\n\n\n\n\n# 자주 사용하는 프로젝션\n\n사실 타원체니, 투영법이니 크게 중요하지 않다. 그냥 본인이 가진 데이터가 어떤 좌표계를 사용하는지만 잘 알면 된다. 타원체가 뭔지, 투영법이 뭔지에 관계없이 모든 좌표계는 `EPSG:0000`의 형태로 관리되기 때문. 그냥 본인이 원하는 좌표계의 코드만 알고 있으면 단순 사용에 아무런 문제가 없다.\n\n모든 좌표계를 다 숙지하거나, proj 인자를 외울 필요는 전혀 없다. 단, 주로 사용하는 좌표계 정도는 알고 있는 것이 수월하다.\n\n아래는 대표적으로 사용하는 좌표계의 목록이다.\n\n<br />\n\n\n\n## 세계 측지\n\n|  EPSG 코드  | proj 인자                                                                                                          |        비고         |\n| :---------: | :----------------------------------------------------------------------------------------------------------------- | :-----------------: |\n| `EPSG:3857` | `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs`                                                                 |         GPS         |\n| `EPSG:4326` | `+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs` | Google Maps, VWorld |\n\n## 국내 측지\n\n|  EPSG 코드  | proj 인자                                                                                               |   비고    |\n| :---------: | :------------------------------------------------------------------------------------------------------ | :-------: |\n| `EPSG:5179` | `+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs` | NAVER Map |\n| `EPSG:5181` | `+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=GRS80 +units=m +no_defs`          | KAKAO Map |\n| `EPSG:5186` | `+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs`          | 중부원점  |\n\n이 밖에도 여러 좌표계가 있으므로, 필요할 때마다 찾아 사용하면 된다.\n\n[EPSG.io](https://epsg.io/)에서 다양한 좌표계의 정보를 확인할 수 있으니 참고할 것.","url":["2022-03-04-gis-guide-for-programmer-3","2022","03","04","gis-guide-for-programmer-3"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 2. GIS랑 인사하기","excerpt":"여러분들이 GIS를 처음 접했다면, 한 번 물어보고 싶다. 공간이란 뭘로 이루어져 있을까? 한 번 생각해보자. 다양한 답이 나왔을 것이라 생각한다. 무슨 답인지 내가 직접 못 듣는다는 게 좀 아쉽지만. 아마 대부분 추상적인 답이 나왔을 것이라 생각한다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-03T23:36:04+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer","OpenLayers","React(리액트)","TypeScript"],"group":"프로그래머스","comment":true,"publish":true},"name":"2022-03-03-gis-guide-for-programmer-2.md","content":"\n# GIS의 50가지 그림자\n\n여러분들이 GIS를 처음 접했다면, 한 번 물어보고 싶다. **공간이란 뭘로 이루어져 있을까?** 한 번 생각해보자.\n\n다양한 답이 나왔을 것이라 생각한다. 무슨 답인지 내가 직접 못 듣는다는 게 좀 아쉽지만. 아마 대부분 추상적인 답이 나왔을 것이라 생각한다.\n\n<br />\n\n어떤 사물을 파악할 때, <span class=\"red-500\">가장 효과적인 방법은 사물의 본질을 파악하는 것</span>이다. 철로 이루어진 어떤 물건이 있다고 해보자. 이걸 어디다 쓰는진 알 수 없지만, 단단한 게 필요할 때 요긴하게 쓸 수 있을 것이다. 필요하다면, 녹여서 다른 철제 물건으로 만들 수도 있다.\n\n반대로 이게 정확히 뭔지 모르고 \"어... 이거 그건데..? 그 뭐였더라...?\" 같은 추상적인 방법으로 접근한다면 그 사물이 뭔지 파악하는 건 매우 어렵다.\n\n공간을 구현해야한다는 관점에서 볼 때, 공간을 추상적인 개념으로 접근한다면 공간을 디지털화하기 매우 어려울 것이다. 때문에 우리는 공간을 다루기 이전에, 공간이 무엇으로 이루어지는지 그 개념을 명확하게 알 필요가 있다.\n\n공간은 **점(Point)**, **선(Line)**, **면(Polygon)**으로 이루어진다.\n\n* 공간에 점을 하나 찍으면 점이 생긴다.\n* 무수히 많은 점을 연달아 찍으면 선이 생긴다.\n* 무수히 많은 선을 연달아 그으면 면이 생긴다.\n\n![image](https://user-images.githubusercontent.com/50317129/156584563-367bd1e7-390d-4e3d-bef1-1ff3103b1a13.png)\n\n3차원 관점에서는 좀 더 복잡한 요소들이 작용하지만, 2차원은 단순한 점, 선, 면만으로 온전한 공간을 구현할 수 있다. 면은 선의 집합으로 표현할 수 있고, 선은 점의 집합으로 표현할 수 있으니, 공간은 점의 위치들로 표현이 가능하다. 이 글에서 궁극적으로 다룰 OpenLayers는 2차원 형태의 지도이므로, 이 정도로만 기억해도 당장엔 무리가 없다.\n\n공간이 무엇으로 이루어져 있는지 앞서 생각한 답과 점의 집합 중 어느게 더 구현하기 쉬울 지 비교해보자. 아마 점 $(x, y)$로 표현하는 것이 더 간단할 것이다.\n\n* 점: 하나의 $(x, y)$로 이루어진다.\n* 선: 다수의 $(x, y)$들로 이루어진다. 단, 가장 처음 $(x, y)$와 마지막 $(x, y)$가 달라야 한다.\n* 면: 다수의 $(x, y)$들로 이루어진다. 단, 가장 처음 $(x, y)$와 마지막 $(x, y)$가 서로 같아야 한다.\n\n선과 면의 차이에 주목하자. 선과 면 모두 무수히 많은 점들로 구성되어 있는데, 선과 면을 구분할 수 있는 가장 큰 차이는 가장 첫 좌표와 마지막 좌표가 동일한지 확인하는 것이다.\n\n<span class=\"blue-500\">첫 좌표와 마지막 좌표가 동일하면 온전히 하나의 면이 이루어진 것</span>으로 보며, 만약 육안으로 아무리 가까워보여도 <span class=\"blue-500\">첫 좌표와 마지막 좌표가 서로 일치하지 않으면 선</span>이다.\n\n3차원 공간은 GIS 지식에 대한 전공 수준의 이해 뿐만 아니라, 3D 프로그래밍에도 조예가 있어야하는 매우 복잡한 영역이니, 여기선 다루지 않는다. <del class=\"grey-500\">애초에 3차원 개발하려는 사람의 수준은 이 글을 아득히 뛰어넘는다.</del>\n\n<br />\n<br />\n\n\n\n\n\n## 공간정보를 냉장고에 넣는 법\n\n디지털에서 공간을 표현하는 데 점의 위치를 이용한다는 것을 알았다. 그런데, 이 정보. 도대체 어떤 식으로 다뤄야될까?\n\n점의 경우 다행히 데이터의 표현 방식이 $(x, y)$로 명확하다. 하지만 선, 면으로 가면 얘기가 다소 복잡해진다. 우선 데이터의 양이 매우 많아진다. 데이터를 어떤 식으로 구분하는지에도 차이가 발생한다.\n\n* ${x_1}$,${y_1}$ ${x_2}$,${y_2}$ ... ${x_n}$,${y_n}$\n* ${x_1}$ ${y_1}$,${x_2}$ ${y_2}$, ... ${x_n}$ ${y_n}$\n\n위 처럼 같은 집합을 표현함에도 개발자에 따라 다양한 표현 방법이 나오게 된다. 특정 컬럼의 양이 기하급수적으로 늘어남은 물론이고, 문자열 연산도 수행해야한다. 더 큰 문제는 데이터 보관 주체마다 양식이 통일되지 않으므로, 호환성은 희망사항일 뿐이다.\n\n때문에 공간정보를 다루기 위한 여러 포맷이 고안됐다.\n\n<br />\n\n\n\n### SHP (Shape)\n\n가장 대표적인 공간정보 데이터 포맷이다. 미국의 ESRI에서 공간정보 데이터를 위해 고안한 형식이다. ESRI는 SHP 뿐만 아니라 QGIS라는 걸출한 GIS 오픈소스 툴을 만든 회사이기도 하다.\n\nSHP는 일반 데이터 컬럼은 데이터 형식에 맞게 저장하고(VARCHAR, NUMBER, DATE 등) 위치정보만 정해진 규격으로 저장한다. 해당 바이너리를 통해 데이터의 형식 및 좌표 데이터를 산출할 수 있다.\n\nSHP 파일은 기본적으로 아래 4가지 파일로 이루어져있다. shp를 제외한 나머지 파일은 shp를 보조하는 파일로, 없어도 shp를 다루는데 문제는 없다.\n\n* `shp`: 벡터 도형 데이터 (핵심)\n* `shx`: 벡터 도형 인덱스\n* `dbf`: 각 도형의 속성 데이터\n* `prj`: 좌표 정보\n\n공간정보 뿐만 아니라 다양한 부가 데이터를 쉽게 저장할 수 있으며, 구조 상 데이터베이스와 매우 유사하다는 이점이 있으며, 거의 대부분의 GIS 툴이 SHP를 지원한다.\n\n이러한 이점과 범용성에 힘입어 공간정보 데이터의 표준이 되었고, 대부분의 공간정보는 기본적으로 SHP로 제공된다고 봐도 무방하다. 즉, <span class=\"primary\">공간정보 데이터는 SHP 하나만 알고 있어도 된다.</span>\n\n<br />\n\n\n\n### GeoJSON\n\nJSON은 알겠는데, GeoJSON은 또 뭐야? 하겠지만, 우리가 아는 그 JSON 맞다. 단, 공간정보를 표현하기 위해 정해진 방식으로 구성된 JSON이다.\n\nGeoJSON의 양식은 아래와 같다.\n\nJavaScript와 친숙한 JSON을 차용함으로써, HTTP 통신으로 공간정보를 쉽게 호출하는 데 쓰인다. 이러한 특성 때문에, 공간정보 데이터를 보관한다는 목적 보다는 HTTP 데이터 통신 시 주로 사용한다.\n\n물론 GeoJSON도 공간정보를 보관하는데 무리가 없으며, 인지도 있는 GIS 툴은 GeoJSON을 지원한다. 또한 SHP와 달리 데이터의 CRUD에 별다른 툴이 필요하지 않다는 장점이 있다.\n\n\n\n### 기타\n\n그 밖에도 CSV, Excel, txt 등 여러 텍스트 기반 파일로 다루기도 한다. 단, 이러한 형식들은 공간정보를 저장하는데 적합하지 않아 공간 데이터의 추출 결과물이나, 점 데이터에 한해 제한적으로 사용하기도 한다.\n\n공간정보를 다루는 방법에 있어서 꼭 SHP나 GeoJSON으로만 한정되지 않는다는 것만 참고하자.\n\n<br />\n<br />\n<br />\n\n\n\n\n\n\n\n\n\n\n# 둘러보기\n\n* [도로명주소 건물 데이터](http://data.nsdi.go.kr/dataset/14783) (로그인 필요)\n\n위 URL은 도로명주소의 건물 데이터를 제공받을 수 있는 URL이다. 건물 뿐만 아니라 시도, 시군구, 건물 진출입로, 도로 등 다양한 데이터를 제공하고 있다. 대부분 SHP로 제공한다는 점에 주목하자.","url":["2022-03-03-gis-guide-for-programmer-2","2022","03","03","gis-guide-for-programmer-2"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 1. 머릿말","excerpt":"공간정보, 지리쪽에 업이 있거나 관심있는 사람이 아니라면, GIS라는 단어는 다소 생소한 단어다. 혹자는 GIS가 아니라 GPS 아니냐고 반문하기도 한다. GPS(Global Positioning System)는 3개 이상의 위성 신호를 통해 수신기의 위치를 계산할 수 있는 기법이다. GPS라 하면 흔히 네비게이션을 연상하기 쉽지만, 알게 모르게 GPS는 일상생활에 깊게 녹아들어 있다. 네비게이션, 스마트폰 지도, 배달 플랫폼의 라이더 위치 추적, 드론 군집비행, 군사학 등. GPS는 다양한 영역에 스며들어 그 이로움을 전해준다. 우리는 GPS를 통해, 공간정보라는 디지털 시대에서 공간을 디지털화한다는 것이 어떤 능력을 발휘하는 지 엿볼 수 있다. GIS(Global Information System)는 GPS와 같이 공간정보를 다루는 모든 기술에 대한 포괄적인 기술을 의미한다. GPS 뿐만 아니라, 지도, 좌표계와 같이 공간과 엮이는 모든 기술은 GIS라는 커다란 범주로 묶을 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-03T23:05:35+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer","OpenLayers","React(리액트)","TypeScript"],"group":"프로그래머스","comment":true,"publish":true},"name":"2022-03-03-gis-guide-for-programmer-1.md","content":"\n# 개요\n\n공간정보, 지리쪽에 업이 있거나 관심있는 사람이 아니라면, GIS라는 단어는 다소 생소한 단어다. 혹자는 GIS가 아니라 GPS 아니냐고 반문하기도 한다.\n\nGPS(Global Positioning System)는 3개 이상의 위성 신호를 통해 수신기의 위치를 계산할 수 있는 기법이다. GPS라 하면 흔히 네비게이션을 연상하기 쉽지만, 알게 모르게 GPS는 일상생활에 깊게 녹아들어 있다. 네비게이션, 스마트폰 지도, 배달 플랫폼의 라이더 위치 추적, 드론 군집비행, 군사학 등. GPS는 다양한 영역에 스며들어 그 이로움을 전해준다. 우리는 GPS를 통해, 공간정보라는 디지털 시대에서 공간을 디지털화한다는 것이 어떤 능력을 발휘하는 지 엿볼 수 있다.\n\nGIS(Global Information System)는 GPS와 같이 공간정보를 다루는 모든 기술에 대한 포괄적인 기술을 의미한다. GPS 뿐만 아니라, 지도, 좌표계와 같이 공간과 엮이는 모든 기술은 GIS라는 커다란 범주로 묶을 수 있다.\n\n![image](https://user-images.githubusercontent.com/50317129/156580872-dfd08787-3416-4595-b224-a12156075ffb.png)\n\n컴퓨터의 발전이래, 인류는 현실세계의 모든 것을 디지털화하고 있다. 이미 인류는 보고 듣는 모든 것들을 디지털화했다. 찰나의 순간, 기억을 저장한다는 욕구 이후로, 이젠 이러한 자료를 관리하고 제공하는 자들이 막대한 돈을 벌어들이고 있다.\n\n![image](https://user-images.githubusercontent.com/50317129/156581103-fd79ade7-ab3e-424e-852c-8bfd3d4382b7.png)\n\n시청각의 디지털화는 시청각을 마음대로 다룰 수 있다는 뜻이나 다름없다. 정적 데이터인 사진의 합성은 이젠 애들 장난 수준이다. 발전된 영상 편집 기술은 물론 논란의 중심인 딥 페이크 기술을 보고 있자면 인식의 개념을 부정당하는 느낌이 들기도 한다.\n\n<br />\n<p align=\"large center\" class=\"grey-400\"><i>고도로 발달한 기술은 마법과 구별할 수 없다.</i></p>\n<br />\n\n동영상, 사진이 시청각을 다룬다면, GIS는 현실에서의 공간을 디지털화하고, 이를 다룰 수 있는 매우 멋진 기술이다. 지금은 지도나 위치정보 같은 데이터류를 다루는 것이 일반적이지만, 현재 각광받고 있는 메타버스 기술, 가상현실과 같이 '공간'이 주가 되는 기술에서 GIS는 그 핵심이 될 것이다.\n\n시청각 디지털이 시청각에 마법을 일으킨다면, GIS는 디지털 속 공간이라는 개념에 마법을 부릴 수 있다 하겠다.\n\n<br />\n<br />\n<br />\n\n...라고 말은 거창하게 적었지만 내가 무슨 GIS의 대가도 아니고, 그냥 GIS 살짝 담궈본 일개 프로그래머일 뿐이다.\n\n이직한 회사에서 GIS에 대한 소요가 좀 있는 거 같길래, 이전 회사에서 배웠던 기술도 좀 되살려볼 겸, 토이 프로젝트 식으로 GIS 서비스를 만들며 관련 기술에 대해 기록해볼까 한다.\n\n사실 한국에서의 GIS는 다른 기술에 비해 찬밥 신세를 면치 못 한다. 이런 원천기술류가 으레 그렇듯이, 깊게 들어가면 측량, 토목 쪽으로 빠져버리니 GIS라는 분야에 뜻을 가진 사람이 아니라면 깊게 들어가기도 애매하다. 당장 이 글을 읽는 당신 조차 그렇다. 당신은 개발자이기를 원하지, 절대 GIS 연구자이고 싶지 않을 테니.\n\n<br />\n\n사람들은 여행을 떠날 때 GIS로 이루어진 지도라는 걸 보고 여행하겠지만, 막상 GIS를 여행하려는 사람들은 한국에서 볼 게 적은 것이 현실이다. 남들은 여행길이 고생길이라고 할 때, GIS 여행자들은 여행 준비부터가 고생인 셈이다.\n\n<br />\n<p align=\"large center\" class=\"grey-400\"><i>우리 모두는 한 때 초심자였다.</i></p>\n<br />\n\n\"수학을 잘하고 싶어요!\"라고 말하는 초등학생에게 다짜고짜 수학의 정석을 풀라고 할 수 없다.\n\n\"프로그래밍 잘하고 싶어요!\"라고 말하는 국비 3일차 개발자에게 \"음 그래? 그럼 프로그래머스 5단계 풀어\"라고 할 수 없다.\n\n모든 것엔 입문이 있고, 순서라는 게 존재한다. 아이의 생각은 아이의 눈높이에서 봐야 가장 잘 이해할 수 있다.\n\n내 비록 꼬꼬마 프로그래머지만, 내 경험과 글, 시야를 통해 이제 막 OpenLayers 여행을 시작한 개발자들에게 작은 안내서라도 되어주길 바란다.\n\n<br />\n<br />\n<br />\n\n\n\n\n\n\n\n\n\n\n# 부록\n\n## 준비물\n\n* OpenLayers 6\n* React\n* GeoServer\n\n## 우리는 커서...\n\n* 프로그래밍에서 GIS를 어떤 식으로 다루는 지 알아봐요!\n* GeoServer로 GIS 서비스 환경을 만들어요!\n* React + OpenLayers 6로 GIS 서비스를 제공해요!\n  * OpenLayers 6는 ESNext를 지향하므로, React가 적합하답니다.","url":["2022-03-03-gis-guide-for-programmer-1","2022","03","03","gis-guide-for-programmer-1"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 메뉴 리뉴얼 (72411)","excerpt":"각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, \"스카피\"가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, \"스카피\"가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-29T22:13:12+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-29-programmers-a0078.md","content":"\r\n# 메뉴 리뉴얼\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [메뉴 리뉴얼](https://programmers.co.kr/learn/courses/30/lessons/72411)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 `orders`, \"스카피\"가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 `course`가 매개변수로 주어질 때, \"스카피\"가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `orders` 배열의 크기는 2 이상 20 이하입니다.\r\n* `orders` 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.\r\n  * 각 문자열은 알파벳 대문자로만 이루어져 있습니다.\r\n  * 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.\r\n* `course` 배열의 크기는 1 이상 10 이하입니다.\r\n  * `course` 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다.\r\n  * `course` 배열에는 같은 값이 중복해서 들어있지 않습니다.\r\n* 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요.\r\n  * 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다.\r\n  * 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.\r\n  * `orders`와 `course` 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                       orders                        |   course    |               result                |\r\n| :-------------------------------------------------: | :---------: | :---------------------------------: |\r\n|  { \"ABCFG\", \"AC\", \"CDE\", \"ACDE\", \"BCFG\", \"ACDEH\" }  | { 2, 3, 4 } |   { \"AC\", \"ACDE\", \"BCFG\", \"CDE\" }   |\r\n| { \"ABCDE\", \"AB\", \"CD\", \"ADE\", \"XYZ\", \"XYZ\", \"ACD\" } | { 2, 3, 5 } | { \"ACD\", \"AD\", \"ADE\", \"CD\", \"XYZ\" } |\r\n|               { \"XYZ\", \"XWY\", \"WXA\" }               | { 2, 3, 4 } |           { \"WX\", \"XY\" }            |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\nAD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.\r\n\r\n요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다.\r\n\r\n**입출력 예 #3**\r\n\r\nWX가 두 번, XY가 두 번 주문됐습니다.\r\n\r\n3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.\r\n\r\n또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n손님이 시킨 요리 중 가장 많이 선택된 요리를 골라 코스 요리로 만든다고 한다. 도와주자.\r\n\r\n코스 요리는 2개 이상의 단품 메뉴로 구성해야한다. `course`에 단품 메뉴 갯수의 배열이 할당된다.\r\n\r\n`[ 2, 3, 4 ]`라면 각각 단품 메뉴가 2개, 3개, 4개로 구성된 코스요리를 만들어야 한다. 만약, 가장 많이 주문한 요리가 두 개 이상일 경우, 전부 코스 요리로 만든다.\r\n\r\n<br />\r\n\r\n단품 메뉴의 수를 기준으로 손님의 주문 내역에서 만들 수 있는 조합을 구한 후, 그 숫자를 카운팅하여 구할 수 있을 것이다.\r\n\r\n`HashMap` 객체를 활용하여 각 코스 요리별 주문 갯수를 기록하고, 가장 많이 주문된 조합을 `ArrayList`에 담아 반환한다.\r\n\r\n손님의 주문 중 `n`개로 구성된 코스 요리 조합을 구해야 하므로, 조합이 적절해보인다.\r\n\r\n각 `course`의 요소별로 `for`문을 돌려 코스요리별로 가장 많이 주문된 조합을 구한다.\r\n\r\n<br />\r\n\r\n주문이 `ABC`일 경우, 단품 2개로 구성된 코스 요리는 `AB`, `BC`, `AC`가 있다. `AB`와 `BA`는 조합상 같기 때문에 주문을 사전순으로 정렬할 필요가 있다.\r\n\r\n`Arrays.sort()` 메소드를 사용하여 각 주문의 `char[]`를 정렬한다.\r\n\r\n이후 조합을 통해 각 구성별 코스 요리를 계산하여 `HashMap`에 저장하고, 가장 많이 호출된 수 `max`를 별도로 계산한다.\r\n\r\n코스 요리 계산이 끝나면 `HashMap`의 요소를 돌며 `max`와 동일한 값을 가진 키를 `ArrayList`에 저장한다.\r\n\r\n이후 `ArrayList`를 정렬하여 배열로 만든 후 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 메뉴 리뉴얼 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.29 Wed 11:25:03\r\n */\r\nclass Solution\r\n{\r\n\tprivate HashMap<String, Integer> map;\r\n\t\r\n\tprivate int max;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param orders: [String[]] 열\r\n\t * @param course: [int[]] 행\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic String[] solution(String[] orders, int[] course)\r\n\t{\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item : course)\r\n\t\t{\r\n\t\t\tmap = new HashMap<>();\r\n\t\t\t\r\n\t\t\tmax = 2;\r\n\t\t\t\r\n\t\t\tfor (String order : orders)\r\n\t\t\t{\r\n\t\t\t\t// 주문한 메뉴가 추가하려는 코스요리 갯수 이상일 경우\r\n\t\t\t\tif (order.length() >= item)\r\n\t\t\t\t{\r\n\t\t\t\t\tboolean[] isVisit = new boolean[order.length()];\r\n\t\t\t\t\t\r\n\t\t\t\t\tchar[] texts = order.toCharArray();\r\n\t\t\t\t\t\r\n\t\t\t\t\tArrays.sort(texts);\r\n\t\t\t\t\t\r\n\t\t\t\t\tcombination(texts, isVisit, 0, item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmap.forEach((s, integer) ->\r\n\t\t\t{\r\n\t\t\t\t// 요소가 최대값일 경우\r\n\t\t\t\tif (integer == max)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.add(s);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().sorted().toArray(String[]::new);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 메서드\r\n\t *\r\n\t * @param texts: [char[]] 문자 배열\r\n\t * @param isVisit: [boolean[]] 방문 여부 배열\r\n\t * @param start: [int] 시작 인덱스\r\n\t * @param target: [int] 조합 갯수\r\n\t */\r\n\tprivate void combination(char[] texts, boolean[] isVisit, int start, int target)\r\n\t{\r\n\t\t// 탐색이 끝났을 경우\r\n\t\tif (target == 0)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < texts.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 탐색했을 경우\r\n\t\t\t\tif (isVisit[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.append(texts[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tString key = builder.toString();\r\n\t\t\t\r\n\t\t\tint value = map.getOrDefault(key, 0) + 1;\r\n\t\t\t\r\n\t\t\tmap.put(key, value);\r\n\t\t\t\r\n\t\t\tmax = Math.max(max, value);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = start; i < texts.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisVisit[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(texts, isVisit, i + 1, target - 1);\r\n\t\t\t\t\r\n\t\t\t\tisVisit[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```","url":["2021-12-29-programmers-a0078","2021","12","29","programmers-a0078"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 행렬 테두리 회전하기 (77485)","excerpt":"rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-29T11:23:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-29-programmers-a0077.md","content":"\r\n# 행렬 테두리 회전하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [행렬 테두리 회전하기](https://programmers.co.kr/learn/courses/30/lessons/77485)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`rows` x `columns` 크기인 행렬이 있습니다. 행렬에는 1부터 `rows` x `columns`까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다.\r\n\r\n* x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다.\r\n\r\n다음은 6 x 6 크기 행렬의 예시입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/ybm/4c3c0fab-11f4-43b6-b290-6f4017e9379f/grid_example.png)\r\n\r\n이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/ybm/962df137-5c71-4091-ad9f-8e322910c1ab/rotation_example.png)\r\n\r\n행렬의 세로 길이(행 개수) `rows`, 가로 길이(열 개수) `columns`, 그리고 회전들의 목록 `queries`가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 **가장 작은 숫자들을 순서대로 배열에 담아** return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `rows`는 2 이상 100 이하인 자연수입니다.\r\n* `columns`는 2 이상 100 이하인 자연수입니다.\r\n* 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다.\r\n  * 즉, 아무 회전도 하지 않았을 때, `i` 행 `j` 열에 있는 숫자는 `((i-1) x columns + j)`입니다.\r\n* `queries`의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다.\r\n* `queries`의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다.\r\n  * x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다.\r\n  * `1 ≤ x1 < x2 ≤ rows`, `1 ≤ y1 < y2 ≤ columns`입니다.\r\n  * 모든 회전은 순서대로 이루어집니다.\r\n  * 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| rows  | columns |                              queries                               |     result     |\r\n| :---: | :-----: | :----------------------------------------------------------------: | :------------: |\r\n|   6   |    6    |         { { 2, 2, 5, 4 }, { 3, 3, 6, 6 }, { 5, 1, 6, 3 } }         | { 8, 10, 25 }  |\r\n|   3   |    3    | { { 1, 1, 2, 2 }, { 1, 2, 2, 3 }, { 2, 1, 3, 2 }, { 2, 2, 3, 3 } } | { 1, 1, 5, 3 } |\r\n|  100  |   97    |                       { { 1, 1, 100, 97 } }                        |     { 1 }      |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/ybm/8c8cdd84-d0ec-4b9d-bdf7-f100d0098c5e/example1.png)\r\n\r\n**입출력 예 #2**\r\n\r\n회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/ybm/e3fce2bf-9da9-41e4-926a-5d19b4f31188/example2.png)\r\n\r\n**입출력 예 #3**\r\n\r\n이 예시에서는 행렬의 테두리에 위치한 모든 칸들이 움직입니다. 따라서, 행렬의 테두리에 있는 수 중 가장 작은 숫자인 1이 바로 답이 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n행렬의 테두리 회전 알고리즘을 잘 짜야한다.\r\n\r\n사각형으로 회전하므로, 각 변마다 회전하는 알고리즘을 `for`문으로 구성해야한다. 다행히 회전 방향은 시계 방향으로 정해져있다.\r\n\r\n데이터를 정상적으로 회전시키려면, 회전하는 방향과 반대 방향으로 진행해야 데이터를 온전히 보존하면서 회전할 수 있다.\r\n\r\n좌 -> 하 -> 우 -> 상 순으로 진행하며 데이터를 회전시킨다. 방법은 아래와 같다.\r\n\r\n* `minPos`: $(x_{min}, y_{min})$\r\n* `maxPos`: $(x_{max}, y_{max})$\r\n\r\n<br />\r\n\r\n**1. 좌측 회전**\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147632640-17caa77d-200c-4ca3-9f0a-e9b0117bc9b1.png)\r\n\r\n좌측 회전을 수행한다.\r\n\r\n``` java\r\nfor (int j = minPos[0]; j < maxPos[0]; j++)\r\n{\r\n\tboard[j][minPos[1]] = board[j + 1][minPos[1]];\r\n}\r\n```\r\n\r\n`(2, 2)`, `(3, 2)`, `(4, 2)` 순으로 진행한다.\r\n\r\ny좌표는 $y_{min}$으로 동일하고, x좌표만 바뀐다.\r\n\r\n진행하며 그림을 기준으로 자신의 하단값을 자신에게 할당한다.\r\n\r\n가장 최소 좌표인 `(2, 2)`의 값 8은 별도로 저장한다.\r\n\r\n<br />\r\n\r\n**2. 하단 회전**\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147632647-0bc7e891-43b4-4683-b27c-9445ae5d6122.png)\r\n\r\n하단 회전을 수행한다.\r\n\r\n``` java\r\nfor (int j = minPos[1]; j < maxPos[1]; j++)\r\n{\r\n\tboard[maxPos[0]][j] = board[maxPos[0]][j + 1];\r\n}\r\n```\r\n\r\n`(5, 2)`, `(5, 3)` 순으로 진행한다.\r\n\r\nx좌표는 $x_{max}$로 동일하고, y좌표만 바뀐다.\r\n\r\n진행하며 그림을 기준으로 자신의 우측값을 자신에게 할당한다.\r\n\r\n<br />\r\n\r\n**3. 우측 회전**\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147632648-698b63f6-ee1c-4f2f-b9a3-caf2248bdbfc.png)\r\n\r\n``` java\r\nfor (int j = maxPos[0]; j > minPos[0]; j--)\r\n{\r\n\tboard[j][maxPos[1]] = board[j - 1][maxPos[1]];\r\n}\r\n```\r\n\r\n`(5, 4)`, `(4, 4)`, `(3, 4)` 순으로 진행한다.\r\n\r\ny좌표는 $y_{max}$로 동일하고, x좌표만 바뀐다.\r\n\r\n진행하며 그림을 기준으로 자신의 상단값을 자신에게 할당한다.\r\n\r\n<br />\r\n\r\n**4. 상단 회전**\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147632660-a9fcebbf-4e93-476d-8520-658c8a5bcdd7.png)\r\n\r\n``` java\r\nfor (int j = maxPos[1]; j > minPos[1]; j--)\r\n{\r\n\tboard[minPos[0]][j] = board[minPos[0]][j - 1];\r\n}\r\n```\r\n\r\n`(2, 4)`, `(2, 3)` 순으로 진행한다.\r\n\r\nx좌표는 $x_{min}$으로 동일하고, y좌표만 바뀐다.\r\n\r\n진행하며 그림을 기준으로 자신의 좌측값을 자신에게 할당한다.\r\n\r\n회전 이후 `(2, 3)` 데이터가 손실되는데, 이 때 **좌측 회전**에서 따로 저장해둔 최소 좌표값을 할당한다.\r\n\r\n즉, $(x_{min}, y_{min})$을 별도로 저장해두고, $(x_{min}, y_{min} + 1)$에 따로 할당하면 된다.\r\n\r\n<br />\r\n\r\n회전 방향과 반대로 진행하며, 자신 앞의 데이터를 자신에게 할당하는 알고리즘을 구현하는 것이 관건이다.\r\n\r\n회전 방향이 여러개일 경우, 회전 방향마다 알고리즘을 별도로 구성해야하나, 이 문제에서는 시계방향 고정이니 신경쓸 필욘 없다.\r\n\r\n회전 과정에서 모든 요소에 접근하게 되므로, 요소마다 값을 비교하여 최소값을 별도로 저장하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 멀쩡한 사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.28 Tue 22:51:28\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param rows: [int] 열\r\n\t * @param columns: [int] 행\r\n\t * @param queries: [int[][]] 회전 대상\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int[] solution(int rows, int columns, int[][] queries)\r\n\t{\r\n\t\tint[] answer = new int[queries.length];\r\n\t\t\r\n\t\tint[][] board = new int[rows][columns];\r\n\t\t\r\n\t\tfor (int i = 0; i < rows; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < columns; j++)\r\n\t\t\t{\r\n\t\t\t\tboard[i][j] = i * columns + j + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < queries.length; i++)\r\n\t\t{\r\n\t\t\tint[] minPos = { queries[i][0] - 1, queries[i][1] - 1 };\r\n\t\t\tint[] maxPos = { queries[i][2] - 1, queries[i][3] - 1 };\r\n\t\t\t\r\n\t\t\tint start = board[minPos[0]][minPos[1]];\r\n\t\t\t\r\n\t\t\tint min = Integer.MAX_VALUE;\r\n\t\t\t\r\n\t\t\t// 좌측 라인 회전\r\n\t\t\tfor (int j = minPos[0]; j < maxPos[0]; j++)\r\n\t\t\t{\r\n\t\t\t\tmin = Math.min(min, board[j][minPos[1]]);\r\n\t\t\t\t\r\n\t\t\t\tboard[j][minPos[1]] = board[j + 1][minPos[1]];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 하단 라인 회전\r\n\t\t\tfor (int j = minPos[1]; j < maxPos[1]; j++)\r\n\t\t\t{\r\n\t\t\t\tmin = Math.min(min, board[maxPos[0]][j]);\r\n\t\t\t\t\r\n\t\t\t\tboard[maxPos[0]][j] = board[maxPos[0]][j + 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 우측 라인 회전\r\n\t\t\tfor (int j = maxPos[0]; j > minPos[0]; j--)\r\n\t\t\t{\r\n\t\t\t\tmin = Math.min(min, board[j][maxPos[1]]);\r\n\t\t\t\t\r\n\t\t\t\tboard[j][maxPos[1]] = board[j - 1][maxPos[1]];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 윗 라인 회전\r\n\t\t\tfor (int j = maxPos[1]; j > minPos[1]; j--)\r\n\t\t\t{\r\n\t\t\t\tmin = Math.min(min, board[minPos[0]][j]);\r\n\t\t\t\t\r\n\t\t\t\tboard[minPos[0]][j] = board[minPos[0]][j - 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tboard[minPos[0]][minPos[1] + 1] = start;\r\n\t\t\t\r\n\t\t\tanswer[i] = min;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-29-programmers-a0077","2021","12","29","programmers-a0077"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 짝지어 제거하기 (12973)","excerpt":"짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-29T11:23:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-29-programmers-a0076.md","content":"\r\n# 짝지어 제거하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [짝지어 제거하기](https://programmers.co.kr/learn/courses/30/lessons/12973)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 `S`가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.\r\n\r\n예를 들어, 문자열 `S = baabaa` 라면\r\n\r\nb **aa** baa → **bb** aa → **aa** →\r\n\r\n의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 문자열의 길이 : 1,000,000이하의 자연수\r\n* 문자열은 모두 소문자로 이루어져 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   s    | result |\r\n| :----: | :----: |\r\n| baabaa |   1    |\r\n|  cdcd  |   0    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n위의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n처음엔 `while`을 통한 반복문과 `charAt` 메서드로 접근했는데, 동작은 잘 됐으나 너무 느렸다.\r\n\r\n곰곰히 생각해보다가 문득 Level 1의 [크레인 인형뽑기 게임 (64061)](/posts/2021/12/14/programmers-a0005)와 매우 유사하다는 것을 깨달았다.\r\n\r\n위 문제는 동일한 인형을 연속해서 뽑았을 경우, 해당 인형을 삭제하는 동작이 포함되어 있다.\r\n\r\n위 문제의 인형을 문자열로 바꿔 생각해보면 매우 유사함을 알 수 있다.\r\n\r\n<br />\r\n\r\n`Stack`에 문자열을 하나씩 담으며, 담기 전에 가장 마지막에 삽입된 요소를 꺼내 비교한다.\r\n\r\n만약 동일하다면, 같은 문자열이 두 번 반복됐다는 의미이므로 삽입없이 스택에서 마지막 요소를 제거한다.\r\n\r\n아니라면, 그냥 삽입하면 된다.\r\n\r\n<br />\r\n\r\n예시: `baabaa`\r\n\r\n1. 스택에 아무것도 없으므로 `b`를 삽입한다.\r\n2. 다음 문자 `a`와 스택의 최근 데이터 `b`를 비교한다.\r\n   1. 같지 않으므로 `a`를 삽입한다.\r\n3. 다음 문자 `a`와 스택의 최근 데이터 `a`를 비교한다.\r\n   1. 같으므로 스택의 최근 데이터 `a`를 삭제한다.\r\n4. 다음 문자 `b`와 스택의 최근 데이터 `b`를 비교한다.\r\n   1. 같으므로 스택의 최근 데이터 `b`를 삭제한다.\r\n5. 스택에 아무것도 없으므로 다음 문자 `a`를 삽입한다.\r\n6. 다음 문자 `a`와 스택의 최근 데이터 `a`를 비교한다.\r\n   1. 같으므로 스택의 최근 데이터 `a`를 삭제한다.\r\n7. 스택이 비었을 경우 `1`, 아닐 경우 `0`을 반환한다.\r\n\r\n두 문자가 연속할 경우로 제한되어 있기 때문에, 세 자리 이상의 연속된 문자는 고려할 필요 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 짝지어 제거하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.28 Tue 17:38:51\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\tStack<Character> stack = new Stack<>();\r\n\t\t\r\n\t\tfor (char c : s.toCharArray())\r\n\t\t{\r\n\t\t\t// 스택이 비었을 경우\r\n\t\t\tif (stack.isEmpty())\r\n\t\t\t{\r\n\t\t\t\tstack.add(c);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 글씨가 서로 붙어있을 경우\r\n\t\t\t\tif (c == stack.peek())\r\n\t\t\t\t{\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstack.add(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn stack.isEmpty() ? 1 : 0;\r\n\t}\r\n}\r\n```","url":["2021-12-29-programmers-a0076","2021","12","29","programmers-a0076"]},{"header":{"title":"[프로그래머스 / MySQL] Level 2 루시와 엘라 찾기 (59046)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-28T17:38:16+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-28-programmers-a0075.md","content":"\r\n# 루시와 엘라 찾기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [루시와 엘라 찾기](https://programmers.co.kr/learn/courses/30/lessons/59046)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL 문을 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n이때 결과는 아이디 순으로 조회해주세요. 예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION | NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :---: | :-------------: |\r\n|  A373219  |     Cat     | 2014-07-29 11:43:00 |      Normal      | Ella  |  Spayed Female  |\r\n|  A377750  |     Dog     | 2017-10-25 17:17:00 |      Normal      | Lucy  |  Spayed Female  |\r\n|  A353259  |     Dog     | 2016-05-08 12:57:00 |     Injured      |  Bj   |  Neutered Male  |\r\n|  A354540  |     Cat     | 2014-12-11 11:48:00 |      Normal      |  Tux  |  Neutered Male  |\r\n|  A354597  |     Cat     | 2014-05-02 12:16:00 |      Normal      | Ariel |  Spayed Female  |\r\n\r\nSQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID | NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---: | :-------------: |\r\n|  A373219  | Ella  |  Spayed Female  |\r\n|  A377750  | Lucy  |  Spayed Female  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. `NAME`이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물을 조회한다.\r\n2. `ANIMAL_ID`, `NAME`, `SEX_UPON_INTAKE`를 조회한다.\r\n3. `ANIMAL_ID`의 사전순으로 조회한다.\r\n\r\n`IN`을 사용하면 여러 요소가 포함된 데이터를 한 번에 조회할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME, SEX_UPON_INTAKE FROM ANIMAL_INS WHERE NAME IN ('Lucy', 'Ella', 'Pickle', 'Rogan', 'Sabrina', 'Mitty') ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-28-programmers-a0075","2021","12","28","programmers-a0075"]},{"header":{"title":"[프로그래머스 / MySQL] Level 2 고양이와 개는 몇 마리 있을까 (59040)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-28T17:19:20+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-28-programmers-a0074.md","content":"\r\n# 고양이와 개는 몇 마리 있을까\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [고양이와 개는 몇 마리 있을까](https://programmers.co.kr/learn/courses/30/lessons/59040)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 고양이와 개가 각각 몇 마리인지 조회하는 SQL문을 작성해주세요. 이때 고양이를 개보다 먼저 조회해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어, `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION | NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :---: | :-------------: |\r\n|  A373219  |     Cat     | 2014-07-29 11:43:00 |      Normal      | Ella  |  Spayed Female  |\r\n|  A377750  |     Dog     | 2017-10-25 17:17:00 |      Normal      | Lucy  |  Spayed Female  |\r\n|  A354540  |     Cat     | 2014-12-11 11:48:00 |      Normal      |  Tux  |  Neutered Male  |\r\n\r\n고양이는 2마리, 개는 1마리 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_TYPE | count |\r\n| :---------: | :---: |\r\n|     Cat     |   2   |\r\n|     Dog     |   1   |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. `ANIMAL_TYPE`이 `Cat` 혹은 `Dog`인 동물을 조회한다.\r\n2. `ANIMAL_TYPE`과 갯수를 조회한다.\r\n3. `ANIMAL_TYPE`의 사전순으로 조회한다.\r\n\r\n`GROUP BY`를 통해 `ANIMAL_TYPE`을 그룹화하여 `Cat`, `Dog`의 갯수를 구할 수 있다. `ORDER BY`로 `ANIMAL_TYPE`의 사전순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_TYPE, COUNT(*) FROM ANIMAL_INS GROUP BY ANIMAL_TYPE ORDER BY ANIMAL_TYPE;\r\n```","url":["2021-12-28-programmers-a0074","2021","12","28","programmers-a0074"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 타겟 넘버 (43165)","excerpt":"n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-28T17:10:04+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-28-programmers-a0073.md","content":"\r\n# 타겟 넘버\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`n`개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.\r\n\r\n* -1+1+1+1+1 = 3\r\n* +1-1+1+1+1 = 3\r\n* +1+1-1+1+1 = 3\r\n* +1+1+1-1+1 = 3\r\n* +1+1+1+1-1 = 3\r\n\r\n사용할 수 있는 숫자가 담긴 배열 `numbers`, 타겟 넘버 `target`이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.\r\n* 각 숫자는 1 이상 50 이하인 자연수입니다.\r\n* 타겟 넘버는 1 이상 1000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      numbers      | target | return |\r\n| :---------------: | :----: | :----: |\r\n| { 1, 1, 1, 1, 1 } |   3    |   5    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n문제에 나온 예와 같습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`numbers`의 요소를 적절히 더하고 빼서 나온 값이 `target`이 되는 경우의 수를 구한다.\r\n\r\nDFS 알고리즘을 활용해 `numbers`의 각 수를 가감하여 합계를 구하고, 이를 `target`과 비교하여 동일할 경우 이를 카운팅한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 타겟 넘버 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.28 Tue 12:31:46\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 정수 배열\r\n\t * @param target: [int] 타겟 넘버\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] numbers, int target)\r\n\t{\r\n\t\treturn dfs(numbers, 0, 0, target);\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 정수 배열\r\n\t * @param depth: [int] 깊이\r\n\t * @param sum: [int] 합계\r\n\t * @param target: [int] 타겟 넘버\r\n\t *\r\n\t * @return [int] 결과\r\n\t */\r\n\tpublic int dfs(int[] numbers, int depth, int sum, int target)\r\n\t{\r\n\t\t// 완전 탐색했을 경우\r\n\t\tif (depth == numbers.length)\r\n\t\t{\r\n\t\t\t// 타겟 넘버와 합계가 동일할 경우\r\n\t\t\tif (target == sum)\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn dfs(numbers, depth + 1, sum + numbers[depth], target) + dfs(numbers, depth + 1, sum - numbers[depth], target);\r\n\t\t}\r\n\t}\r\n}\r\n```","url":["2021-12-28-programmers-a0073","2021","12","28","programmers-a0073"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 더 맵게 (42626)","excerpt":"매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-28T12:15:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-28-programmers-a0072.md","content":"\r\n# 더 맵게\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [더 맵게](https://programmers.co.kr/learn/courses/30/lessons/42626)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 `K` 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 `K` 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\r\n\r\n`섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)`\r\n\r\nLeo는 모든 음식의 스코빌 지수가 `K` 이상이 될 때까지 반복하여 섞습니다.\r\n\r\nLeo가 가진 음식의 스코빌 지수를 담은 배열 `scoville`과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 `K` 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `scoville`의 길이는 2 이상 1,000,000 이하입니다.\r\n* `K`는 0 이상 1,000,000,000 이하입니다.\r\n* `scoville`의 원소는 각각 0 이상 1,000,000 이하입니다.\r\n* 모든 음식의 스코빌 지수를 `K` 이상으로 만들 수 없는 경우에는 -1을 return 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|        scoville        |   K   | return |\r\n| :--------------------: | :---: | :----: |\r\n| { 1, 2, 3, 9, 10, 12 } |   7   |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\r\n\r\n새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\r\n\r\n가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\r\n\r\n스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\r\n\r\n새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\r\n\r\n가진 음식의 스코빌 지수 = [13, 9, 10, 12]\r\n\r\n모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문제 자체는 간단하다. `scoville` 중 가장 작은 값과 두 번째로 작은 값을 호출하여 섞는다. 이 과정을 수행하여 모든 요소의 값이 `K` 이상이 될 때까지 반복한다.\r\n\r\n만약, 모든 연산을 수행했음에도 `K` 이상이 되지 못 하는 음식이 있을 경우 -1을 반환한다.\r\n\r\n<br />\r\n\r\n뽑아야 하는 요소의 법칙이 정해져 있으므로 조합은 맞지 않다.\r\n\r\n1. 데이터를 호출할 때마다 가장 작은 값이 나와야 한다.\r\n2. 데이터의 삽입, 삭제가 자유롭다.\r\n\r\n얼핏 보면 `ArrayList` 사용해서 정렬하면 되지 않을까? 싶지만 이 방법은 효율성이 극히 떨어진다. 연산을 수행할 때마다 `ArrayList`의 정렬 과정이 필요하기 때문.\r\n\r\n<br />\r\n\r\n이 문제는 `PriorityQueue` 객체를 알고 있다면 쉽게 풀 수 있고, 아니라면 고생 좀 하게 되는 문제다.\r\n\r\n`PriorityQueue`는 이름 그대로 큐지만, 일반적인 LIFO 방식이 아니다. `PriorityQueue`의 독특한 규칙은 아래와 같다.\r\n\r\n1. 데이터의 우선순위를 파악하여 가장 높은 우선순위의 데이터를 먼저 출력\r\n2. 이진트리 방식을 사용하으로 시간복잡도는 $O(N\\log{N})$\r\n3. 베이스는 `Queue`를 따른다.\r\n\r\n`PriorityQueue`의 특징은 이 문제와 매우 적합하다. 각 요소가 숫자로 이루어져 있으므로, 가장 낮은 숫자를 우선순위로 지정하여 데이터를 출력하면, 굳이 정렬을 사용하지 않고도 가장 작은 데이터를 호출할 수 있을 것이다.\r\n\r\n``` java\r\n// 우선순위가 낮은 순\r\nPriorityQueue<Integer> queue = new PriorityQueue<>();\r\n\r\n// 우선순위가 높은 순\r\nPriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\r\n```\r\n\r\n`PriorityQueue`를 선언할 때, 우선순위를 지정할 수 있다.\r\n\r\n이 문제는 가장 작은 수를 최우선으로 뽑아야 하므로, **우선순위가 낮은 순**으로 뽑는 것이 적절할 것이다.\r\n\r\n`PriorityQueue`에서 뽑은 요소가 `K`를 넘지 않을 경우, 아직 덜 매운 음식이 있으므로 연산을 수행한다.\r\n\r\n`K`를 넘는다면, 가장 안 매운 음식도 `K`를 넘으므로 연산을 수행할 필요가 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Objects;\r\nimport java.util.PriorityQueue;\r\n\r\n/**\r\n * 더 맵게 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.27 Mon 13:43:34\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param scoville: [int[]] 음식의 스코빌 지수 배열\r\n\t * @param K: [int] 목표 스코빌 지수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] scoville, int K)\r\n\t{\r\n\t\tint answer;\r\n\t\t\r\n\t\t// 섞을 요소가 부족할 경우\r\n\t\tif (scoville.length < 2)\r\n\t\t{\r\n\t\t\tanswer = -1;\r\n\t\t}\r\n\t\t\r\n\t\t// 섞을 요소가 충분할 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tPriorityQueue<Integer> queue = new PriorityQueue<>();\r\n\t\t\t\r\n\t\t\tanswer = 0;\r\n\t\t\t\r\n\t\t\tfor (int item : scoville)\r\n\t\t\t{\r\n\t\t\t\tqueue.add(item);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile (Objects.requireNonNull(queue.peek()) < K)\r\n\t\t\t{\r\n\t\t\t\t// 섞을 요소가 부족할 경우\r\n\t\t\t\tif (queue.size() < 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer = -1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tqueue.add(Objects.requireNonNull(queue.poll()) + (Objects.requireNonNull(queue.poll()) * 2));\r\n\t\t\t\t\r\n\t\t\t\tanswer++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```\r\n\r\n`queue.poll()`, `queue.peek()`이 `null`을 반환할 가능성이 있으므로, `Objects.requireNonNull()`를 사용하여 관련 오류를 제거한다.\r\n\r\n`Objects.requireNonNull()`가 없어도 동작에 영향은 없다.","url":["2021-12-28-programmers-a0072","2021","12","28","programmers-a0072"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 기능개발 (42586)","excerpt":"프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-27T13:42:49+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-27-programmers-a0071.md","content":"\r\n# 기능개발\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [기능개발](https://programmers.co.kr/learn/courses/30/lessons/42586)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.\r\n\r\n또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.\r\n\r\n먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 `progresses`와 각 작업의 개발 속도가 적힌 정수 배열 `speeds`가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 `solution` 함수를 완성하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 작업의 개수(`progresses`, `speeds`배열의 길이)는 100개 이하입니다.\r\n* 작업 진도는 100 미만의 자연수입니다.\r\n* 작업 속도는 100 이하의 자연수입니다.\r\n* 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         progresses         |        speeds        |   return    |\r\n| :------------------------: | :------------------: | :---------: |\r\n|       { 93, 30, 55 }       |     { 1, 30, 5 }     |  { 2, 1 }   |\r\n| { 95, 90, 99, 99, 80, 99 } | { 1, 1, 1, 1, 1, 1 } | { 1, 3, 2 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\r\n\r\n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\r\n\r\n세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\r\n\r\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\r\n\r\n**입출력 예 #2**\r\n\r\n모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\r\n\r\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n* `progresses`는 현재 진행률을 나타낸다.\r\n* `speeds`는 하루 당 개발 속도를 나타낸다.\r\n\r\n`progresses`와 `speeds`를 적절히 활용하면 개발에 소요되는 기간 데이터를 얻을 수 있을 것이다.\r\n\r\n``` java\r\nint[] days = new int[progresses.length];\r\n\r\nfor (int i = 0; i < progresses.length; i++)\r\n{\r\n\tdays[i] = (int) Math.ceil((100F - progresses[i]) / speeds[i]);\r\n}\r\n```\r\n\r\n100에서 `progresses`을 빼고, 이를 `speeds`로 나누면 기간을 알 수 있다.\r\n\r\n`2.1`, `3.5` 등, 소수점이 발생할 경우 올림한다.\r\n\r\n<br />\r\n\r\n`days` 배열을 탐색하여 기간을 비교하여 배포 배열을 만들어 반환한다.\r\n\r\n배열 요소가 몇 개나 생길지 모르므로, `ArrayList`를 활용한다.\r\n\r\n배포 갯수를 저장할 `count`, 기간 값을 비교할 `target`을 선언하고, `days`를 탐색한다.\r\n\r\n`count`의 초기값은 1, `target`의 초기값은  `days[0]`이다.\r\n\r\n<br />\r\n\r\n``` java\r\nArrayList<Integer> list = new ArrayList<>();\r\n\r\nint count = 1;\r\nint target = days[0];\r\n\r\nfor (int i = 1; i < days.length; i++)\r\n{\r\n\t// 이 작업이 훨씬 오래 걸릴 경우\r\n\tif (target < days[i])\r\n\t{\r\n\t\ttarget = days[i];\r\n\t\t\r\n\t\tlist.add(count);\r\n\t\t\r\n\t\tcount = 1;\r\n\t}\r\n\t\r\n\t// 이미 완료됐을 경우\r\n\telse\r\n\t{\r\n\t\tcount++;\r\n\t}\r\n}\r\n\r\nlist.add(count);\r\n```\r\n\r\n`days[1]`부터 탐색하여 `days[i]`와 `target`을 비교한다.\r\n\r\n만약 `days[i]`가 더 클 경우, 배포하는데 시간이 더 필요하므로, 현재까지 배포된 갯수를 `ArrayList`에 저장하고, `count`를 초기화한다. `target` 또한 `days[i]`으로 재할당한다.\r\n\r\n만약 `target`이 아직 더 클 경우, 이미 개발이 끝난 기능이므로, `target`이 배포될 때 같이 배포할 수 있다. `count`만 증가시킨다.\r\n\r\n`for`문을 다 돌면 마지막 데이터가 반영되지 않으므로, 마지막으로 `count`를 따로 저장한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 기능개발 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.27 Mon 12:40:08\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param progresses: [int[]] 자연수\r\n\t * @param speeds: [int[]] 자연수\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] progresses, int[] speeds)\r\n\t{\r\n\t\tint[] days = new int[progresses.length];\r\n\t\t\r\n\t\tfor (int i = 0; i < progresses.length; i++)\r\n\t\t{\r\n\t\t\tdays[i] = (int) Math.ceil((100F - progresses[i]) / speeds[i]);\r\n\t\t}\r\n\t\t\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tint count = 1;\r\n\t\tint target = days[0];\r\n\t\t\r\n\t\tfor (int i = 1; i < days.length; i++)\r\n\t\t{\r\n\t\t\t// 이 작업이 훨씬 오래 걸릴 경우\r\n\t\t\tif (target < days[i])\r\n\t\t\t{\r\n\t\t\t\ttarget = days[i];\r\n\t\t\t\t\r\n\t\t\t\tlist.add(count);\r\n\t\t\t\t\r\n\t\t\t\tcount = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 이미 완료됐을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlist.add(count);\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-27-programmers-a0071","2021","12","27","programmers-a0071"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 124 나라의 숫자 (12899)","excerpt":"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-27T01:42:47+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-27-programmers-a0070.md","content":"\r\n# 124 나라의 숫자\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [124 나라의 숫자](https://programmers.co.kr/learn/courses/30/lessons/12899)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.\r\n\r\n* 124 나라에는 자연수만 존재합니다.\r\n* 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.\r\n\r\n예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.\r\n\r\n| 10진법 | 124 나라 | 10진법 | 124 나라 |\r\n| :----: | :------: | :----: | :------: |\r\n|   1    |    1     |   6    |    14    |\r\n|   2    |    2     |   7    |    21    |\r\n|   3    |    4     |   8    |    22    |\r\n|   4    |    11    |   9    |    24    |\r\n|   5    |    12    |   10   |    41    |\r\n\r\n자연수 `n`이 매개변수로 주어질 때, `n`을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `n`은 500,000,000이하의 자연수 입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|   1   |   1    |\r\n|   2   |   2    |\r\n|   3   |   4    |\r\n|   4   |   11   |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n124 나라라는 이상한 나라가 있다.\r\n\r\n국제적으로 통용되는 10진법을 쓰지 않고, 굳이 124 법칙이라는 이상한 진법을 고수하여 당신을 피곤하게 만들고 있다.\r\n\r\n이 124 진법을 해석하는 알고리즘을 구성하여 만성 피로에서 벗어나보자.\r\n\r\n<br />\r\n\r\n규칙 자체는 별거 없다. `[ 1, 2, 4 ]` 순으로 번갈아가며 숫자가 표기된다.\r\n\r\n| 10진법 | 124 나라 |\r\n| :----: | :------: |\r\n|   1    |    1     |\r\n|   2    |    2     |\r\n|   3    |    4     |\r\n|   4    |    11    |\r\n|   5    |    12    |\r\n|   6    |    14    |\r\n|   7    |    21    |\r\n|   8    |    22    |\r\n|   9    |    24    |\r\n|   10   |    41    |\r\n|   11   |    42    |\r\n|   12   |    44    |\r\n|   13   |   111    |\r\n|   14   |   112    |\r\n|   15   |   114    |\r\n\r\n대충 이런 식으로 전개된다. 끝에 3이 아닌 4가 껴버리는 바람에 살짝 헷갈릴 수 있다.\r\n\r\n규칙적인 데이터을 가지고 있으므로, 이를 통해 패턴을 유추해보자.\r\n\r\n숫자 3개로 표현되니, 3진법을 만드는 방식과 매우 유사할 것이다.\r\n\r\n<br />\r\n\r\n`MOD 연산`을 통해 124 진법으로 변환할 수 있다.\r\n\r\n1. `n % 3` 연산을 수행하여 나머지를 구한다.\r\n2. `n / 3` 연산을 수행하여 `n`에 할당한다.\r\n   1. 만약 `n % 3 == 0`일 경우 할당된 `n`에서 1을 뺀다.\r\n3. `n = 0`일 때까지 위 과정을 반복한다.\r\n\r\n`n = 5`일 경우, 아래와 같다.\r\n\r\n1. `5 % 3` 연산을 수행하여 나머지 2를 구한다.\r\n   1. 124의 두 번째 숫자는 2이므로, 첫 번째 자리는 2가 된다.\r\n2. `5 / 3` 연산을 수행하여 `n`을 1로 할당한다.\r\n3. `1 % 3` 연산을 수행하여 나머지 1을 구한다.\r\n   1. 124의 첫 번째 숫자는 1이므로, 두 번째 자리는 1이 된다.\r\n4. `1 / 3` 연산을 수행하여 `n`을 0으로 할당한다.\r\n5. `n = 0`이므로 종료한다. `5`는 124 진법으로 `12`가 된다. \r\n\r\n그러나 `n % 3 == 0`일 경우 특이한 조건이 붙는데, 이는 3의 배수를 직접 연산해보면 알 수 있다.\r\n\r\n1. `6 % 3` 연산을 수행하여 나머지 0을 구한다.\r\n   1. 124의 0 번째 숫자는 4이므로, 첫 번째 자리는 4가 된다.\r\n2. `6 / 3` 연산을 수행하여 `n`을 2로 할당한다.\r\n3. `2 % 3` 연산을 수행하여 나머지 2을 구한다.\r\n   1. 124의 두 번째 숫자는 2이므로, 두 번째 자리는 2가 된다.\r\n4. `2 / 3` 연산을 수행하여 `n`을 0으로 할당한다.\r\n5. `n = 0`이므로 종료한다. `6`은 124 진법으로 `24`가 된다...?\r\n\r\n계산에 의하면 24가 되는데, 실제로는 14다. 3의 배수일 경우, 자릿수가 하나 올라가기 때문에, `n`을 하나 빼서 이를 보정해줘야 한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * 124 나라의 숫자 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.27 Mon 00:36:19\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final String[] DIGIT = { \"4\", \"1\", \"2\" };\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int n)\r\n\t{\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (n != 0)\r\n\t\t{\r\n\t\t\tint index = n % 3;\r\n\t\t\t\r\n\t\t\tn /= 3;\r\n\t\t\t\r\n\t\t\t// 인덱스가 0일 경우\r\n\t\t\tif (index == 0)\r\n\t\t\t{\r\n\t\t\t\tn--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlist.add(DIGIT[index]);\r\n\t\t}\r\n\t\t\r\n\t\tCollections.reverse(list);\r\n\t\t\r\n\t\treturn list.stream().reduce(String::concat).isPresent() ? list.stream().reduce(String::concat).get() : \"\";\r\n\t}\r\n}\r\n```","url":["2021-12-27-programmers-a0070","2021","12","27","programmers-a0070"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 멀쩡한 사각형 (62048)","excerpt":"가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다. 가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-27T00:35:33+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-27-programmers-a0069.md","content":"\r\n# 멀쩡한 사각형\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [멀쩡한 사각형](https://programmers.co.kr/learn/courses/30/lessons/62048)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.\r\n\r\n가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `W`, `H` : 1억 이하의 자연수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   W   |   H   | result |\r\n| :---: | :---: | :----: |\r\n|   8   |  12   |   80   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다.\r\n\r\n![image](https://grepp-programmers.s3.amazonaws.com/files/production/ee895b2cd9/567420db-20f4-4064-afc3-af54c4a46016.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n단서가 없으니 주어진 정보를 통해 패턴을 유추해보자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147412264-f08885da-f966-4508-ae9d-0623521e252e.png)\r\n\r\n특정 지점마다 선분이 정확히 교차하는 곳이 존재하며, 해당 부분을 위 그림에서 파란색 원으로 표시했다.\r\n\r\n파란색 원의 좌표값은 `(2, 3)`, `(4, 6)`, `(6, 8)`, `(8, 12)`이 된다.\r\n\r\n즉, `(2, 3)`부터 정확히 2씩 좌표값이 더해지며, 총 4번의 동일한 패턴이 관측된다.\r\n\r\n`(8, 12) -> (2, 3)`은 각 좌표값을 4로 나누어 얻을 수 있는데, 여기서 4는 `w`와 `h`의 값인 8과 12의 최대공약수다.\r\n\r\n따라서, `w`, `h`, `w`와 `h`의 최대공약수를 적절히 계산하면 일반식을 도출할 수 있다.\r\n\r\n<br />\r\n\r\n패턴을 발견했으니, 해당 패턴의 직사각형에서 제외되는 직사각형의 일반식을 구하기만 하면 된다.\r\n\r\n패턴이 최대공약수만큼 반복되므로, 일반식을 유추하면 아래와 같다.\r\n\r\n`사용 가능한 직사각형 수 = 전체 직사각형 수 - (패턴에서 제외되는 직사각형 수 * 최대공약수)`\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147412826-ffc6da45-c266-4752-950e-575544bd7984.png)\r\n\r\n각 패턴별로 분석하면 패턴에서 제외되는 직사각형 수를 쉽게 알 수 있다.\r\n\r\n1. `(2, 3)` 짜리 직사각형. 4개의 직사각형이 영향을 받는다.\r\n2. `(5, 2)` 짜리 직사각형. 6개의 직사각형이 영향을 받는다.\r\n3. `(1, 1)` 짜리 직사각형. 1개의 직사각형이 영향을 받는다.\r\n\r\n이러한 패턴으로 미루어볼 때, 패턴에서 제외되는 직사각형의 수는 `가로 + 세로 - 1`이 된다.\r\n\r\n<br />\r\n\r\n따라서 최종적인 일반식은 아래와 같다.\r\n\r\n`(w * h) - (((w / gcd) + (h / gcd) - 1) * gcd)`가 된다.\r\n\r\n반환값이 `long`이므로, `int`를 반환하지 않도록 주의하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 멀쩡한 사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.26 Sun 22:31:31\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param w: [int] 가로 길이\r\n\t * @param h: [int] 세로 길이\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic long solution(int w, int h)\r\n\t{\r\n\t\tlong ref = gcd(w, h);\r\n\t\t\r\n\t\treturn ((long) w * h) - (((w / ref) + (h / ref) - 1) * ref);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유클리드 호제법 연산결과 반환 메서드\r\n\t *\r\n\t * @param n: [int] 정수 1\r\n\t * @param m: [int] 정수 2\r\n\t *\r\n\t * @return [int] 최대공약수\r\n\t */\r\n\tprivate int gcd(int n, int m)\r\n\t{\r\n\t\twhile (m != 0)\r\n\t\t{\r\n\t\t\tint r = n % m;\r\n\t\t\t\r\n\t\t\tn = m;\r\n\t\t\tm = r;\r\n\t\t}\r\n\t\t\r\n\t\treturn n;\r\n\t}\r\n}\r\n```","url":["2021-12-27-programmers-a0069","2021","12","27","programmers-a0069"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 단체사진 찍기 (1835)","excerpt":"가을을 맞아 카카오프렌즈는 단체로 소풍을 떠났다. 즐거운 시간을 보내고 마지막에 단체사진을 찍기 위해 카메라 앞에 일렬로 나란히 섰다. 그런데 각자가 원하는 배치가 모두 달라 어떤 순서로 설지 정하는데 시간이 오래 걸렸다. 네오는 프로도와 나란히 서기를 원했고, 튜브가 뿜은 불을 맞은 적이 있던 라이언은 튜브에게서 적어도 세 칸 이상 떨어져서 서기를 원했다. 사진을 찍고 나서 돌아오는 길에, 무지는 모두가 원하는 조건을 만족하면서도 다르게 서는 방법이 있지 않았을까 생각해보게 되었다. 각 프렌즈가 원하는 조건을 입력으로 받았을 때 모든 조건을 만족할 수 있도록 서는 경우의 수를 계산하는 프로그램을 작성해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-26T22:09:38+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-26-programmers-a0068.md","content":"\r\n# 단체사진 찍기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [단체사진 찍기](https://programmers.co.kr/learn/courses/30/lessons/1829)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://t1.kakaocdn.net/codefestival/picture.png)\r\n\r\n가을을 맞아 카카오프렌즈는 단체로 소풍을 떠났다. 즐거운 시간을 보내고 마지막에 단체사진을 찍기 위해 카메라 앞에 일렬로 나란히 섰다. 그런데 각자가 원하는 배치가 모두 달라 어떤 순서로 설지 정하는데 시간이 오래 걸렸다. 네오는 프로도와 나란히 서기를 원했고, 튜브가 뿜은 불을 맞은 적이 있던 라이언은 튜브에게서 적어도 세 칸 이상 떨어져서 서기를 원했다. 사진을 찍고 나서 돌아오는 길에, 무지는 모두가 원하는 조건을 만족하면서도 다르게 서는 방법이 있지 않았을까 생각해보게 되었다. 각 프렌즈가 원하는 조건을 입력으로 받았을 때 모든 조건을 만족할 수 있도록 서는 경우의 수를 계산하는 프로그램을 작성해보자.\r\n\r\n\r\n\r\n\r\n\r\n## 입력 형식\r\n\r\n입력은 조건의 개수를 나타내는 정수 `n`과 `n`개의 원소로 구성된 문자열 배열 data로 주어진다. `data`의 원소는 각 프렌즈가 원하는 조건이 `N~F=0`과 같은 형태의 문자열로 구성되어 있다. 제한조건은 아래와 같다.\r\n\r\n* 1 <= n <= 100\r\n* data의 원소는 다섯 글자로 구성된 문자열이다. 각 원소의 조건은 다음과 같다.\r\n  * 첫 번째 글자와 세 번째 글자는 다음 8개 중 하나이다. `{ A, C, F, J, M, N, R, T }` 각각 어피치, 콘, 프로도, 제이지, 무지, 네오, 라이언, 튜브를 의미한다. 첫 번째 글자는 조건을 제시한 프렌즈, 세 번째 글자는 상대방이다. 첫 번째 글자와 세 번째 글자는 항상 다르다.\r\n  * 두 번째 글자는 항상 `~`이다.\r\n  * 네 번째 글자는 다음 3개 중 하나이다. `{ =, <, > }` 각각 같음, 미만, 초과를 의미한다.\r\n  * 다섯 번째 글자는 0 이상 6 이하의 정수의 문자형이며, 조건에 제시되는 간격을 의미한다. 이때 간격은 두 프렌즈 사이에 있는 다른 프렌즈의 수이다.\r\n\r\n\r\n\r\n\r\n\r\n## 출력 형식\r\n\r\n모든 조건을 만족하는 경우의 수를 리턴한다.\r\n\r\n\r\n\r\n\r\n\r\n## 예제 입출력\r\n\r\n|   n   |         data         | answer |\r\n| :---: | :------------------: | :----: |\r\n|   2   | { \"N~F=0\", \"R~T>2\" } |  3648  |\r\n|   2   | { \"M~C<2\", \"C~M>1\" } |   0    |\r\n\r\n\r\n\r\n### 예제에 대한 설명\r\n\r\n첫 번째 예제는 문제에 설명된 바와 같이, 네오는 프로도와의 간격이 0이기를 원하고 라이언은 튜브와의 간격이 2보다 크기를 원하는 상황이다.\r\n\r\n두 번째 예제는 무지가 콘과의 간격이 2보다 작기를 원하고, 반대로 콘은 무지와의 간격이 1보다 크기를 원하는 상황이다. 이는 동시에 만족할 수 없는 조건이므로 경우의 수는 0이다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n카카오 프렌즈들이 순서대로 서서 사진을 찍을 때, 각자 원하는 조건을 모두 충족하는 경우의 수를 구해야 한다.\r\n\r\n이 경우, 배치가 중요하므로, 순열이 적합할 것이다.\r\n\r\n<br />\r\n\r\n순열 알고리즘을 구현하여 모든 경우의 수를 파악하고, 각 경우의 수마다 조건을 비교하여 해당되는 조건만 카운팅하면 될 것이다.\r\n\r\n``` java\r\nprivate void permutation(String[] output, boolean[] isVisit, int depth, int n, String[] data)\r\n{\r\n\t// 마지막에 도달했을 경우\r\n\tif (depth == NAMES.length)\r\n\t{\r\n\t\tanswer += isValidate(n, data, output) ? 1 : 0;\r\n\t\t\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfor (int i = 0; i < NAMES.length; i++)\r\n\t{\r\n\t\t// 방문하지 않았을 경우\r\n\t\tif (!isVisit[i])\r\n\t\t{\r\n\t\t\tisVisit[i] = true;\r\n\t\t\t\r\n\t\t\toutput[depth] = NAMES[i];\r\n\t\t\t\r\n\t\t\tpermutation(output, isVisit, depth + 1, n, data);\r\n\t\t\t\r\n\t\t\tisVisit[i] = false;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n구현한 순열 알고리즘은 위와 같다.\r\n\r\n모든 경우의 수 계산이 끝나게 되면, `isValidate` 메서드로 조건이 일치하는지 여부를 파악한다.\r\n\r\n제시된 조건에서 하나라도 일치하지 않을 경우 `false`를 반환하고, 모든 조건을 검사했음에도 문제가 없다면 `true`를 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 단체사진 찍기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.26 Sun 20:35:07\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final String[] NAMES = { \"A\", \"C\", \"F\", \"J\", \"M\", \"N\", \"R\", \"T\" };\r\n\tprivate int answer;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 조건의 갯수\r\n\t * @param data: [String[]] 조건\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n, String[] data)\r\n\t{\r\n\t\tanswer = 0;\r\n\t\t\r\n\t\tint count = NAMES.length;\r\n\t\t\r\n\t\tString[] output = new String[count];\r\n\t\t\r\n\t\tboolean[] isVisit = new boolean[count];\r\n\t\t\r\n\t\tpermutation(output, isVisit, 0, n, data);\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 순열 메서드\r\n\t *\r\n\t * @param output: [String[]] 결과 저장 배열\r\n\t * @param isVisit: [boolean[]] 방문 여부 배열\r\n\t * @param depth: [int] 카운팅\r\n\t * @param data: [String[]] 조건\r\n\t * @param n: [int] 조건의 갯수\r\n\t */\r\n\tprivate void permutation(String[] output, boolean[] isVisit, int depth, int n, String[] data)\r\n\t{\r\n\t\t// 마지막에 도달했을 경우\r\n\t\tif (depth == NAMES.length)\r\n\t\t{\r\n\t\t\tanswer += isValidate(n, data, output) ? 1 : 0;\r\n\t\t\t\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < NAMES.length; i++)\r\n\t\t{\r\n\t\t\t// 방문하지 않았을 경우\r\n\t\t\tif (!isVisit[i])\r\n\t\t\t{\r\n\t\t\t\tisVisit[i] = true;\r\n\t\t\t\t\r\n\t\t\t\toutput[depth] = NAMES[i];\r\n\t\t\t\t\r\n\t\t\t\tpermutation(output, isVisit, depth + 1, n, data);\r\n\t\t\t\t\r\n\t\t\t\tisVisit[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조건 검증결과 반환 메서드\r\n\t *\r\n\t * @param n: [int] 조건의 갯수\r\n\t * @param data: [String[]] 조건\r\n\t * @param output: [String[]] 결과 저장 배열\r\n\t *\r\n\t * @return [boolean] 조건 검증결과\r\n\t */\r\n\tprivate boolean isValidate(int n, String[] data, String[] output)\r\n\t{\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (String out : output)\r\n\t\t{\r\n\t\t\tbuilder.append(out);\r\n\t\t}\r\n\t\t\r\n\t\tString text = builder.toString();\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tString[] temp = data[i].split(\"\");\r\n\t\t\t\r\n\t\t\tString name1 = temp[0];\r\n\t\t\tString name2 = temp[2];\r\n\t\t\tString operation = temp[3];\r\n\t\t\t\r\n\t\t\tint distance = Integer.parseInt(temp[4]);\r\n\t\t\t\r\n\t\t\tint realDistance = Math.abs(text.indexOf(name1) - text.indexOf(name2)) - 1;\r\n\t\t\t\r\n\t\t\t// > 조건과 일치하지 않을 경우\r\n\t\t\tif (operation.equals(\">\") && realDistance <= distance)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// = 조건과 일치하지 않을 경우\r\n\t\t\telse if (operation.equals(\"=\") && realDistance != distance)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// < 조건과 일치하지 않을 경우\r\n\t\t\telse if (operation.equals(\"<\") && realDistance >= distance)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```","url":["2021-12-26-programmers-a0068","2021","12","26","programmers-a0068"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 카카오프렌즈 컬러링북 (1829)","excerpt":"출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.) 그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-26T16:34:11+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-26-programmers-a0067.md","content":"\r\n# 카카오프렌즈 컬러링북\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [카카오프렌즈 컬러링북](https://programmers.co.kr/learn/courses/30/lessons/1829)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.)\r\n\r\n그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자.\r\n\r\n![image](http://t1.kakaocdn.net/codefestival/apeach.png)\r\n\r\n위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다.\r\n\r\n\r\n\r\n\r\n\r\n## 입력 형식\r\n\r\n입력은 그림의 크기를 나타내는 `m`과 `n`, 그리고 그림을 나타내는 `m × n` 크기의 2차원 배열 `picture`로 주어진다. 제한조건은 아래와 같다.\r\n\r\n* `1 <= m`, `n <= 100`\r\n* `picture`의 원소는 0 이상 2^31 - 1 이하의 임의의 값이다.\r\n* `picture`의 원소 중 값이 0인 경우는 색칠하지 않는 영역을 뜻한다.\r\n\r\n\r\n\r\n\r\n\r\n## 출력 형식\r\n\r\n리턴 타입은 원소가 두 개인 정수 배열이다. 그림에 몇 개의 영역이 있는지와 가장 큰 영역은 몇 칸으로 이루어져 있는지를 리턴한다.\r\n\r\n\r\n\r\n\r\n\r\n## 예제 입출력\r\n\r\n|   m   |   n   |                                              picture                                               |  answer  |\r\n| :---: | :---: | :------------------------------------------------------------------------------------------------: | :------: |\r\n|   6   |   4   | { { 1, 1, 1, 0 }, { 1, 2, 2, 0 }, { 1, 0, 0, 1 }, { 0, 0, 0, 1 }, { 0, 0, 0, 3 }, { 0, 0, 0, 3 } } | { 4, 5 } |\r\n\r\n\r\n\r\n### 예제에 대한 설명\r\n\r\n예제로 주어진 그림은 총 4개의 영역으로 구성되어 있으며, 왼쪽 위의 영역과 오른쪽의 영역은 모두 1로 구성되어 있지만 상하좌우로 이어져있지 않으므로 다른 영역이다. 가장 넓은 영역은 왼쪽 위 1이 차지하는 영역으로 총 5칸이다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n그림을 구역별로 나눠, 색을 숫자로 표시한 `pitcture`가 제공된다. 이 그림들이 같은 색끼리 인접한 영역의 수와, 영역 중 가장 넓은 영역의 크기를 계산해야한다.\r\n\r\n이렇게 서로 인접한 영역을 구하는 문제의 경우 **BFS 알고리즘**을 적용하는 것이 좋다.\r\n\r\n<br />\r\n\r\nBFS 알고리즘은 너비 우선 탐색이라고도 불린다.\r\n\r\n* 너비를 중심으로 탐색\r\n* 노드의 깊이가 얕을수록 유리\r\n* `Queue`를 활용하여 구현\r\n\r\n`picture`의 요소 하나하나를 탐색하여 유효한 색을 가진 영역이 발견될 경우, BFS 알고리즘을 인접 영역을 탐색한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/147405712-4ce218db-30d1-448c-ac53-93fd4b6793eb.png)\r\n\r\n1. 색이 존재하는 영역 1을 큐에 넣고, 방문 여부에 체크한다. 이후 큐에서 삭제한다.\r\n2. 영역 1을 기준으로, 거리가 1인 영역을 탐색한다. 2를 큐에 넣는다.\r\n3. 똑같이 거리가 1인 영역 4를 큐에 넣는다.\r\n4. 가장 마지막에 입력된 영역 2를 탐색한다. 방문여부를 체크하고, 큐에서 삭제한다.\r\n5. 영역 4를 탐색한다. 방문여부를 체크하고, 큐에서 삭제한다. 탐색 과정에서 인접한 영역인 7을 큐에 삽입한다.\r\n6. 영역 7을 탐색한다. 방문여부를 체크하고, 큐에서 삭제한다.\r\n\r\n이런 식으로, 거리에 따라 순차적으로 탐색을 수행한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 카카오프렌즈 컬러링북 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.25 Sat 13:52:12\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final int[] DX = { 0, 0, -1, 1 };\r\n\tprivate static final int[] DY = { -1, 1, 0, 0 };\r\n\t\r\n\tprivate boolean[][] isVisit;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param m: [int] 그림의 높이\r\n\t * @param n: [int] 그림의 길이\r\n\t * @param picture: [int[][]] 그림 원화\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int m, int n, int[][] picture)\r\n\t{\r\n\t\tint[] answer = { 0, 0 };\r\n\t\t\r\n\t\t// picture를 직접 수정하면 문제에서 오류를 일으킴\r\n\t\tint[][] copy = picture.clone();\r\n\t\t\r\n\t\tisVisit = new boolean[m][n];\r\n\t\t\r\n\t\tfor (int i = 0; i < copy.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < copy[i].length; j++)\r\n\t\t\t{\r\n\t\t\t\t// 원화가 유효한 색을 가지고, 아직 방문하지 않았을 경우\r\n\t\t\t\tif (copy[i][j] > 0 && !isVisit[i][j])\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer[0]++;\r\n\t\t\t\t\tanswer[1] = Math.max(answer[1], bfs(m, n, i, j, copy));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 우선 탐색 알고리즘 결과 반환 메서드\r\n\t *\r\n\t * @param m: [int] 그림의 높이\r\n\t * @param n: [int] 그림의 길이\r\n\t * @param x: [int] 기준 인덱스 x\r\n\t * @param y: [int] 기준 인덱스 y\r\n\t * @param picture: [int[][]] 그림 원화\r\n\t *\r\n\t * @return [int] 영역의 크기\r\n\t */\r\n\tprivate int bfs(int m, int n, int x, int y, int[][] picture)\r\n\t{\r\n\t\tint size = 1;\r\n\t\t\r\n\t\tisVisit[x][y] = true;\r\n\t\t\r\n\t\tQueue<int[]> queue = new LinkedList<>();\r\n\t\tqueue.offer(new int[] { x, y });\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\tint[] position = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tint dx = position[0] + DX[i];\r\n\t\t\t\tint dy = position[1] + DY[i];\r\n\t\t\t\t\r\n\t\t\t\t// dx와 dy가 전체 영역과 기준 인덱스 사이에 있으면서, 동일한 색을 가지고, 아직 체크하지 않았을 경우\r\n\t\t\t\tif (dx > -1 && dx < m && dy > -1 && dy < n && picture[dx][dy] == picture[x][y] && !isVisit[dx][dy])\r\n\t\t\t\t{\r\n\t\t\t\t\tqueue.offer(new int[] { dx, dy });\r\n\t\t\t\t\t\r\n\t\t\t\t\tisVisit[dx][dy] = true;\r\n\t\t\t\t\t\r\n\t\t\t\t\tsize++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n}\r\n```\r\n\r\n`DX`와 `DY`는 각각 x좌표의 이동, y좌표의 이동을 상하좌우로 나타낸 것이다.\r\n\r\n상하좌우임에도 `DY`가 `[ 1, -1, 0, 0 ]`이 아니라 `[ -1, 1, 0, 0 ]`인 이유는, `picture[0][1]`에서 밑으로 내려가면 `picture[0][2]`로 y값이 1 증가하기 때문.\r\n\r\n`bfs` 메서드를 선언하여 BFS 알고리즘을 수행한다.\r\n\r\n같은 색을 가진 인접 영역을 발견할 때마다 `size`에 값을 누적하여 영역 크기를 구할 수 있다.","url":["2021-12-26-programmers-a0067","2021","12","26","programmers-a0067"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 오픈채팅방 (42888)","excerpt":"카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다. 신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-26T16:34:11+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-26-programmers-a0066.md","content":"\r\n# 오픈채팅방\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [오픈채팅방](https://programmers.co.kr/learn/courses/30/lessons/42888)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.\r\n\r\n신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\r\n\r\n* \"[닉네임]님이 들어왔습니다.\"\r\n\r\n채팅방에서 누군가 나가면 다음 메시지가 출력된다.\r\n\r\n* \"[닉네임]님이 나갔습니다.\"\r\n\r\n<br />\r\n\r\n채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\r\n\r\n채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.\r\n\r\n채팅방에서 닉네임을 변경한다.\r\n\r\n닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.\r\n\r\n<br />\r\n\r\n예를 들어, 채팅방에 \"Muzi\"와 \"Prodo\"라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.\r\n\r\n* \"Muzi님이 들어왔습니다.\"\r\n* \"Prodo님이 들어왔습니다.\"\r\n\r\n채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.\r\n\r\n* \"Muzi님이 들어왔습니다.\"\r\n* \"Prodo님이 들어왔습니다.\"\r\n* \"Muzi님이 나갔습니다.\"\r\n\r\nMuzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.\r\n\r\n* \"Prodo님이 들어왔습니다.\"\r\n* \"Prodo님이 들어왔습니다.\"\r\n* \"Prodo님이 나갔습니다.\"\r\n* \"Prodo님이 들어왔습니다.\"\r\n\r\n채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.\r\n\r\n* \"Prodo님이 들어왔습니다.\"\r\n* \"Ryan님이 들어왔습니다.\"\r\n* \"Prodo님이 나갔습니다.\"\r\n* \"Prodo님이 들어왔습니다.\"\r\n\r\n채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `record`는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다.\r\n* 다음은 `record`에 담긴 문자열에 대한 설명이다.\r\n  * 모든 유저는 [유저 아이디]로 구분한다.\r\n  * [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - \"Enter [유저 아이디] [닉네임]\" (ex. \"Enter uid1234 Muzi\")\r\n  * [유저 아이디] 사용자가 채팅방에서 퇴장 - \"Leave [유저 아이디]\" (ex. \"Leave uid1234\")\r\n  * [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - \"Change [유저 아이디] [닉네임]\" (ex. \"Change uid1234 Muzi\")\r\n  * 첫 단어는 Enter, Leave, Change 중 하나이다.\r\n  * 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.\r\n  * 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.\r\n  * 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다.\r\n  * 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                                                   record                                                    |                                                   result                                                    |\r\n| :---------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------: |\r\n| { \"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\" } | { \"Prodo님이 들어왔습니다.\", \"Ryan님이 들어왔습니다.\", \"Prodo님이 나갔습니다.\", \"Prodo님이 들어왔습니다.\" } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 설명과 같다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n카카오톡 오픈채팅방은 설정에 따라 원하는 닉네임을 임의로 지정하고, 언제든지 변경하여 사용할 수 있다.\r\n\r\n오픈톡방에 들어오게 되면, 채팅방에 들어온 사람의 닉네임을 표시해준다. 또한, 채팅을 칠 때마다 닉네임과 프로필 사진을 같이 표시해준다.\r\n\r\n만약 여기서 닉네임을 변경하면? 변경하기 이전의 프로필 정보와 닉네임까지 모두 반영되어 표시된다. 우리가 구현해야할 것도 이와 동일하다.\r\n\r\n<br />\r\n\r\n닉네임은 가변성이 짙으므로, 고유값인 아이디를 기준으로 데이터를 저장해야한다. `Map` 계열 자료구조가 적합할 것이다. 아이디와 닉네임을 저장하며, 각 명령어에 따른 동작을 구현하자.\r\n\r\n* Enter: 아이디와 닉네임 저장\r\n* Change: 해당 아이디의 닉네임 변경\r\n* Leave: 동작 없음\r\n\r\nEnter일 경우, `Map`에 아이디와 닉네임을 저장한다. Change일 경우, `Map`에 변경된 닉네임을 갱신한다.\r\n\r\n모든 명령어를 분석하게되면, 최종적으로 변경된 아이디별 닉네임을 획득할 수 있다.\r\n\r\n<br />\r\n\r\n이제 순서대로 명령어에 따른 문구를 출력하면 된다. `List` 객체를 활용하여 문구를 저장한 뒤, 배열로 반환한다.\r\n\r\n* Enter: 오픈톡방 입장 안내 메시지 출력\r\n* Change: 동작 없음\r\n* Leave: 오픈톡방 퇴장 안내 메시지 출력\r\n\r\n아이디에 매칭되는 닉네임은 `Map`에서 획득한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 오픈채팅방 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 23:00:15\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param record: [String[]] 닉네임 변경 기록\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic String[] solution(String[] record)\r\n\t{\r\n\t\tArrayList<String[]> list = new ArrayList<>();\r\n\t\t\r\n\t\tHashMap<String, String> ids = new HashMap<>();\r\n\t\t\r\n\t\tfor (String text : record)\r\n\t\t{\r\n\t\t\tString[] texts = text.split(\" \");\r\n\t\t\t\r\n\t\t\tswitch (texts[0])\r\n\t\t\t{\r\n\t\t\t\tcase \"Enter\" -> {\r\n\t\t\t\t\tlist.add(new String[] { texts[0], texts[1] });\r\n\t\t\t\t\t\r\n\t\t\t\t\t// ID가 이미 기록된 경우\r\n\t\t\t\t\tif (ids.containsKey(texts[1]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tids.replace(texts[1], texts[2]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 아닐 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tids.put(texts[1], texts[2]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcase \"Change\" -> ids.replace(texts[1], texts[2]);\r\n\t\t\t\tcase \"Leave\" -> list.add(new String[] { texts[0], texts[1] });\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream()\r\n\t\t\t\t.map(strings -> new StringBuilder(ids.get(strings[1])).append(strings[0].equals(\"Enter\") ? \"님이 들어왔습니다.\" : \"님이 나갔습니다.\").toString())\r\n\t\t\t\t.toArray(String[]::new);\r\n\t}\r\n}\r\n```","url":["2021-12-26-programmers-a0066","2021","12","26","programmers-a0066"]},{"header":{"title":"[프로그래머스 / JAVA] Level 2 문자열 압축 (60057)","excerpt":"데이터 처리 전문가가 되고 싶은 \"어피치\"는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 \"aabbaccc\"의 경우 \"2a2ba3c\"(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, \"abcabcdede\"와 같은 문자열은 전혀 압축되지 않습니다. \"어피치\"는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-26T02:37:58+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 2"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-26-programmers-a0065.md","content":"\r\n# 문자열 압축\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 2 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열 압축](https://programmers.co.kr/learn/courses/30/lessons/60057)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n데이터 처리 전문가가 되고 싶은 \"어피치\"는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.\r\n\r\n간단한 예로 \"aabbaccc\"의 경우 \"2a2ba3c\"(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, \"abcabcdede\"와 같은 문자열은 전혀 압축되지 않습니다. \"어피치\"는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.\r\n\r\n예를 들어, \"ababcdcdababcdcd\"의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 \"2ab2cd2ab2cd\"로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 \"2ababcdcd\"로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.\r\n\r\n다른 예로, \"abcabcdede\"와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 \"abcabc2de\"가 되지만, 3개 단위로 자른다면 \"2abcdede\"가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.\r\n\r\n압축할 문자열 `s`가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `s`의 길이는 1 이상 1,000 이하입니다.\r\n* `s`는 알파벳 소문자로만 이루어져 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|             s              | result |\r\n| :------------------------: | :----: |\r\n|         \"aabbaccc\"         |   7    |\r\n|     \"ababcdcdababcdcd\"     |   9    |\r\n|        \"abcabcdede\"        |   8    |\r\n| \"abcabcabcabcdededededede\" |   14   |\r\n|    \"xababcdcdababcdcd\"     |   17   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.\r\n\r\n**입출력 예 #3**\r\n\r\n문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.\r\n\r\n**입출력 예 #4**\r\n\r\n문자열을 2개 단위로 자르면 \"abcabcabcabc6de\" 가 됩니다.\r\n\r\n문자열을 3개 단위로 자르면 \"4abcdededededede\" 가 됩니다.\r\n\r\n문자열을 4개 단위로 자르면 \"abcabcabcabc3dede\" 가 됩니다.\r\n\r\n문자열을 6개 단위로 자를 경우 \"2abcabc2dedede\"가 되며, 이때의 길이가 14로 가장 짧습니다.\r\n\r\n**입출력 예 #5**\r\n\r\n문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.\r\n\r\n따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.\r\n\r\n이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문자열의 비손실 압축 알고리즘을 구현해야한다.\r\n\r\n1. 문자열을 앞에서부터 `n`만큼 잘라서 기준이 되는 압축 대상 문자열을 생성한다.\r\n2. 문자열의 내용을 비교하여 압축 대상과 동일할 경우, 압축한다.\r\n   1. 만약 하나만 압축될 경우, 압축의 의미가 없으므로 숫자를 생략하고 `abc`와 같이 표현한다.\r\n   2. 두 개 이상 압축될 경우, `2abc`와 같이 표현한다.\r\n3. 압축 대상의 문자열 압축이 끝나면, 나머지 문자열을 기준으로 압축을 반복한다.\r\n\r\n압축 대상 문자열은 반드시 **문자열의 앞에서부터 잘라 만든다는 것**과 **`n`은 `s.length() / 2`를 넘지 않는다는 것**이 포인트다.\r\n\r\n**입력 예시 5**의 `xababcdcdababcdcd`를 보면 이러한 특징을 잘 확인할 수 있는데, 전체 문자열에 하나만 존재하는 `x`가 맨 앞에 존재한다.\r\n\r\n때문에 어떻게 자르든 압축이 불가능하다.\r\n\r\n만약 `x`가 앞에 있지 않았다면, `n = 2`일 경우 높은 압축률을 보였을 것이다.\r\n\r\n또한, 문자열 길이의 반을 넘어가는 문자열로 압축을 시도할 경우, 압축하는데 의미가 없다.\r\n\r\n<br />\r\n\r\n이 장에선 `compress`라는 압축 메서드를 선언한다. `compress`는 문자열 `s`와 압축할 문자열 크기 `num`을 입력받는다.\r\n\r\n`compress`는 문자열 `s`를 `num`씩 잘라서 압축을 시도할 것이다.\r\n\r\n1. 압축 대상 문자열을 정의한다.\r\n2. `num` 길이씩 압축을 시도한다.\r\n   1. 압축 대상 문자열과 동일할 경우, 압축 횟수를 추가한다.\r\n   2. 압축 대상 문자열과 동일하지 않을 경우, 지금까지 압축한 내용을 기록하고, 압축 횟수를 초기화한다.\r\n   3. 압축 대상 문자열이 `s`보다 길어질 경우, 남은 문자열을 기록한다.\r\n3. 기록한 내용을 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 문자열 압축 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 23:30:16\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\tint answer = s.length();\r\n\r\n\t\t// 문자열의 반절 이상은 압축하는 의미가 없다.\r\n\t\tfor (int i = 1; i <= s.length() / 2; i++)\r\n\t\t{\r\n\t\t\tString a = compress(s, i);\r\n\r\n\t\t\tanswer = Math.min(answer, a.length());\r\n\t\t}\r\n\r\n\t\treturn answer;\r\n\t}\r\n\r\n\t/**\r\n\t * 압축 결과 반환 메서드\r\n\t * \r\n\t * @param s: [String] 문자열\r\n\t * @param num: [int] 압축 갯수\r\n\t *\r\n\t * @return [String] 압축된 문자열\r\n\t */\r\n\tprivate String compress(String s, int num)\r\n\t{\r\n\t\tint count = 1;\r\n\r\n\t\tString pattern = s.substring(0, num);\r\n\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\r\n\t\tfor (int i = num; i < s.length(); i += num)\r\n\t\t{\r\n\t\t\t// 비교 인덱스가 s의 길이보다 길어질 경우\r\n\t\t\tif (i + num > s.length())\r\n\t\t\t{\r\n\t\t\t\t// 애초에 압축이 불가능하므로 넘어감\r\n\r\n\t\t\t\tbuilder.append(s.substring(i));\r\n\t\t\t}\r\n\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tString target = s.substring(i, i + num);\r\n\r\n\t\t\t\t// 문자열과 패턴이 동일할 경우\r\n\t\t\t\tif (target.equals(pattern))\r\n\t\t\t\t{\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 동일하지 않을 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// 2회 이상 압축이 가능할 경우\r\n\t\t\t\t\tif (count > 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuilder.append(count);\r\n\r\n\t\t\t\t\t\tcount = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(pattern);\r\n\r\n\t\t\t\t\t// 패턴 갱신\r\n\t\t\t\t\tpattern = target;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 2회 이상 압축이 가능할 경우\r\n\t\tif (count > 1)\r\n\t\t{\r\n\t\t\tbuilder.append(count);\r\n\t\t}\r\n\r\n\t\tbuilder.append(pattern);\r\n\r\n\t\treturn builder.toString();\r\n\t}\r\n}\r\n```","url":["2021-12-26-programmers-a0065","2021","12","26","programmers-a0065"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 직사각형 별찍기 (12954)","excerpt":"이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다. 별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-19T16:18:31+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-19-programmers-a0064.md","content":"\r\n# 직사각형 별찍기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [직사각형 별찍기](https://programmers.co.kr/learn/courses/30/lessons/12954)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n이 문제에는 표준 입력으로 두 개의 정수 `n`과 `m`이 주어집니다.\r\n\r\n별(*) 문자를 이용해 가로의 길이가 `n`, 세로의 길이가 `m`인 직사각형 형태를 출력해보세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* `n`과 `m`은 각각 1000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n\r\n\r\n### 입력\r\n\r\n``` txt\r\n5 3\r\n```\r\n\r\n\r\n\r\n### 출력\r\n\r\n``` txt\r\n*****\r\n*****\r\n*****\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n이 번엔 특이하게 `Scanner` 객체를 통해 사용자의 입력을 직접 받는 방식이다. 직접 `n`, `m`을 받아 해당 크기만큼 별표(\\*)로 사각형을 찍어 출력한다. 학부 시절 처음 C언어를 배웠을 때가 생각나던 문제.\r\n\r\n필자는 개인적으로 `Scanner`보다 `BufferedReader`를 사용하여 사용자 입력을 받는 것을 더 선호한다. 이유는 `BufferedReader`의 성능이 더 뛰어나기 때문.\r\n\r\n어차피 미묘한 성능차가 알고리즘의 수행 여부를 판단하지 않으므로, 그냥 원하는 걸로 사용해도 무방하다.\r\n\r\n<br />\r\n\r\n`n`, `m`을 입력하여 `n`개의 별을 `m`줄 만큼 표시하자. `repeat()` 메서드를 활용하여 특정 문자열을 원하는 만큼 반복해 이중포문 없이 구성할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 직사각형 별찍기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 22:27:04\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 메인 메서드\r\n\t *\r\n\t * @param args: [String[]] 파라미터\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint[] inputs = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tfor (int i = 0; i < inputs[1]; i++)\r\n\t\t{\r\n\t\t\tSystem.out.println(\"*\".repeat(inputs[0]));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```","url":["2021-12-19-programmers-a0064","2021","12","19","programmers-a0064"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 x만큼 간격이 있는 n개의 숫자 (12954)","excerpt":"함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:56:29+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0063.md","content":"\r\n# x만큼 간격이 있는 n개의 숫자\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [x만큼 간격이 있는 n개의 숫자](https://programmers.co.kr/learn/courses/30/lessons/12954)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n함수 `solution`은 정수 `x`와 자연수 `n`을 입력 받아, `x`부터 시작해 `x`씩 증가하는 숫자를 `n`개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `x`는 -10000000 이상, 10000000 이하인 정수입니다.\r\n* `n`은 1000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   x   |   n   |       answer       |\r\n| :---: | :---: | :----------------: |\r\n|   2   |   5   | { 2, 4, 6, 8, 10 } |\r\n|   4   |   3   |    { 4, 8, 12 }    |\r\n|  -4   |   2   |     { -4, -8 }     |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`x`만큼 간격을 가진 수를 `n`개 만큼 나열하여 배열로 반환한다. 다른건 문제가 없지만, 음수의 경우가 문제다.\r\n\r\n음수의 경우 내림차순으로 정렬해야 한다.\r\n\r\n`ArrayList`에 요소를 담은 후, 각 수의 절대값을 기준으로 오름차순으로 정렬하자. `ArrayList`를 스트림화하여 `sorted()` 메서드를 사용하되, 정렬 알고리즘을 오버라이딩한다. `(o1, o2) -> (int) (Math.abs(o1) - Math.abs(o2))`로 오버라이딩하면 된다. `Math.abs()` 메서드를 통해 각 수의 절대값을 추출할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * x만큼 간격이 있는 n개의 숫자 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 22:21:01\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param x: [int] 간격\r\n\t * @param n: [int] 갯수\r\n\t *\r\n\t * @return [long[]] 해답\r\n\t */\r\n\tpublic long[] solution(int x, int n)\r\n\t{\r\n\t\tArrayList<Long> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (n != 0)\r\n\t\t{\r\n\t\t\tlist.add((long) x * n);\r\n\t\t\t\r\n\t\t\tn--;\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().sorted((o1, o2) -> (int) (Math.abs(o1) - Math.abs(o2))).mapToLong(Long::longValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0063","2021","12","18","programmers-a0063"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 행렬의 덧셈 (12950)","excerpt":"행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:56:29+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0062.md","content":"\r\n# 행렬의 덧셈\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [행렬의 덧셈](https://programmers.co.kr/learn/courses/30/lessons/12950)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 `arr1`과 `arr2`를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 행렬 `arr1`, `arr2`의 행과 열의 길이는 500을 넘지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          arr1          |          arr2          |         return         |\r\n| :--------------------: | :--------------------: | :--------------------: |\r\n| { { 1, 2 }, { 2, 3 } } | { { 3, 4 }, { 5, 6 } } | { { 4, 6 }, { 7, 9 } } |\r\n|    { { 1 }, { 2 } }    |    { { 3 }, { 4 } }    |    { { 4 }, { 6 } }    |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n행렬. 즉, 2차원 배열의 덧셈을 구한다. 그냥 이중 포문 돌면서 각 요소를 더해 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 행렬의 덧셈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 22:12:23\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param arr1: [int[][]] 행렬 1\r\n\t * @param arr2: [int[][]] 행렬 2\r\n\t *\r\n\t * @return [int[][]] 해답\r\n\t */\r\n\tpublic int[][] solution(int[][] arr1, int[][] arr2)\r\n\t{\r\n\t\tint[][] answer = new int[arr1.length][arr1[0].length];\r\n\t\t\r\n\t\tfor (int i = 0; i < arr1.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < arr1[i].length; j++)\r\n\t\t\t{\r\n\t\t\t\tanswer[i][j] += arr1[i][j] + arr2[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0062","2021","12","18","programmers-a0062"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 핸드폰 번호 가리기 (12948)","excerpt":"프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:52:30+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0061.md","content":"\r\n# 핸드폰 번호 가리기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [핸드폰 번호 가리기](https://programmers.co.kr/learn/courses/30/lessons/12948)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.\r\n\r\n전화번호가 문자열 `phone_number`로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 \\*으로 가린 문자열을 리턴하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `s`는 길이 4 이상, 20이하인 문자열입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| phone_number  |        return        |\r\n| :-----------: | :------------------: |\r\n| \"01033334444\" | \"\\*\\*\\*\\*\\*\\*\\*4444\" |\r\n|  \"027778888\"  |   \"\\*\\*\\*\\*\\*8888\"   |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n핸드폰 번호의 나머지 4자리만 남기고 전부 별표(\\*)로 마스킹한다.\r\n\r\n목적이 워낙 명확하므로, 굳이 정규식을 사용할 필요는 없다. `phone_number`의 글자를 나누어 `for`문을 돌리고, `phone_number`의 4글자 이전까지 돌며 각 문자를 \\*로 마스킹하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 핸드폰 번호 가리기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 22:06:10\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param phone_number: [String] 핸드폰 번호\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String phone_number)\r\n\t{\r\n\t\tchar[] chars = phone_number.toCharArray();\r\n\t\t\r\n\t\tfor (int i = 0; i < phone_number.length() - 4; i++)\r\n\t\t{\r\n\t\t\tchars[i] = '*';\r\n\t\t}\r\n\t\t\r\n\t\treturn new String(chars);\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0061","2021","12","18","programmers-a0061"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 하샤드 수 (12947)","excerpt":"양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1 + 8 = 9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:48:00+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0060.md","content":"\r\n# 하샤드 수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [하샤드 수](https://programmers.co.kr/learn/courses/30/lessons/12947)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n양의 정수 `x`가 하샤드 수이려면 `x`의 자릿수의 합으로 `x`가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1 + 8 = 9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 `x`를 입력받아 `x`가 하샤드 수인지 아닌지 검사하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `x`는 1 이상, 10000 이하인 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  arr  | return |\r\n| :---: | :----: |\r\n|  10   |  true  |\r\n|  12   |  true  |\r\n|  11   | false  |\r\n|  13   | false  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.\r\n\r\n**입출력 예 #3**\r\n\r\n11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.\r\n\r\n**입출력 예 #4**\r\n\r\n13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n**하샤드 수**를 구한다. 임의의 수 `x`의 모든 자릿수를 전부 더한 합을 구하고, `x`와 이 값이 온전히 나누어지는지를 확인하자. 완전히 나누어진다면, 하샤드 수다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 하샤드 수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 21:52:12\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param x: [int] 정수 배열\r\n\t *\r\n\t * @return [boolean] 해답\r\n\t */\r\n\tpublic boolean solution(int x)\r\n\t{\r\n\t\tint temp = x;\r\n\t\tint sum = 0;\r\n\t\t\r\n\t\twhile (temp >= 10)\r\n\t\t{\r\n\t\t\tsum += temp % 10;\r\n\t\t\t\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\t\r\n\t\tsum += temp;\r\n\t\t\r\n\t\treturn x % sum == 0;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0060","2021","12","18","programmers-a0060"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 평균 구하기 (12944)","excerpt":"정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:43:34+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0059.md","content":"\r\n# 평균 구하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [평균 구하기](https://programmers.co.kr/learn/courses/30/lessons/12944)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수를 담고 있는 배열 `arr`의 평균값을 return하는 함수, `solution`을 완성해보세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `arr`은 길이 1 이상, 100 이하인 배열입니다.\r\n* `arr`의 원소는 -10,000 이상 10,000 이하인 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      arr       | return |\r\n| :------------: | :----: |\r\n| { 1, 2, 3, 4 } |  2.5   |\r\n|    { 5, 5 }    |   5    |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n배열 `arr` 요소의 평균을 구해 반환한다. `Stream`을 활용하면 반복문없이 쉽게 구할 수 있다.\r\n\r\n`Arrays.stream(arr).sum()`로 배열 요소의 총 합을 한 번에 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 평균 구하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 21:49:40\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param arr: [int[]] 정수 배열\r\n\t *\r\n\t * @return [double] 해답\r\n\t */\r\n\tpublic double solution(int[] arr)\r\n\t{\r\n\t\treturn (double) Arrays.stream(arr).sum() / arr.length;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0059","2021","12","18","programmers-a0059"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 콜라츠 추측 (12943)","excerpt":"1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:39:51+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0058.md","content":"\r\n# 콜라츠 추측\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [콜라츠 추측](https://programmers.co.kr/learn/courses/30/lessons/12943)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\r\n\r\n1. 입력된 수가 짝수라면 2로 나눕니다. \r\n2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.\r\n3. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.\r\n\r\n예를 들어, 입력된 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, `solution`을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 입력된 수, `num`은 1 이상 8000000 미만인 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n    | result |\r\n| :----: | :----: |\r\n|   6    |   8    |\r\n|   16   |   4    |\r\n| 626331 |   -1   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 설명과 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n16 -> 8 -> 4 -> 2 -> 1 이되어 총 4번만에 1이 됩니다.\r\n\r\n**입출력 예 #3**\r\n\r\n626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n**콜라츠 추측**이라는 연산을 통해 모든 수를 1로 만들어보자. 단, 500번 이상의 연산이 수행될 경우, 그냥 -1을 반환한다.\r\n\r\n1. 입력된 수가 짝수라면 2로 나눕니다. \r\n2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.\r\n3. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.\r\n\r\n콜라즈 추측의 수행 방법은 위와 같이 매우 간단하다.\r\n\r\n위 연산을 반복하는 알고리즘을 구현하자.\r\n\r\n> **케이스 3이 -1이 아니라 488이 나올 경우**  \r\n> 케이스 3이 -1인 것과는 달리 실제로 수행해보면 제대로 연산했음에도 `488`이 나오는 경우가 있다.  \r\n> 이는 초기 함수의 잘못된 표기로 인해 발생한다. 초기 함수는 `public int solution(int num)`로 되어있지만, `num`은 `int`가 아니라 `long`으로 선언해야 오류가 없다.  \r\n> `num`이 `int`일 경우 연산 과정에서 `int`의 최대값(약 21억)을 초과하게 되어, 숫자가 짤려 연산이 뒤틀리게 된다. 따라서 `public int solution(long num)`으로 바꾸기만하면 정상적으로 동작할 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 콜라츠 추측 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 21:34:17\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param num: [long] 정수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(long num)\r\n\t{\r\n\t\tint count = 0;\r\n\t\t\r\n\t\twhile (num != 1)\r\n\t\t{\r\n\t\t\t// 500번 수행했을 경우\r\n\t\t\tif (count == 500)\r\n\t\t\t{\r\n\t\t\t\tcount = -1;\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnum = num % 2 == 0 ? num / 2 : num * 3 + 1;\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0058","2021","12","18","programmers-a0058"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 최대공약수와 최소공배수 (12940)","excerpt":"두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T21:30:56+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0057.md","content":"\r\n# 최대공약수와 최소공배수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [최대공약수와 최소공배수](https://programmers.co.kr/learn/courses/30/lessons/12940)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, `solution`을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 `solution(3, 12)`는 [3, 12]를 반환해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* 두 수는 1이상 1000000이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |   m   |  return   |\r\n| :---: | :---: | :-------: |\r\n|   3   |  12   | { 3, 12 } |\r\n|   2   |   5   | { 1, 10 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n위의 설명과 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n두 수 `n`, `m`의 최대공약수와 최소공배수를 구하는 문제. 최대공약수만 구하면 `n`과 `m`, 최대공약수를 활용해 최소공배수를 구할 수 있다.\r\n\r\n약수를 일일히 구해 비교하는 방법도 있지만, <span class=\"primary\">유클리드 호제법</span>을 활용하여 최대공약수를 쉽게 구할 수 있다.\r\n\r\n<br />\r\n\r\n**유클리드 호제법**\r\n\r\n1. `n`을 `m`으로 나눠 나머지 `r`를 구한다.\r\n   * `r`이 0일 경우, 나눴던 그 수가 최대공약수가 된다.\r\n2. `n`은 `m`으로, `m`은 `r`로 할당하여 1을 반복한다.\r\n\r\n이렇게 최대공약수를 구하면, 최소공배수는 간단하게 구할 수 있다.\r\n\r\n`n`과 `m`을 곱하고, 최대공약수로 이를 나누면 된다.\r\n\r\n<br />\r\n\r\n구한 두 값을 배열로 만들어 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 최대공약수와 최소공배수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 19:33:08\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 정수 1\r\n\t * @param m: [int] 정수 2\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int n, int m)\r\n\t{\r\n\t\tint[] answer = new int[2];\r\n\t\t\r\n\t\tanswer[0] = gcd(n, m);\r\n\t\tanswer[1] = n * m / answer[0];\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유클리드 호제법 연산결과 반환 메서드\r\n\t *\r\n\t * @param n: [int] 정수 1\r\n\t * @param m: [int] 정수 2\r\n\t *\r\n\t * @return [int] 최대공약수\r\n\t */\r\n\tprivate int gcd(int n, int m)\r\n\t{\r\n\t\twhile (m != 0)\r\n\t\t{\r\n\t\t\tint r = n % m;\r\n\t\t\t\r\n\t\t\tn = m;\r\n\t\t\tm = r;\r\n\t\t}\r\n\t\t\r\n\t\treturn n;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0057","2021","12","18","programmers-a0057"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 짝수와 홀수 (12937)","excerpt":"정수 num이 짝수일 경우 \"Even\"을 반환하고 홀수인 경우 \"Odd\"를 반환하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T20:59:59+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0056.md","content":"\r\n# 짝수와 홀수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [짝수와 홀수](https://programmers.co.kr/learn/courses/30/lessons/12937)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수 `num`이 짝수일 경우 \"Even\"을 반환하고 홀수인 경우 \"Odd\"를 반환하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `num`은 `int` 범위의 정수입니다.\r\n* 0은 짝수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  num  | return |\r\n| :---: | :----: |\r\n|   3   | \"Odd\"  |\r\n|   4   | \"Even\" |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`num`이 홀수인지 짝수인지 비교하여 홀수일 경우 \"Odd\", 짝수일 경우 \"Even\"을 반환한다.\r\n\r\n`num % 2` 연산을 통해 나누어 떨어지는지 아닌지를 판별하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 짝수와 홀수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 19:28:38\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param num: [int] 정수\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int num)\r\n\t{\r\n\t\treturn num % 2 == 0 ? \"Even\" : \"Odd\";\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0056","2021","12","18","programmers-a0056"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 제일 작은 수 제거하기 (12935)","excerpt":"정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T20:55:40+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0055.md","content":"\r\n# 제일 작은 수 제거하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [제일 작은 수 제거하기](https://programmers.co.kr/learn/courses/30/lessons/12935)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수를 저장한 배열, `arr` 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, `solution`을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 `arr`이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `arr`은 길이 1 이상인 배열입니다.\r\n* 인덱스 `i`, `j`에 대해 `i ≠ j`이면 `arr[i] ≠ arr[j]` 입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      arr       |   return    |\r\n| :------------: | :---------: |\r\n| { 4, 3, 2, 1 } | { 4, 3, 2 } |\r\n|     { 10 }     |   { -1 }    |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n배열 `arr`의 가장 작은 수를 찾아 제거하고, 남은 배열을 반환하면 된다. 만약 제공된 배열의 갯수가 하나라면, 그 하나가 최소값이므로 그 값을 제외하면 빈 배열이 된다. 이 경우 -1을 담아 `{ -1 }`로 반환한다.\r\n\r\n배열을 돌며 가장 작은 값을 파악하고 그 값을 제거한 뒤 반환한다.\r\n\r\n<br />\r\n\r\n이 장에서는 `ArrayList`를 활용한다. `arr`를 돌며 최소값을 비교함과 동시에 `ArrayList`에 요소를 입력한다.\r\n\r\n이후 최소값을 `ArrayList`로부터 삭제한 뒤 반환한다.\r\n\r\n``` java\r\nint min = Integer.MAX_VALUE;\r\n\t\t\r\nfor (int item : arr)\r\n{\r\n\tmin = Math.min(min, item);\r\n}\r\n```\r\n\r\n최소값은 위와 같이 판별한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 제일 작은 수 제거하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 19:20:27\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param arr: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] arr)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tint min = Integer.MAX_VALUE;\r\n\t\t\r\n\t\tfor (int item : arr)\r\n\t\t{\r\n\t\t\tmin = Math.min(min, item);\r\n\t\t\t\r\n\t\t\tlist.add(item);\r\n\t\t}\r\n\t\t\r\n\t\tlist.remove((Integer) min);\r\n\t\t\r\n\t\t// 리스트가 비었을 경우\r\n\t\tif (list.isEmpty())\r\n\t\t{\r\n\t\t\tlist.add(-1);\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0055","2021","12","18","programmers-a0055"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 정수 제곱근 판별 (12934)","excerpt":"임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x + 1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T20:46:29+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0054.md","content":"\r\n# 정수 제곱근 판별\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [정수 제곱근 판별](https://programmers.co.kr/learn/courses/30/lessons/12934)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n임의의 양의 정수 `n`에 대해, `n`이 어떤 양의 정수 `x`의 제곱인지 아닌지 판단하려 합니다.\r\n\r\n`n`이 양의 정수 `x`의 제곱이라면 `x + 1`의 제곱을 리턴하고, `n`이 양의 정수 `x`의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `n`은 1이상, 50000000000000 이하인 양의 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | return |\r\n| :---: | :----: |\r\n|  121  |  144   |\r\n|   3   |   -1   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예#1**\r\n\r\n121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다.\r\n\r\n**입출력 예#2**\r\n\r\n3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`n`이 어떤 수의 제곱수인지 확인하여 제곱수의 제곱근 + 1을 제곱한 값을 반환하는 알고리즘\r\n\r\n제곱근이 맞다면, $(\\sqrt{n} + 1)^2$를 반환하면 된다.\r\n\r\n<br />\r\n\r\n`n`이 제곱수인지 확인하려면 `Math.sqrt(n)`과 `Math.sqrt(n)`의 정수가 일치하는지 확인하면 된다.\r\n\r\n이 판별을 통해 `n`이 어떤 수의 제곱수임이 확인되면 $(\\sqrt{n} + 1)^2$의 값을 반환한다.\r\n\r\n만약 아니라면, -1을 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 정수 제곱근 판별 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 19:15:59\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [long] 정수\r\n\t *\r\n\t * @return [long] 해답\r\n\t */\r\n\tpublic long solution(long n)\r\n\t{\r\n\t\tdouble sqrt = Math.sqrt(n);\r\n\t\t\r\n\t\tlong num = (long) sqrt;\r\n\t\t\r\n\t\treturn sqrt == num ? (long) Math.pow(sqrt + 1, 2) : -1;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0054","2021","12","18","programmers-a0054"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 정수 내림차순으로 배치하기 (12933)","excerpt":"함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T20:39:02+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0053.md","content":"\r\n# 정수 내림차순으로 배치하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [정수 내림차순으로 배치하기](https://programmers.co.kr/learn/courses/30/lessons/12933)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n함수 `solution`은 정수 `n`을 매개변수로 입력받습니다. `n`의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 `n`이 118372면 873211을 리턴하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `n`은 1이상 8000000000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n    | return |\r\n| :----: | :----: |\r\n| 118372 | 873211 |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n정수를 내림차순으로 배치한다. 역순이 아니라 숫자 크기별로 내림차순하여 정렬한 후 다시 숫자로 반환해야한다.\r\n\r\n**자연수 뒤집어 배열로 만들기** 문제를 풀었다면 쉽게 풀이할 수 있다.\r\n\r\n동일하게 자릿수별로 `ArrayList`로 담은 이후에, `Collections.sort()`로 정렬한다.\r\n\r\n이후 다시 숫자를 자릿수별로 조립하여 온전한 숫자를 반환한다. `int`로 반환하지 않도록 주의하자.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * 정수 내림차순으로 배치하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 19:04:28\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [long] 자연수\r\n\t *\r\n\t * @return [long] 해답\r\n\t */\r\n\tpublic long solution(long n)\r\n\t{\r\n\t\tlong answer = 0;\r\n\t\t\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (n >= 10)\r\n\t\t{\r\n\t\t\tlist.add((int) (n % 10));\r\n\t\t\t\r\n\t\t\tn /= 10;\r\n\t\t}\r\n\t\t\r\n\t\tlist.add((int) n);\r\n\t\t\r\n\t\tCollections.sort(list);\r\n\t\t\r\n\t\tfor (int i = 0; i < list.size(); i++)\r\n\t\t{\r\n\t\t\tanswer += list.get(i) * Math.pow(10, i);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0053","2021","12","18","programmers-a0053"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 자연수 뒤집어 배열로 만들기 (12932)","excerpt":"자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:58:31+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0052.md","content":"\r\n# 자연수 뒤집어 배열로 만들기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [자연수 뒤집어 배열로 만들기](https://programmers.co.kr/learn/courses/30/lessons/12932)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `n`을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 `n`이 12345이면 [5,4,3,2,1]을 리턴합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `n`은 10,000,000,000이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |      return       |\r\n| :---: | :---------------: |\r\n| 12345 | { 5, 4, 3, 2, 1 } |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n자연수 `n`을 역순으로 뒤집어 각 숫자를 배열로 반환한다.\r\n\r\n숫자를 문자열로 바꾸고, 각 문자를 역순으로 배열하는 방법도 있다. 하지만 이 번엔 숫자 연산을 통해 구해본다.\r\n\r\n<br />\r\n\r\n`ArrayList`를 선언하여 각 숫자를 담는다.\r\n\r\n``` java\r\nArrayList<Integer> list = new ArrayList<>();\r\n\r\nwhile (n >= 10)\r\n{\r\n\tlist.add((int) (n % 10));\r\n\t\r\n\tn /= 10;\r\n}\r\n\r\nlist.add((int) n);\r\n```\r\n\r\n`n % 10`으로 자릿수를 구할 수 있고, `n / 10`으로 해당 자릿수를 제외한 나머지 숫자를 구할 수 있다. 이후 `n`이 10보다 작아질 때까지 반복하여 연산을 수행한다.\r\n\r\n1의 자리부터 구하기 때문에, 굳이 역순으로 돌릴 필요 없이 담은 배열을 그대로 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 자연수 뒤집어 배열로 만들기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 18:31:27\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [long] 자연수\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(long n)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (n >= 10)\r\n\t\t{\r\n\t\t\tlist.add((int) (n % 10));\r\n\t\t\t\r\n\t\t\tn /= 10;\r\n\t\t}\r\n\t\t\r\n\t\tlist.add((int) n);\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0052","2021","12","18","programmers-a0052"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 자릿수 더하기 (12931)","excerpt":"자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요. 예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:31:11+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0051.md","content":"\r\n# 자릿수 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [자릿수 더하기](https://programmers.co.kr/learn/courses/30/lessons/12931)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `N`이 주어지면, `N`의 각 자릿수의 합을 구해서 return 하는 `solution` 함수를 만들어 주세요.\r\n예를들어 `N = 123`이면 1 + 2 + 3 = 6을 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `N`의 범위 : 100,000,000 이하의 자연수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   N   | answer |\r\n| :---: | :----: |\r\n|  123  |   6    |\r\n|  987  |   24   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n9 + 8 + 7 = 24이므로 24를 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자의 자릿수 별 숫자를 전부 더하는 알고리즘.\r\n\r\n숫자를 문자로 변환하여 한 글자씩 나누고, 나눈 글자를 숫자로 변환하여 값을 누적하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 자릿수 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 18:27:11\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tString[] numbers = String.valueOf(n).split(\"\");\r\n\t\t\r\n\t\tfor (String number : numbers)\r\n\t\t{\r\n\t\t\tanswer += Integer.parseInt(number);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0051","2021","12","18","programmers-a0051"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 약수의 합 (12928)","excerpt":"정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:13:33+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0049.md","content":"\r\n# 약수의 합\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [약수의 합](https://programmers.co.kr/learn/courses/30/lessons/12928)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수 `n`을 입력받아 `n`의 약수를 모두 더한 값을 리턴하는 함수, `solution`을 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* `n`은 0 이상 3000이하인 정수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | return |\r\n| :---: | :----: |\r\n|  12   |   28   |\r\n|   5   |   6    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n약수를 구해서 값을 누적하면 된다. 약수 구하는 알고리즘은 아래와 같다.\r\n\r\n``` java\r\nfor (int i = 1; i <= Math.sqrt(n); i++)\r\n{\r\n\t// 나누어 떨어질 경우\r\n\tif (n % i == 0)\r\n\t{\r\n\t\t// n의 제곱근일 경우\r\n\t\tif (i * i == n)\r\n\t\t{\r\n\t\t\tanswer += i;\r\n\t\t}\r\n\t\t\r\n\t\t// n의 제곱근이 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tanswer += i;\r\n\t\t\tanswer += n / i;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`n`의 제곱근까지 돌면 약수를 모두 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 약수의 합 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 17:52:04\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 정수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 1; i <= Math.sqrt(n); i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어질 경우\r\n\t\t\tif (n % i == 0)\r\n\t\t\t{\r\n\t\t\t\t// n의 제곱근일 경우\r\n\t\t\t\tif (i * i == n)\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer += i;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// n의 제곱근이 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tanswer += i;\r\n\t\t\t\t\tanswer += n / i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0049","2021","12","18","programmers-a0049"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 시저 암호 (12926)","excerpt":"어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 \"AB\"는 1만큼 밀면 \"BC\"가 되고, 3만큼 밀면 \"DE\"가 됩니다. \"z\"는 1만큼 밀면 \"a\"가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:05:21+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0048.md","content":"\r\n# 시저 암호\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [시저 암호](https://programmers.co.kr/learn/courses/30/lessons/12926)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 \"AB\"는 1만큼 밀면 \"BC\"가 되고, 3만큼 밀면 \"DE\"가 됩니다. \"z\"는 1만큼 밀면 \"a\"가 됩니다. 문자열 `s`와 거리 `n`을 입력받아 `s`를 `n`만큼 민 암호문을 만드는 함수, `solution`을 완성해 보세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* 공백은 아무리 밀어도 공백입니다.\r\n* `s`는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.\r\n* `s`의 길이는 8000이하입니다.\r\n* `n`은 1 이상, 25이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|    s    |   n   | result  |\r\n| :-----: | :---: | :-----: |\r\n|  \"AB\"   |   1   |  \"BC\"   |\r\n|   \"z\"   |   1   |   \"a\"   |\r\n| \"a B z\" |   4   | \"e F d\" |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n주어진 문자열 `s`의 문자들을 `n`만큼 밀어 시저 암호를 만든다. 소문자 `z`의 경우 한 번 밀게 되면 `a`로 다시 역전하고, 마찬가지로 대문자 `Z`도 한 번 밀게 되면 `A`로 역전한다. 공백은 몇 번을 밀어도 공백.\r\n\r\n각 문자를 정해진 수 만큼 적절히 순환하여 문자열을 반환하면 된다. 각 문자의 ASCII 코드 번호를 활용하면 된다.\r\n\r\n* A ~ Z: 65 ~ 90\r\n* a ~ z: 97 ~ 122\r\n\r\n해당 범위를 넘어가게 될 경우, 범위의 처음으로 순환하여 그 번호를 반환하는 메서드를 만들자.\r\n\r\n``` java\r\nprivate int converter(int num, int n)\r\n{\r\n\t// 대문자일 경우\r\n\tif (num >= 65 && num <= 90)\r\n\t{\r\n\t\t// 대문자 영역을 넘어버릴 경우\r\n\t\tif (num + n > 90)\r\n\t\t{\r\n\t\t\treturn num + n - 90 + 65 - 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn num + n;\r\n\t}\r\n\t\r\n\t// 소문자일 경우\r\n\telse if (num >= 97 && num <= 122)\r\n\t{\r\n\t\t// 소문자 영역을 넘어버릴 경우\r\n\t\tif (num + n > 122)\r\n\t\t{\r\n\t\t\treturn num + n - 122 + 97 - 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn num + n;\r\n\t}\r\n\t\r\n\t// 공백일 경우\r\n\telse\r\n\t{\r\n\t\treturn ' ';\r\n\t}\r\n}\r\n```\r\n\r\n`converter` 메서드는 해당 숫자와 밀 번호를 받아 민 만큼의 숫자를 반환한다. 공백은 그냥 밀 것 없이 바로 공백을 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * 시저 암호 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 16:12:50\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t * @param n: [int] 이동 거리\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String s, int n)\r\n\t{\r\n\t\treturn s.chars().mapToObj(value -> Character.toString(converter(value, n))).collect(Collectors.joining(\"\"));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 결과 반환 메서드\r\n\t *\r\n\t * @param num: [int] 원본 숫자\r\n\t * @param n: [int] 이동 거리\r\n\t *\r\n\t * @return [int] 변환환 숫자\r\n\t */\r\n\tprivate int converter(int num, int n)\r\n\t{\r\n\t\t// 대문자일 경우\r\n\t\tif (num >= 65 && num <= 90)\r\n\t\t{\r\n\t\t\t// 대문자 영역을 넘어버릴 경우\r\n\t\t\tif (num + n > 90)\r\n\t\t\t{\r\n\t\t\t\treturn num + n - 90 + 65 - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn num + n;\r\n\t\t}\r\n\t\t\r\n\t\t// 소문자일 경우\r\n\t\telse if (num >= 97 && num <= 122)\r\n\t\t{\r\n\t\t\t// 소문자 영역을 넘어버릴 경우\r\n\t\t\tif (num + n > 122)\r\n\t\t\t{\r\n\t\t\t\treturn num + n - 122 + 97 - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn num + n;\r\n\t\t}\r\n\t\t\r\n\t\t// 공백일 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn ' ';\r\n\t\t}\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0048","2021","12","18","programmers-a0048"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 문자열을 정수로 바꾸기 (12925)","excerpt":"문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T17:21:13+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0047.md","content":"\r\n# 문자열을 정수로 바꾸기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열을 정수로 바꾸기](https://programmers.co.kr/learn/courses/30/lessons/12925)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n문자열 `s`를 숫자로 변환한 결과를 반환하는 함수, `solution`을 완성하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* `s`의 길이는 1 이상 5이하입니다.\r\n* `s`의 맨앞에는 부호(+, -)가 올 수 있습니다.\r\n* `s`는 부호와 숫자로만 이루어져있습니다.\r\n* `s`는 \"0\"으로 시작하지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n예를들어 `str`이 \"1234\"이면 1234를 반환하고, \"-1234\"이면 -1234를 반환하면 됩니다.\r\n\r\n`str`은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자가 적인 문자열을 숫자로 변환하는 알고리즘을 구현한다.\r\n\r\n`Integer.parseInt()` 메서드를 사용하면, 문자열을 숫자로 변환할 수 있다. 부호까지 같이 변환되므로, 부호를 따로 신경써줄 필요는 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 문자열을 정수로 바꾸기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 16:10:18\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\treturn Integer.parseInt(s);\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0047","2021","12","18","programmers-a0047"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 수박수박수박수박수박수? (12922)","excerpt":"길이가 n이고, \"수박수박수박수....\"와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 \"수박수박\"을 리턴하고 3이라면 \"수박수\"를 리턴하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T17:15:21+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0046.md","content":"\r\n# 수박수박수박수박수박수?\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [수박수박수박수박수박수?](https://programmers.co.kr/learn/courses/30/lessons/12922)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n길이가 `n`이고, \"수박수박수박수....\"와 같은 패턴을 유지하는 문자열을 리턴하는 함수, `solution`을 완성하세요. 예를들어 `n`이 4이면 \"수박수박\"을 리턴하고 3이라면 \"수박수\"를 리턴하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `n`은 길이 10,000이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |   return   |\r\n| :---: | :--------: |\r\n|   3   |  \"수박수\"  |\r\n|   4   | \"수박수박\" |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문자열 길이 `n`에 따라 `수박수박수박...`의 형태로 이루어진 문자열을 만들면 된다.\r\n\r\n`n`번 만큼 반복하여 짝수 인덱스일 경우 `수`, 홀수 인덱스일 경우 `박`을 이어붙여 문자열을 만들면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 수박수박수박수박수박수? 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 16:05:46\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int n)\r\n\t{\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tbuilder.append(i % 2 == 0 ? \"수\" : \"박\");\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n}\r\n```","url":["2021-12-18-programmers-a0046","2021","12","18","programmers-a0046"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 소수 찾기 (12921)","excerpt":"1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다. (1은 소수가 아닙니다.)","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-17T18:44:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-17-programmers-a0045.md","content":"\r\n# 소수 찾기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [소수 찾기](https://programmers.co.kr/learn/courses/30/lessons/12921)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n1부터 입력받은 숫자 `n` 사이에 있는 소수의 개수를 반환하는 함수, `solution`을 만들어 보세요.\r\n\r\n소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.\r\n\r\n(1은 소수가 아닙니다.)\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `n`은 2이상 1000000이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|  10   |   4    |\r\n|   5   |   3    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환\r\n\r\n**입출력 예 #2**\r\n\r\n1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1과 n 사이의 숫자들 중 소수인 수의 갯수를 요구하는 알고리즘\r\n\r\n소수 판별 알고리즘을 설계하여, 해당 수가 소수일 경우 하나씩 카운팅하면 될 것이다.\r\n\r\n``` java\r\nprivate boolean isPrime(int n)\r\n{\r\n\tfor (int i = 2; i * i <= n; i++)\r\n\t{\r\n\t\t// 나눠 떨어질 경우\r\n\t\tif (n % i == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n```\r\n\r\n소수 판별 알고리즘은 위와 같다. 2부터 입력된 수 `n`의 제곱근까지 돌며 값을 나눠본다. 하나라도 나눠질 경우 소수가 아니므로 `false`를 반환한다.\r\n\r\n만약 모든 반복문을 수행했음에도 나눠지지 않는다면 그 수는 소수이다.\r\n\r\n<br />\r\n\r\n$\\sqrt{n}$까지만 반복문을 수행하는 이유는 소수의 특성 때문이다. `n`이 소수일 경우, 1과 `n` 자기 자신만을 갖는다. 즉, 이외의 약수를 가질 경우 소수가 아니다.\r\n\r\n`12` -> `[ 1, 2, 3, 4, 6, 12 ]`일 때, $\\sqrt{12}$는 약 3이다. 3까지만 돌며 나누어 떨어지는 수를 구하면, 나머지 반쪽은 12로 나누어 그 값을 알 수 있다.\r\n\r\n만약 약수 3을 구했다면, `12 / 3 = 4`를 통해, 약수 4를 구할 수 있다.\r\n\r\n<br />\r\n\r\n이 문제는 약수의 갯수에 상관없이 소수인지만 판별하면 되므로, 1과 `n` 이외의 약수가 하나라도 확인되면 소수가 아니라고 판단하여 알고리즘을 구성하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 소수 찾기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 15:51:37\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 2; i <= n; i++)\r\n\t\t{\r\n\t\t\tanswer += isPrime(i) ? 1 : 0;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 메서드\r\n\t *\r\n\t * @param n: [int] 숫자\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate boolean isPrime(int n)\r\n\t{\r\n\t\tfor (int i = 2; i * i <= n; i++)\r\n\t\t{\r\n\t\t\t// 나눠 떨어질 경우\r\n\t\t\tif (n % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```","url":["2021-12-17-programmers-a0045","2021","12","17","programmers-a0045"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 서울에서 김서방 찾기 (12919)","excerpt":"String형 배열 seoul의 element중 \"Kim\"의 위치 x를 찾아, \"김서방은 x에 있다\"는 String을 반환하는 함수, solution을 완성하세요. seoul에 \"Kim\"은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-17T18:33:21+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-17-programmers-a0044.md","content":"\r\n# 서울에서 김서방 찾기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [서울에서 김서방 찾기](https://programmers.co.kr/learn/courses/30/lessons/12919)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\nString형 배열 `seoul`의 element중 \"Kim\"의 위치 x를 찾아, \"김서방은 x에 있다\"는 String을 반환하는 함수, `solution`을 완성하세요. `seoul`에 \"Kim\"은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `seoul`은 길이 1 이상, 1000 이하인 배열입니다.\r\n* `seoul`의 원소는 길이 1 이상, 20 이하인 문자열입니다.\r\n* \"Kim\"은 반드시 `seoul` 안에 포함되어 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       seoul       |       return        |\r\n| :---------------: | :-----------------: |\r\n| { \"Jane\", \"Kim\" } | \"김서방은 1에 있다\" |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n일반적인 `String[]`과 같은 배열과 달리, `List`의 경우, `indexOf()`라는 메서드를 사용할 수 있다. 이 메서드는 원하는 요소의 위치를 반환한다.\r\n\r\n`Arrays.asList()` 메서드를 활용하여 배열을 `List`로 변환하고 `indexOf()`를 사용하여 위치를 이용해 답을 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 서울에서 김서방 찾기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 15:44:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param seoul: [String[]] 문자열\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String[] seoul)\r\n\t{\r\n\t\treturn new StringBuilder(\"김서방은 \").append(Arrays.asList(seoul).indexOf(\"Kim\")).append(\"에 있다\").toString();\r\n\t}\r\n}\r\n```","url":["2021-12-17-programmers-a0044","2021","12","17","programmers-a0044"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 문자열 다루기 기본 (12918)","excerpt":"문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 \"a234\"이면 False를 리턴하고 \"1234\"라면 True를 리턴하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T21:38:44+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0043.md","content":"\r\n# 문자열 다루기 기본\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열 다루기 기본](https://programmers.co.kr/learn/courses/30/lessons/12918)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n문자열 `s`의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, `solution`을 완성하세요. 예를 들어 `s`가 \"a234\"이면 False를 리턴하고 \"1234\"라면 True를 리턴하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `s`는 길이 1 이상, 길이 8 이하인 문자열입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   s    | return |\r\n| :----: | :----: |\r\n| \"a234\" | false  |\r\n| \"1234\" |  true  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n아래의 조건을 모두 만족하는 문자열만 `true`를 반환하며, 나머지는 모두 `false`로 반환한다.\r\n\r\n* 모든 문자가 숫자로 이루어짐\r\n* 글자가 4글자 혹은 6글자 (4 ~ 6이 아님)\r\n\r\n정규식을 이용하면 깔끔하게 풀 수 있다. 정규식을 구성하여 해당 식에 부합하면 `true`, 아니라면 `false`를 반환하자.\r\n\r\n* 정규식: `^([0-9]{4}|[0-9]{6})$`\r\n* `[0-9]` - 숫자\r\n* `{4}` - 4글자\r\n* `|` - OR\r\n* `^` - 문자의 앞\r\n* `$` - 문자의 끝\r\n\r\n문자의 전체가 4자리 숫자 혹은 6자리 숫자인 정규식이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 문자열 다루기 기본 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 15:38:26\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [boolean] 해답\r\n\t */\r\n\tpublic boolean solution(String s)\r\n\t{\r\n\t\treturn Pattern.matches(\"^([0-9]{4}|[0-9]{6})$\", s);\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0043","2021","12","16","programmers-a0043"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 문자열 내림차순으로 배치하기 (12917)","excerpt":"문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T21:31:37+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0042.md","content":"\r\n# 문자열 내림차순으로 배치하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열 내림차순으로 배치하기](https://programmers.co.kr/learn/courses/30/lessons/12917)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n문자열 `s`에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, `solution`을 완성해주세요.\r\n\r\n`s`는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `str`은 길이 1 이상인 문자열입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|     s     |  return   |\r\n| :-------: | :-------: |\r\n| \"Zbcdefg\" | \"gfedcbZ\" |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\ns의 문자들을 큰 순서대로 정렬하는 함수. 이것저것 따질 것 없이, 각 문자의 ASCII 코드 번호를 비교하면 간단하게 풀 수 있다.\r\n\r\n* A to Z: 65 ~ 90\r\n* z to z: 97 ~ 122\r\n\r\n대문자의 코드값이 소문자보다 작기 때문에, 문제의 조건과 정확히 일치한다.\r\n\r\n정렬 시, 문자열의 ASCII 코드값을 받아서 이를 통해 정렬하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * 문자열 내림차순으로 배치하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 15:11:19\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String s)\r\n\t{\r\n\t\tList<String> list = s.chars().sorted().mapToObj(Character::toString).collect(Collectors.toList());;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = list.size() - 1; i > -1; i--)\r\n\t\t{\r\n\t\t\tbuilder.append(list.get(i));\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0042","2021","12","16","programmers-a0042"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 문자열 내 p와 y의 개수 (12916)","excerpt":"대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 'p'의 개수와 'y'의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. 'p', 'y' 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T21:16:32+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0041.md","content":"\r\n# 문자열 내 p와 y의 개수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열 내 p와 y의 개수](https://programmers.co.kr/learn/courses/30/lessons/12916)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n대문자와 소문자가 섞여있는 문자열 `s`가 주어집니다. `s`에 'p'의 개수와 'y'의 개수를 비교해 같으면 True, 다르면 False를 return 하는 `solution`를 완성하세요. 'p', 'y' 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.\r\n\r\n예를 들어 s가 \"pPoooyY\"면 true를 return하고 \"Pyy\"라면 false를 return합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* 문자열 `s`의 길이 : 50 이하의 자연수\r\n* 문자열 `s`는 알파벳으로만 이루어져 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|     s     | answer |\r\n| :-------: | :----: |\r\n| \"pPoooyY\" |  true  |\r\n|   \"Pyy\"   | false  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n'p'의 개수 2개, 'y'의 개수 2개로 같으므로 true를 return 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n'p'의 개수 1개, 'y'의 개수 2개로 다르므로 false를 return 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문자열의 p와 y의 갯수를 비교해서, 같으면 `true`, 아니면 `false`를 반환하면 되는 간단한 문제다.\r\n\r\np와 y는 대소문자 구분을 하지 않으므로, 편의를 위해 `toLowerCase()` 메서드를 적용시켜 전부 소문자로 만든다.\r\n\r\n이후 문자열 `s`의 각 문자를 탐색하여 p와 y의 갯수를 산출, 비교하면 된다.\r\n\r\n<br />\r\n\r\n여기서는 `s`를 한 글자씩 분리하여 배열로 만들고, 스트림을 활용하여 p와 y의 갯수를 산출, 이를 비교하는 방식을 취한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 문자열 내 p와 y의 개수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 15:01:11\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic boolean solution(String s)\r\n\t{\r\n\t\tint p = (int) Arrays.stream(s.toLowerCase().split(\"\")).filter(item -> item.equals(\"p\")).count();\r\n\t\tint y = (int) Arrays.stream(s.toLowerCase().split(\"\")).filter(item -> item.equals(\"y\")).count();\r\n\t\t\r\n\t\treturn p == y;\r\n\t}\r\n}\r\n```\r\n\r\n`toLowerCase()`를 적용하는 것 말고도 `equalsIgnoreCase()`를 사용하여 대소문자에 관계없이 글자를 비교해도 된다.","url":["2021-12-16-programmers-a0041","2021","12","16","programmers-a0041"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 문자열 내 마음대로 정렬하기 (12915)","excerpt":"문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [\"sun\", \"bed\", \"car\"]이고 n이 1이면 각 단어의 인덱스 1의 문자 \"u\", \"e\", \"a\"로 strings를 정렬합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:48:21+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0040.md","content":"\r\n# 문자열 내 마음대로 정렬하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [문자열 내 마음대로 정렬하기](https://programmers.co.kr/learn/courses/30/lessons/12915)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n문자열로 구성된 리스트 `strings`와, 정수 `n`이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 `strings`가 [ \"sun\", \"bed\", \"car\" ]이고 `n`이 1이면 각 단어의 인덱스 1의 문자 \"u\", \"e\", \"a\"로 `strings`를 정렬합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 조건\r\n\r\n* `strings`는 길이 1 이상, 50이하인 배열입니다.\r\n* `strings`의 원소는 소문자 알파벳으로 이루어져 있습니다.\r\n* `strings`의 원소는 길이 1 이상, 100이하인 문자열입니다.\r\n* 모든 `strings`의 원소의 길이는 `n`보다 큽니다.\r\n* 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          strings          |   n   |          return           |\r\n| :-----------------------: | :---: | :-----------------------: |\r\n|  { \"sun\", \"bed\", \"car\" }  |   1   |  { \"car\", \"bed\", \"sun\" }  |\r\n| { \"abce\", \"abcd\", \"cdx\" } |   2   | { \"abcd\", \"abce\", \"cdx\" } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 1**\r\n\r\n\"sun\", \"bed\", \"car\"의 1번째 인덱스 값은 각각 \"u\", \"e\", \"a\" 입니다. 이를 기준으로 `strings`를 정렬하면 [\"car\", \"bed\", \"sun\"] 입니다.\r\n\r\n**입출력 예 2**\r\n\r\n\"abce\"와 \"abcd\", \"cdx\"의 2번째 인덱스 값은 \"c\", \"c\", \"x\"입니다. 따라서 정렬 후에는 \"cdx\"가 가장 뒤에 위치합니다. \"abce\"와 \"abcd\"는 사전순으로 정렬하면 \"abcd\"가 우선하므로, 답은 [\"abcd\", \"abce\", \"cdx\"] 입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`strings`를 스트림으로 만들어 정렬하면 쉽게 풀 수 있다. 각 요소의 `n`번 째 텍스트를 기준으로 정렬하되, 텍스트가 동일할 경우, 전체 텍스트를 기준으로 사전순으로 정렬하여 반환한다.\r\n\r\n이 경우 편하게 일단 전체 요소를 사전순으로 한 번 정렬을 하고, 이후 `n`번 째 텍스트를 기준으로 정렬하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * 문자열 내 마음대로 정렬하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 14:22:36\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param strings: [String[]] 문자열 배열\r\n\t * @param n: [int] 정렬 대상 인덱스\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic String[] solution(String[] strings, int n)\r\n\t{\r\n\t\treturn Arrays.stream(strings).sorted().sorted(Comparator.comparingInt(o -> o.charAt(n))).toArray(String[]::new);\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0040","2021","12","16","programmers-a0040"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 두 정수 사이의 합 (12912)","excerpt":"두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:31:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0039.md","content":"\r\n# 두 정수 사이의 합\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [두 정수 사이의 합](https://programmers.co.kr/learn/courses/30/lessons/12912)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n두 정수 `a`, `b`가 주어졌을 때 `a`와 `b` 사이에 속한 모든 정수의 합을 리턴하는 함수, `solution`을 완성하세요.\r\n예를 들어 `a = 3`, `b = 5`인 경우, `3 + 4 + 5 = 12`이므로 12를 리턴합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한조건\r\n\r\n* `a`와 `b`가 같은 경우는 둘 중 아무 수나 리턴하세요.\r\n* `a`와 `b`는 -10,000,000 이상 10,000,000 이하인 정수입니다.\r\n* `a`와 `b`의 대소관계는 정해져있지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   a   |   b   | return |\r\n| :---: | :---: | :----: |\r\n|   3   |   5   |   12   |\r\n|   3   |   3   |   3    |\r\n|   5   |   3   |   12   |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n그냥 `a`와 `b` 사이에 `for`문을 돌며 사이의 모든 수를 더하면 된다.\r\n\r\n이 때, `for`문을 구성하기 위해 `a`와 `b`의 대소 여부를 판단할 필요가 있다.\r\n\r\n응답이 `long`이므로, `int`로 반환하지 않도록 주의하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 두 정수 사이의 합 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 14:16:50\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int] 정수 1\r\n\t * @param b: [int] 정수 2\r\n\t *\r\n\t * @return [long] 해답\r\n\t */\r\n\tpublic long solution(int a, int b)\r\n\t{\r\n\t\tlong answer = 0;\r\n\t\t\r\n\t\tint start = Math.min(a, b);\r\n\t\tint end = Math.max(a, b);\r\n\t\t\r\n\t\tfor (int i = start; i <= end; i++)\r\n\t\t{\r\n\t\t\tanswer += i;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0039","2021","12","16","programmers-a0039"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 나누어 떨어지는 숫자 배열 (12910)","excerpt":"array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:26:55+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0038.md","content":"\r\n# 나누어 떨어지는 숫자 배열\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [나누어 떨어지는 숫자 배열](https://programmers.co.kr/learn/courses/30/lessons/12910)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\narray의 각 element 중 `divisor`로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, `solution`을 작성해주세요.\r\n`divisor`로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `arr`은 자연수를 담은 배열입니다.\r\n* 정수 `i`, `j`에 대해 `i ≠ j` 이면 `arr[i] ≠ arr[j]` 입니다.\r\n* `divisor`는 자연수입니다.\r\n* `array`는 길이 1 이상인 배열입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       arr       | divisor |     return      |\r\n| :-------------: | :-----: | :-------------: |\r\n| { 5, 9, 7, 10 } |    5    |    { 5, 10 }    |\r\n| { 2, 36, 1, 3 } |    1    | { 1, 2, 3, 36 } |\r\n|   { 3, 2, 6 }   |   10    |     { -1 }      |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예#1**\r\n\r\n`arr`의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다.\r\n\r\n**입출력 예#2**\r\n\r\n`arr`의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.\r\n\r\n**입출력 예#3**\r\n\r\n3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`arr`의 요소 중 `divisor`으로 나누어 떨어지는 수들을 오름차순으로 정렬하여 반환한다.\r\n\r\n`arr`의 어떤 수가 `divisor`에 나누어 떨어질지 알 수 없으므로, 가변 배열 `ArrayList`를 선언하여, 해당하는 값을 담는다.\r\n\r\n`for`문을 돌며 `arr`의 요소를 `divisor`으로 나눠보며 완전히 나누어 떨어질 경우, `ArrayList`에 담는다. 이후 정렬 후 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 나누어 떨어지는 숫자 배열 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 14:08:59\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param arr: [int[]] 자연수 배열\r\n\t * @param divisor: [int] 나눌 수\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] arr, int divisor)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item : arr)\r\n\t\t{\r\n\t\t\t// 나누어 떨어질 경우\r\n\t\t\tif (item % divisor == 0)\r\n\t\t\t{\r\n\t\t\t\tlist.add(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 나누어 떨어진 수가 하나도 없을 경우\r\n\t\tif (list.isEmpty())\r\n\t\t{\r\n\t\t\tlist.add(-1);\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().sorted().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0038","2021","12","16","programmers-a0038"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 같은 숫자는 싫어 (12906)","excerpt":"배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:16:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0037.md","content":"\r\n# 같은 숫자는 싫어\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [같은 숫자는 싫어](https://programmers.co.kr/learn/courses/30/lessons/12906)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n배열 `arr`가 주어집니다. 배열 `arr`의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 `arr`에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 `arr`의 원소들의 순서를 유지해야 합니다. 예를 들면,\r\n\r\n* `arr = [ 1, 1, 3, 3, 0, 1, 1 ]` 이면 `[ 1, 3, 0, 1 ` 을 return 합니다.\r\n* `arr = [ 4, 4, 4, 3, 3 ]` 이면 `[ 4, 3 ]` 을 return 합니다.\r\n* \r\n배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 배열 `arr`의 크기 : 1,000,000 이하의 자연수\r\n* 배열 `arr`의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|           arr           |     answer     |\r\n| :---------------------: | :------------: |\r\n| { 1, 1, 3, 3, 0, 1, 1 } | { 1, 3, 0, 1 } |\r\n|    { 4, 4, 4, 3, 3 }    |    { 4, 3 }    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1, 2**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n임의의 정수 배열 `arr`이 주어진다. 이 배열에서 동일하게 연속된 값이 있다면 전부 제거하고 하나만 남긴다. 이렇게 연속된 값을 전부 하나로 변경하여 반환하는 알고리즘을 구현해야한다.\r\n\r\n배열 요소의 고유값을 요구하는 것이 아니므로, `HashSet`을 쓰면 안된다. 일례로, **입력 1**을 보면 `{ 1, 1, 3, 3, 0, 1, 1 }` -> `{ 1, 3, 0, 1 }`이 되는데, 1이 두 개가 있음을 확인할 수 있다.\r\n\r\n<br />\r\n\r\n정확히 몇 개의 요소가 생길지 알 수 없으므로 `ArrayList`를 사용하는 것이 적절해보인다.\r\n\r\n`ArrayList`의 초기값으로 `arr[0]`을 하나 넣어놓는다. 이후 `arr[1]` 부터 탐색하며, `ArrayList` 마지막에 들어있는 수와 비교한다.\r\n\r\n* 만약 `ArrayList`의 마지막과 다른 값일 경우, 연속되지 않았으므로 `ArrayList`에 넣는다.\r\n* `ArrayList`의 마지막과 같은 값일 경우, 연속된 값이므로 넘어간다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 같은 숫자는 싫어 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.13 Mon 13:32:56\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param arr: [int[]] 0 ~ 9 사이의 숫자 배열\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] arr)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\tlist.add(arr[0]);\r\n\t\t\r\n\t\tint index = 1;\r\n\t\t\r\n\t\tfor (int i = 1; i < arr.length; i++)\r\n\t\t{\r\n\t\t\t// list의 마지막 숫자와 같지 않을 경우\r\n\t\t\tif (list.get(index - 1) != arr[i])\r\n\t\t\t{\r\n\t\t\t\tindex++;\r\n\t\t\t\tlist.add(arr[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0037","2021","12","16","programmers-a0037"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 상위 n개 레코드 (59405)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:06:17+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0036.md","content":"\r\n# 상위 n개 레코드\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [상위 n개 레코드](https://programmers.co.kr/learn/courses/30/lessons/59405)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 가장 먼저 들어온 동물의 이름을 조회하는 SQL 문을 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어, `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A399552  |     Dog     | 2013-10-14 15:38:00 |      Normal      |   Jack   |  Neutered Male  |\r\n|  A379998  |     Dog     | 2013-10-23 11:42:00 |      Normal      | Disciple |   Intact Male   |\r\n|  A370852  |     Dog     | 2013-11-03 15:04:00 |      Normal      |  Katie   |  Spayed Female  |\r\n|  A403564  |     Dog     | 2013-11-18 17:03:00 |      Normal      |   Anna   |  Spayed Female  |\r\n\r\n이 중 가장 보호소에 먼저 들어온 동물은 Jack입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| NAME  |\r\n| :---: |\r\n| Jack  |\r\n\r\n※ 보호소에 가장 먼저 들어온 동물은 한 마리인 경우만 테스트 케이스로 주어집니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n가장 먼저 들어온 동물의 `NAME`을 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT NAME FROM ANIMAL_INS ORDER BY DATETIME ASC LIMIT 1;\r\n```","url":["2021-12-16-programmers-a0036","2021","12","16","programmers-a0036"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 다트 게임 (17682)","excerpt":"카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~ 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T20:02:11+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0035.md","content":"\r\n# 다트 게임\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [다트 게임](https://programmers.co.kr/learn/courses/30/lessons/17682)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~\r\n\r\n![image](http://t1.kakaocdn.net/welcome2018/gamestar.png)\r\n\r\n카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.\r\n갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.\r\n\r\n1. 다트 게임은 총 3번의 기회로 구성된다.\r\n2. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.\r\n3. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수$^1$, 점수$^2$, 점수$^3$)으로 계산된다.\r\n4. 옵션으로 스타상(\\*) , 아차상(#)이 존재하며 스타상(\\*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.\r\n5. 스타상(\\*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(\\*)의 점수만 2배가 된다. (예제 4번 참고)\r\n6. 스타상(\\*)의 효과는 다른 스타상(\\*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(\\*) 점수는 4배가 된다. (예제 4번 참고)\r\n7. 스타상(\\*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)\r\n8. Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.\r\n9. 스타상(\\*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.\r\n\r\n0 ~ 10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 입력 형식\r\n\r\n`\"점수|보너스|[옵션]\"`으로 이루어진 문자열 3세트.\r\n\r\n예) 1S2D\\*3T\r\n\r\n* 점수는 0에서 10 사이의 정수이다.\r\n* 보너스는 S, D, T 중 하나이다.\r\n* 옵선은 \\*이나 # 중 하나이며, 없을 수도 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 출력 형식\r\n\r\n3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.\r\n\r\n예) 37\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예제\r\n\r\n| 예제  | dartResult | answer |            설명             |\r\n| :---: | :--------: | :----: | :-------------------------: |\r\n|   1   |  1S2D\\*3T  |   37   |    11 * 2 + 22 * 2 + 33     |\r\n|   2   |  1D2S#10S  |   9    |    12 + 21 * (-1) + 101     |\r\n|   3   |   1D2S0T   |   3    |        12 + 21 + 03         |\r\n|   4   | 1S\\*2T\\*3S |   23   |  11 * 2 * 2 + 23 * 2 + 31   |\r\n|   5   | 1D#2S\\*3S  |   5    | 12 * (-1) * 2 + 21 * 2 + 31 |\r\n|   6   |  1T2D3D#   |   -4   |     13 + 22 + 32 * (-1)     |\r\n|   7   |  1D2S3T\\*  |   59   |    12 + 21 * 2 + 33 * 2     |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문제를 해결하는 방식이 생각보다는 좀 까다롭다.\r\n\r\n* `점수 - 보너스 - 옵션` 순으로 배치되지만, 옵션은 있을 수도, 없을 수도 있다.\r\n* 스타상(\\*)의 경우 이전 점수에도 영향을 준다.\r\n  * 스타상은 가장 첫 점수에도 나올 수 있으며, 이 경우 이전 점수가 없으므로 해당 점수만 영향을 준다.\r\n\r\n때문에 각 점수 세트를 정확히 분리할 수 있어야하고, 이전 점수를 건드릴 필요가 있기 때문에 배열 형태로 점수를 저장할 필요가 있어보인다.\r\n\r\n<br />\r\n\r\n1. 점수 세트 분리\r\n2. 점수 세트의 점수, 보너스, 옵션 분리\r\n3. 점수와 보너스를 곱해 기본 점수를 구한다\r\n4. 옵션 효과에 따라 점수에 반영한다\r\n\r\n1번, 2번이 좀 까다로울 수 있겠지만, 정규식을 사용한다면 매우 간단하게 분리할 수 있다.\r\n\r\n* 점수 분리 정규식 - `([0-9]0?)([SDT])([*#]?)`\r\n* `[0-9]` - 0 ~ 9 사이의 숫자 한 자리\r\n* `0?` - 0이 있을 수도 있고, 없을 수도 있음\r\n* `[SDT]` - 보너스\r\n* `[*#]` - *, # 한 자리\r\n* `[*#]?` - *, #이 있을 수도 있고, 없을 수도 있음\r\n\r\n`()`의 경우 정규식 자체에 영향을 주진 않지만, 코드 내에서 해당 정규식을 그룹별로 분리할 때 쓴다.\r\n\r\nJAVA의 경우 `group()` 메서드를 통해 `()`로 구분된 그룹별로 패턴을 따로 뽑아낼 수 있다. 예를 들어, `([0-9]0?)`의 경우 `2S*`에서 `2`만 뺄 수 있다.\r\n\r\n* `group(1)` - 2\r\n* `group(2)` - S\r\n* `group(3)` - *\r\n\r\n정규식으로 점수 세트 하나를 뽑아낸 뒤에, 굳이 이거 저거 빼고 *# 존재여부 판별없이 정규식 하나만으로 전부 해결할 수 있다.\r\n\r\n<br />\r\n\r\n점수 분리를 성공적으로 했다면 이후는 쉽다. 곱할거 곱해주고, 반영할거 반영해서 배열에 저장하면 된다. 만약, 스타상이 떴다? 이전 데이터의 점수를 호출해서 반영해주면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 다트 게임 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 17:55:08\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param dartResult: [String] 점수|보너스|옵션 문자열 (옵션은 선택사항)\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String dartResult)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\tint index = 0;\r\n\t\t\r\n\t\tMatcher matcher = Pattern.compile(\"([0-9]0?)([SDT])([*#]?)\").matcher(dartResult);\r\n\t\t\r\n\t\tArrayList<Integer> scores = new ArrayList<>();\r\n\t\t\r\n\t\twhile (matcher.find())\r\n\t\t{\r\n\t\t\tint type = matcher.group(2).equals(\"T\") ? 3 : matcher.group(2).equals(\"D\") ? 2 : 1;\r\n\t\t\tint option = matcher.group(3).equals(\"*\") ? 2 : matcher.group(3).equals(\"#\") ? -1 : 1;\r\n\t\t\t\r\n\t\t\tint score = (int) Math.pow(Integer.parseInt(matcher.group(1)), type) * option;\r\n\t\t\tscores.add(index, score);\r\n\t\t\t\r\n\t\t\t// 인덱스가 0보다 크고, 스타상을 받았을 경우\r\n\t\t\tif (index > 0 && option == 2)\r\n\t\t\t{\r\n\t\t\t\t// 이전 점수도 스타상의 영향으로 2배가 된다.\r\n\t\t\t\tscores.set(index - 1, scores.get(index - 1) * option);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\t\r\n\t\tfor (Integer score : scores)\r\n\t\t{\r\n\t\t\tanswer += score;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```\r\n\r\n정규식에 대한 약간의 이해가 있다면 매우 쉽게 풀 수 있는 문제.\r\n\r\n정규식의 사용 부분이 궁금하다면 `matcher.group()`이 사용되는 구문을 유심히 보자.","url":["2021-12-16-programmers-a0035","2021","12","16","programmers-a0035"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 여러 기준으로 정렬하기 (59404)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T19:22:38+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0034.md","content":"\r\n# 여러 기준으로 정렬하기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [여러 기준으로 정렬하기](https://programmers.co.kr/learn/courses/30/lessons/59404)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 아이디와 이름, 보호 시작일을 이름 순으로 조회하는 SQL문을 작성해주세요. 단, 이름이 같은 동물 중에서는 보호를 나중에 시작한 동물을 먼저 보여줘야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어, `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION | NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :---: | :-------------: |\r\n|  A349996  |     Cat     | 2018-01-22 14:32:00 |      Normal      | Sugar |  Neutered Male  |\r\n|  A350276  |     Cat     | 2017-08-13 13:50:00 |      Normal      | Jewel |  Spayed Female  |\r\n|  A396810  |     Dog     | 2016-08-22 16:13:00 |     Injured      | Raven |  Spayed Female  |\r\n|  A410668  |     Cat     | 2015-11-19 13:41:00 |      Normal      | Raven |  Spayed Female  |\r\n\r\n1. 이름을 사전 순으로 정렬하면 다음과 같으며, 'Jewel', 'Raven', 'Sugar'\r\n2. 'Raven'이라는 이름을 가진 개와 고양이가 있으므로, 이 중에서는 보호를 나중에 시작한 개를 먼저 조회합니다.\r\n\r\n따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID | NAME  |      DATETIME       |\r\n| :-------: | :---: | :-----------------: |\r\n|  A350276  | Jewel | 2017-08-13 13:50:00 |\r\n|  A396810  | Raven | 2016-08-22 16:13:00 |\r\n|  A410668  | Raven | 2015-11-19 13:41:00 |\r\n|  A349996  | Sugar | 2018-01-22 14:32:00 |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n모든 동물의 `ANIMAL_ID`, `NAME`, `DATETIME`을 조회한다. 결과는 `NAME`의 오름차순으로 보여주되, 동일한 이름을 가질 경우 가장 최근에 들어온 동물. 즉, `DATETIME`의 내림차순으로 보여준다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME, DATETIME FROM ANIMAL_INS ORDER BY NAME, DATETIME DESC;\r\n```","url":["2021-12-16-programmers-a0034","2021","12","16","programmers-a0034"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 가운데 글자 가져오기 (12903)","excerpt":"단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T19:18:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0033.md","content":"\r\n# 가운데 글자 가져오기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [가운데 글자 가져오기](https://programmers.co.kr/learn/courses/30/lessons/12903)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n단어 `s`의 가운데 글자를 반환하는 함수, `solution`을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한 사항\r\n\r\n* `s`는 길이가 1 이상, 100이하인 스트링입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문자열 `s`가 있을 때, 가운데 글자를 반환하면 되는 간단한 문제. 단, 짝수일 경우 두 글자를 반환한다.\r\n\r\n`s`의 길이를 파악하여 홀짝 여부를 판단한다. 홀수라면 가운데 한 글자, 짝수라면 두 글자를 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 가운데 글자 가져오기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 17:43:58\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String s)\r\n\t{\r\n\t\tint index = s.length() / 2;\r\n\t\t\r\n\t\treturn s.length() % 2 == 0 ? s.substring(index - 1, index + 1) : s.substring(index, index + 1);\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0033","2021","12","16","programmers-a0033"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 비밀지도 (17681)","excerpt":"네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T01:02:41+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0032.md","content":"\r\n# 비밀지도\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [비밀지도](https://programmers.co.kr/learn/courses/30/lessons/17681)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\r\n\r\n1. 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 \"공백\"(\" \") 또는 \"벽\"(\"#\") 두 종류로 이루어져 있다.\r\n2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \"지도 1\"과 \"지도 2\"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.\r\n3. \"지도 1\"과 \"지도 2\"는 각각 정수 배열로 암호화되어 있다.\r\n4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\r\n\r\n![image](http://t1.kakaocdn.net/welcome2018/secret8.png)\r\n\r\n네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 입력 형식\r\n\r\n입력으로 지도의 한 변 크기 `n`과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.\r\n\r\n* 1 ≦ n ≦ 16\r\n* arr1, arr2는 길이 n인 정수 배열로 주어진다.\r\n* 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.\r\n\r\n\r\n\r\n\r\n\r\n## 출력 형식\r\n\r\n원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예제\r\n\r\n| 매개변수 |                      값                       |\r\n| :------: | :-------------------------------------------: |\r\n|    n     |                       5                       |\r\n|   arr1   |             { 9, 20, 28, 18, 11 }             |\r\n|   arr2   |             { 30, 1, 21, 17, 28 }             |\r\n|   출력   | { \"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\" } |\r\n\r\n| 매개변수 |                              값                              |\r\n| :------: | :----------------------------------------------------------: |\r\n|    n     |                              6                               |\r\n|   arr1   |                  { 46, 33, 33, 22, 31, 50 }                  |\r\n|   arr2   |                  { 27, 56, 19, 14, 14, 10 }                  |\r\n|   출력   | { \"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \" } |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n두 개의 지도가 있으며, 이 지도를 겹쳐서 진짜 지도를 확인해야 한다. 두 지도 중 하나라도 벽(#)이 있을 경우 해당 공간은 벽이다.\r\n\r\n`10101 -> # # #`이므로, `# = 1`, `공백 = 0`으로 볼 수 있다. 두 값 중 하나라도 1(#)일 경우 해당 지역은 1(#)이 되므로, OR 연산을 구현하면 된다.\r\n\r\n|   a   |   b   |  값   |\r\n| :---: | :---: | :---: |\r\n|   1   |   1   |   1   |\r\n|   1   |   0   |   1   |\r\n|   0   |   1   |   1   |\r\n|   0   |   0   |   0   |\r\n\r\nOR 연산은 `a`와 `b` 중 하나라도 1일 경우 1이 된다.\r\n\r\n<br />\r\n\r\n남은 건 10진수를 2진수로 변경하여 1을 #, 0을 공백으로 치환하기만 하면 된다.\r\n\r\n``` java\r\nprivate int[] dec2bin(int n, int num)\r\n{\r\n\tint[] arr = new int[n];\r\n\t\r\n\tfor (int i = 0; i < n; i++)\r\n\t{\r\n\t\tarr[n - i - 1] = num % 2;\r\n\t\t\r\n\t\tnum /= 2;\r\n\t}\r\n\t\r\n\treturn arr;\r\n}\r\n```\r\n\r\n2진수 변환 메서드는 위와 같다. 10진수 `num`을 `n`자리의 2진수로 변환하며 배열로 반환한다.\r\n\r\n반환된 배열의 값을 토대로 #과 공백을 나누어 문자열로 만들면 될 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 비밀지도 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:54:09\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 지도 길이\r\n\t * @param arr1: [int[]] 지도 1\r\n\t * @param arr2: [int[]] 지도 2\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic String[] solution(int n, int[] arr1, int[] arr2)\r\n\t{\r\n\t\tString[] map = new String[n];\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tint[] map1 = dec2bin(n, arr1[i]);\r\n\t\t\tint[] map2 = dec2bin(n, arr2[i]);\r\n\t\t\t\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < n; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하나라도 벽이 있을 경우 그 공간은 벽(#)\r\n\t\t\t\tbuilder.append((map1[j] | map2[j]) == 1 ? \"#\" : \" \");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmap[i] = builder.toString();\r\n\t\t}\r\n\t\t\r\n\t\treturn map;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 10진수 -> 2진수 배열 반환 메서드\r\n\t *\r\n\t * @param n: [int] 크기\r\n\t * @param num: [int] 10진수\r\n\t *\r\n\t * @return [int[]] 2진수 배열\r\n\t */\r\n\tprivate int[] dec2bin(int n, int num)\r\n\t{\r\n\t\tint[] arr = new int[n];\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tarr[n - i - 1] = num % 2;\r\n\t\t\t\r\n\t\t\tnum /= 2;\r\n\t\t}\r\n\t\t\r\n\t\treturn arr;\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0032","2021","12","16","programmers-a0032"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 부족한 금액 계산하기 (82612)","excerpt":"새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다. 놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T00:52:21+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0031.md","content":"\r\n# 부족한 금액 계산하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [부족한 금액 계산하기](https://programmers.co.kr/learn/courses/30/lessons/82612)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 `N`번 째 이용한다면 원래 이용료의 `N`배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\r\n놀이기구를 `count`번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 `solution` 함수를 완성하세요.\r\n단, 금액이 부족하지 않으면 0을 return 하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 놀이기구의 이용료 `price` : 1 ≤ `price` ≤ 2,500, `price`는 자연수\r\n* 처음 가지고 있던 금액 `money` : 1 ≤ `money` ≤ 1,000,000,000, `money`는 자연수\r\n* 놀이기구의 이용 횟수 `count` : 1 ≤ `count` ≤ 2,500, `count`는 자연수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| price | money | count | result |\r\n| :---: | :---: | :---: | :----: |\r\n|   3   |  20   |   4   |   10   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n시대상을 역행하는 놀이기구다. 타면 탈 수록 가격을 더 받는다니...\r\n\r\n`count` 횟수만큼 `for`문을 수행하여 `price * count`를 누적하여 반환한다.\r\n\r\n반환값이 `long`임에 주의하자. 간혹 아무 생각없이 `int`로 변수를 선언해서 반환해버리는 경우가 있는데, `int`에서 더 많은 범위를 가지는 `long`으로의 변환은 아무런 문제없이 자동으로 이루어지므로, `int`를 반환해도 문제가 없다. 하지만 체점 과정에서 `int`의 범위를 넘어버리는 수가 생길 경우 온전히 표현하지 못하게 되므로 오답이 발생한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 부족한 금액 계산하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:43:20\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param price: [int] 이용료\r\n\t * @param money: [int] 소지금\r\n\t * @param count: [int] 놀이기구를 이용한 횟수\r\n\t *\r\n\t * @return [long] 해답\r\n\t */\r\n\tpublic long solution(int price, int money, int count)\r\n\t{\r\n\t\tlong total = 0;\r\n\t\t\r\n\t\twhile (count > 0)\r\n\t\t{\r\n\t\t\ttotal += (long) price * count;\r\n\t\t\t\r\n\t\t\tcount--;\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.max(total - money, 0);\r\n\t}\r\n}\r\n```\r\n\r\n`total`을 `int`로 반환하지 않도록 주의하자.","url":["2021-12-16-programmers-a0031","2021","12","16","programmers-a0031"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 동물의 아이디와 이름 (59403)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:58:28+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0030.md","content":"\r\n# 동물의 아이디와 이름\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [동물의 아이디와 이름](https://programmers.co.kr/learn/courses/30/lessons/59403)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 아이디와 이름을 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID |     NAME     |\r\n| :-------: | :----------: |\r\n|  A349996  |    Sugar     |\r\n|  A350276  |    Jewel     |\r\n|  A350375  |     Meo      |\r\n|  A352555  |    Harley    |\r\n|  A352713  |     Gia      |\r\n|  A352872  | Peanutbutter |\r\n|  A353259  |      Bj      |\r\n\r\n((이하 생략))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n모든 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0030","2021","12","15","programmers-a0030"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 나머지가 1이 되는 수 찾기 (87389)","excerpt":"자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:36:45+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0029.md","content":"\r\n# 나머지가 1이 되는 수 찾기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [나머지가 1이 되는 수 찾기](https://programmers.co.kr/learn/courses/30/lessons/87389)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `n`이 매개변수로 주어집니다. `n`을 `x`로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 `x`를 return 하도록 `solution` 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 3 ≤ `n` ≤ 1,000,000\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|  10   |   3    |\r\n|  12   |   11   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n10을 3으로 나눈 나머지가 1이고, 3보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 3을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n12를 11로 나눈 나머지가 1이고, 11보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 11을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n별다른 요구사항은 없다. 그냥 `n`이라는 자연수를 나눴을 때, 나머지가 1이 되는 가장 작은 수 `x`를 반환하면 된다.\r\n\r\n그냥 `x = 1` 부터 나눠서 `n % x == 1`일 때까지 `x`를 증가시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 나머지가 1이 되는 수 찾기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:35:58\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint x = 1;\r\n\t\t\r\n\t\twhile (n % x != 1)\r\n\t\t{\r\n\t\t\tx++;\r\n\t\t}\r\n\t\t\r\n\t\treturn x;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0029","2021","12","15","programmers-a0029"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 최소직사각형 (86491)","excerpt":"명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다. 아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:22:00+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0028.md","content":"\r\n# 최소직사각형\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [최소직사각형](https://programmers.co.kr/learn/courses/30/lessons/86491)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.\r\n\r\n아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.\r\n\r\n| 명함 번호 | 가로 길이 | 세로 길이 |\r\n| :-------: | :-------: | :-------: |\r\n|     1     |    60     |    50     |\r\n|     2     |    30     |    70     |\r\n|     3     |    60     |    30     |\r\n|     4     |    80     |    40     |\r\n\r\n가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.\r\n\r\n모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 `sizes`가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `sizes`의 길이는 1 이상 10,000 이하입니다.\r\n* `sizes`의 원소는 `[ w, h ]` 형식입니다.\r\n* `w`는 명함의 가로 길이를 나타냅니다.\r\n* `h`는 명함의 세로 길이를 나타냅니다.\r\n* `w`와 `h`는 1 이상 1,000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                           sizes                           | result |\r\n| :-------------------------------------------------------: | :----: |\r\n|    { { 60, 50 }, { 30, 70 }, { 60, 30 }, { 80, 40 } }     |  4000  |\r\n| { { 10, 7 }, { 12, 3 }, { 8, 15 }, { 14, 7 }, { 5, 15 } } |  120   |\r\n| { { 14, 4 }, { 19, 6 }, { 6, 16 }, { 18, 7 }, { 7, 11 } } |  133   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.\r\n\r\n**입출력 예 #3**\r\n\r\n명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n일상생활에서 보는 명함의 크기는 제각각이다. 물론 어느정도의 규격은 가지는 것 같지만, 동일하다곤 할 수 없다. 또한 어떤 명함은 세로형이고, 어떤 명함은 가로형이다.\r\n\r\n이 문제에선 이렇게 다양한 명함들이 있는데, 이 명함을 문제없이 수납 가능한 지갑을 만드는 것이 목표다.\r\n\r\n<br />\r\n\r\n우리가 명함을 정리한다고 생각해보자. 크기나 앞뒤, 방향 상관없이 모든 명함이 긴 쪽으로 정렬하는 것이 보통이다.\r\n\r\n우리도 마찬가지로, 코드 상에서 우선 명함의 방향을 정렬할 필요가 있다. 조건에 관계없이, 우선 두 길이 중 긴 길이를 우선하여 정렬한다.\r\n\r\n그럼 상대적으로 `[ 명함의 긴 쪽, 명함의 짧은 쪽 ]`으로 정렬된다.\r\n\r\n이후 `for`문을 통해 하나하나 탐색해가며 명함의 긴 쪽 중 가장 큰 값, 명함의 짧은 쪽 중 가장 큰 값을 구하면 모든 명함을 문제없이 수납할 수 있을 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 최소직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:20:39\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param sizes: [int[][]] 가로 세로 길이\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[][] sizes)\r\n\t{\r\n\t\tint w = 0;\r\n\t\tint h = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < sizes.length; i++)\r\n\t\t{\r\n\t\t\tint a = sizes[i][0];\r\n\t\t\tint b = sizes[i][1];\r\n\t\t\t\r\n\t\t\t// 방향 상관없이 더 큰 길이를 sizes[i][0]에, 짧은 길이를 sizes[i][1]에 배치\r\n\t\t\tsizes[i][0] = Math.max(a, b);\r\n\t\t\tsizes[i][1] = Math.min(a, b);\r\n\t\t\t\r\n\t\t\t// 더 큰 길이의 최대값과, 더 작은 길이의 최대값을 구함\r\n\t\t\tw = Math.max(w, sizes[i][0]);\r\n\t\t\th = Math.max(h, sizes[i][1]);\r\n\t\t}\r\n\t\t\r\n\t\treturn w * h;\r\n\t}\r\n}\r\n```\r\n\r\n원한다면 `w = Math.max(w, Math.max(sizes[i][0], sizes[i][1]));`의 형태와 같이 간소화할 수도 있다.","url":["2021-12-15-programmers-a0028","2021","12","15","programmers-a0028"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 어린 동물 찾기 (59037)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:03:19+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0027.md","content":"\r\n# 어린 동물 찾기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [어린 동물 찾기](https://programmers.co.kr/learn/courses/30/lessons/59037)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 젊은 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A365172  |     Dog     | 2014-08-26 12:53:00 |      Normal      |  Diablo  |  Neutered Male  |\r\n|  A367012  |     Dog     | 2015-09-16 09:06:00 |       Sick       |  Miller  |  Neutered Male  |\r\n|  A365302  |     Dog     | 2017-01-08 16:34:00 |       Aged       |  Minnie  |  Spayed Female  |\r\n|  A381217  |     Dog     | 2017-07-08 09:41:00 |       Sick       | Cherokee |  Neutered Male  |\r\n\r\n이 중 젊은 동물은 Diablo, Miller, Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |  NAME   |\r\n| :-------: | :-----: |\r\n|  A365172  | Diablo  |\r\n|  A367012  | Miller  |\r\n|  A381217  | Cheroke |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`INTAKE_CONDITION`이 `Aged`가 아닌 젊은 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS WHERE INTAKE_CONDITION != 'Aged' ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0027","2021","12","15","programmers-a0027"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 2016년 (12901)","excerpt":"2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a, b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN, MON, TUE, WED, THU, FRI, SAT 입니다. 예를 들어 a = 5, b = 24라면 5월 24일은 화요일이므로 문자열 \"TUE\"를 반환하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:58:49+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0026.md","content":"\r\n# 2016년\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [2016년](https://programmers.co.kr/learn/courses/30/lessons/12901)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 `a`, `b`를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, `solution`을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN, MON, TUE, WED, THU, FRI, SAT 입니다. 예를 들어 `a = 5`, `b = 24`라면 5월 24일은 화요일이므로 문자열 \"TUE\"를 반환하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 2016년은 윤년입니다.\r\n* 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   a   |   b   | result |\r\n| :---: | :---: | :----- |\r\n|   5   |  24   | \"TUE\"  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n2016년 중 특정 날짜에 해당하는 요일을 요구하는 문제. 날짜 객체를 사용하면 별다른 연산 없이 쉽게 구할 수 있다.\r\n\r\n여기서는 `Date` 객체를 활용하여, `yyyy-MM-dd` 형태의 문자열을 `Date` 객체로 변환하여 요일을 빼낼 것이다.\r\n\r\n`Date.valueOf(\"yyyy-MM-dd\").toLocalDate().getDayOfWeek().getValue()`를 통해 요일을 빼낼 수 있다.\r\n\r\n다행히 월요일을 1부터 시작해서, 7인 일요일로 끝난다. 간혹 언어나 설정에 따라 1을 일요일로 치거나, 0을 월요일 혹은 일요일로 시작하기도 한다.\r\n\r\n코드를 간소화하기 위해 1 ~ 7 사이의 숫자를 입력하면 요일로 반환하는 메서드를 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.sql.Date;\r\n\r\n/**\r\n * 2016년 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:38:13\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int] 월\r\n\t * @param b: [int] 일\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int a, int b)\r\n\t{\r\n\t\tString dateStr = new StringBuilder().append(\"2016-\").append(a).append(\"-\").append(b).toString();\r\n\t\t\r\n\t\tint dayOfWeek = Date.valueOf(dateStr).toLocalDate().getDayOfWeek().getValue();\r\n\t\t\r\n\t\treturn getDayName(dayOfWeek);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요일 이름 반환 메서드\r\n\t *\r\n\t * @param dayOfWeek: [int] 주별 요일 번호\r\n\t *\r\n\t * @return [String] 요일 이름\r\n\t */\r\n\tprivate String getDayName(int dayOfWeek)\r\n\t{\r\n\t\treturn switch (dayOfWeek)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1 -> \"MON\";\r\n\t\t\t\t\tcase 2 -> \"TUE\";\r\n\t\t\t\t\tcase 3 -> \"WED\";\r\n\t\t\t\t\tcase 4 -> \"THU\";\r\n\t\t\t\t\tcase 5 -> \"FRI\";\r\n\t\t\t\t\tcase 6 -> \"SAT\";\r\n\t\t\t\t\tdefault -> \"SUN\";\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0026","2021","12","15","programmers-a0026"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 아픈 동물 찾기 (59036)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:50:59+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0025.md","content":"\r\n# 아픈 동물 찾기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [아픈 동물 찾기](https://programmers.co.kr/learn/courses/30/lessons/59036)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 아픈 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A365172  |     Dog     | 2014-08-26 12:53:00 |      Normal      |  Diablo  |  Neutered Male  |\r\n|  A367012  |     Dog     | 2015-09-16 09:06:00 |       Sick       |  Miller  |  Neutered Male  |\r\n|  A365302  |     Dog     | 2017-01-08 16:34:00 |       Aged       |  Minnie  |  Spayed Female  |\r\n|  A381217  |     Dog     | 2017-07-08 09:41:00 |       Sick       | Cherokee |  Neutered Male  |\r\n\r\n이 중 아픈 동물은 Miller와 Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |   NAME   |\r\n| :-------: | :------: |\r\n|  A367012  |  Miller  |\r\n|  A381217  | Cherokee |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`INTAKE_CONDITION`이 `Sick`으로 표기된 아픈 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS WHERE INTAKE_CONDITION = 'Sick' ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0025","2021","12","15","programmers-a0025"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 두 개 뽑아서 더하기 (68644)","excerpt":"정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:47:44+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0024.md","content":"\r\n# 두 개 뽑아서 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수 배열 `numbers`가 주어집니다. `numbers`에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `numbers`의 길이는 2 이상 100 이하입니다.\r\n  * `numbers`의 모든 수는 0 이상 100 이하입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      numbers      |        result        |\r\n| :---------------: | :------------------: |\r\n| { 2, 1, 3, 4, 1 } | { 2, 3, 4, 5, 6, 7 } |\r\n|  { 5, 0, 2, 7 }   |  { 2, 5, 7, 9, 12 }  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n* 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)\r\n* 3 = 2 + 1 입니다.\r\n* 4 = 1 + 3 입니다.\r\n* 5 = 1 + 4 = 2 + 3 입니다.\r\n* 6 = 2 + 4 입니다.\r\n* 7 = 3 + 4 입니다.\r\n  \r\n따라서 { 2, 3, 4, 5, 6, 7 } 을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n* 2 = 0 + 2 입니다.\r\n* 5 = 5 + 0 입니다.\r\n* 7 = 0 + 7 = 5 + 2 입니다.\r\n* 9 = 2 + 7 입니다.\r\n* 12 = 5 + 7 입니다.\r\n  \r\n따라서 { 2, 5, 7, 9, 12 } 를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n정수 배열 `numbers`에서 임의의 정수 두 개를 뽑아 더할 때, 나올 수 있는 모든 수의 배열을 요구하는 알고리즘이다.\r\n\r\n1. 배열에서 임의의 요소 두 개를 뽑아내는 알고리즘\r\n2. 두 수를 더한 값 저장\r\n\r\n1번의 경우 이중 `for`로도 충분히 구현할 수 있지만, 이번에는 좀 더 알고리즘적인 측면에서 접근하고자 한다. 백트래킹을 활용한 조합 알고리즘을 통해 요소를 뽑아내보자.\r\n\r\n2번의 경우 `HashSet`을 사용하여 더한 값의 고유값만을 지정하도록 하자.\r\n\r\n<br />\r\n\r\n``` java\r\n/**\r\n * 조합 메서드 (백트래킹)\r\n *\r\n * @param numbers: [int[]] 대상 배열\r\n * @param isCheck: [int[]] 백트래킹 체크 여부 배열\r\n * @param start: [int] 시작값\r\n * @param target: [int] 조합할 갯수\r\n */\r\nprivate void combination(int[] numbers, boolean[] isCheck, int start, int target)\r\n{\r\n\t// 조합할 갯수가 0개일 경우 (탐색 완료)\r\n\tif (target == 0)\r\n\t{\r\n\t\tint sum = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < numbers.length; i++)\r\n\t\t{\r\n\t\t\t// 백트래킹 체크일 경우\r\n\t\t\tif (isCheck[i])\r\n\t\t\t{\r\n\t\t\t\tsum += numbers[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tset.add(sum);\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tfor (int i = start; i < numbers.length; i++)\r\n\t\t{\r\n\t\t\tisCheck[i] = true;\r\n\t\t\t\r\n\t\t\tcombination(numbers, isCheck, i + 1, target - 1);\r\n\t\t\t\r\n\t\t\tisCheck[i] = false;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n백트래킹 조합 알고리즘은 위와 같다.\r\n\r\n조합을 수행한 뒤 선택된 두 값을 더해 `HashSet` 객체에 입력한다.\r\n\r\n이후 해당값을 정렬하여 배열로 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * 두 개 뽑아서 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:19:39\r\n */\r\nclass Solution\r\n{\r\n\tprivate HashSet<Integer> set;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] numbers)\r\n\t{\r\n\t\tset = new HashSet<>();\r\n\t\t\r\n\t\tboolean[] isCheck = new boolean[numbers.length];\r\n\t\t\r\n\t\tcombination(numbers, isCheck, 0, 2);\r\n\t\t\r\n\t\treturn set.stream().mapToInt(Integer::intValue).sorted().toArray();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 메서드 (백트래킹)\r\n\t *\r\n\t * @param numbers: [int[]] 대상 배열\r\n\t * @param isCheck: [int[]] 백트래킹 체크 여부 배열\r\n\t * @param start: [int] 시작값\r\n\t * @param target: [int] 조합할 갯수\r\n\t */\r\n\tprivate void combination(int[] numbers, boolean[] isCheck, int start, int target)\r\n\t{\r\n\t\t// 조합할 갯수가 0개일 경우 (탐색 완료)\r\n\t\tif (target == 0)\r\n\t\t{\r\n\t\t\tint sum = 0;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < numbers.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 백트래킹 체크일 경우\r\n\t\t\t\tif (isCheck[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tsum += numbers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tset.add(sum);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = start; i < numbers.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisCheck[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(numbers, isCheck, i + 1, target - 1);\r\n\t\t\t\t\r\n\t\t\t\tisCheck[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0024","2021","12","15","programmers-a0024"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 이름이 있는 동물의 아이디 (59407)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:21:06+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0023.md","content":"\r\n# 이름이 있는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 있는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59407)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A434523  |     Cat     | 2015-11-20 14:18:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A562649  |     Dog     | 2014-03-20 18:06:00 |       Sick       |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n이름이 있는 동물의 ID는 A524634와 A465637입니다. 따라서 SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A465637  |\r\n|  A524634  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`NAME`을 가진 동물들을 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NOT NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0023","2021","12","15","programmers-a0023"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 두 개 뽑아서 더하기 (12982)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:10:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0022.md","content":"\r\n# 두 개 뽑아서 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [예산](https://programmers.co.kr/learn/courses/30/lessons/12982)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\nS사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.\r\n\r\n물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.\r\n\r\n부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.\r\n* `d`의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.\r\n* `budget`은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         d         | budget | result |\r\n| :---------------: | :----: | :----: |\r\n| { 1, 3, 2, 5, 4 } |   9    |   3    |\r\n|  { 2, 2, 3, 3 }   |   10   |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.\r\n\r\n* 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.\r\n* 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.\r\n\r\n3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n생각을 조금만 해보면 크게 어렵지 않다. 최대한 많은 부서에 예산을 할당하는 것이 목표며, 예산을 줄거면 주고, 말거면 말아야한다. 즉, 반만 주거나 일부만 줘선 안된다는 얘기다.\r\n\r\n복잡하게 생각할 것 없이, 예산 순으로 정렬하여, 가장 예산을 적게 요청한 부서부터 순서대로 카운팅하면 된다.\r\n\r\n예산이 한정되어 있으므로, 예산을 적게 요청한 부서 순으로 주면 더욱 많은 부서에 예산을 줄 확률이 높아진다.\r\n\r\n1. 예산 순으로 정렬\r\n2. 예산이 0보다 작아질 때까지 요청한 예산 감산\r\n\r\n0이 넘어가는 순간 예산 초과이므로, 해당 부서부터는 예산을 줄 수 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 예산 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:07:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param d: [int[]] 부서별 신청 금액\r\n\t * @param budget: [int] 예산\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] d, int budget)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tArrays.sort(d);\r\n\t\t\r\n\t\tfor (int j : d)\r\n\t\t{\r\n\t\t\tbudget -= j;\r\n\t\t\t\r\n\t\t\t// 예산을 초과할 경우\r\n\t\t\tif (budget < 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tanswer++;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0022","2021","12","15","programmers-a0022"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 예산 (12982)","excerpt":"S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:10:27+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0021.md","content":"\r\n# 예산\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [예산](https://programmers.co.kr/learn/courses/30/lessons/12982)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\nS사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.\r\n\r\n물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.\r\n\r\n부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.\r\n* `d`의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.\r\n* `budget`은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         d         | budget | result |\r\n| :---------------: | :----: | :----: |\r\n| { 1, 3, 2, 5, 4 } |   9    |   3    |\r\n|  { 2, 2, 3, 3 }   |   10   |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.\r\n\r\n* 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.\r\n* 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.\r\n\r\n3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n생각을 조금만 해보면 크게 어렵지 않다. 최대한 많은 부서에 예산을 할당하는 것이 목표며, 예산을 줄거면 주고, 말거면 말아야한다. 즉, 반만 주거나 일부만 줘선 안된다는 얘기다.\r\n\r\n복잡하게 생각할 것 없이, 예산 순으로 정렬하여, 가장 예산을 적게 요청한 부서부터 순서대로 카운팅하면 된다.\r\n\r\n예산이 한정되어 있으므로, 예산을 적게 요청한 부서 순으로 주면 더욱 많은 부서에 예산을 줄 확률이 높아진다.\r\n\r\n1. 예산 순으로 정렬\r\n2. 예산이 0보다 작아질 때까지 요청한 예산 감산\r\n\r\n0이 넘어가는 순간 예산 초과이므로, 해당 부서부터는 예산을 줄 수 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 예산 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:07:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param d: [int[]] 부서별 신청 금액\r\n\t * @param budget: [int] 예산\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] d, int budget)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tArrays.sort(d);\r\n\t\t\r\n\t\tfor (int j : d)\r\n\t\t{\r\n\t\t\tbudget -= j;\r\n\t\t\t\r\n\t\t\t// 예산을 초과할 경우\r\n\t\t\tif (budget < 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tanswer++;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0021","2021","12","15","programmers-a0021"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 3진법 뒤집기 (68935)","excerpt":"자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:48:12+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0020.md","content":"\r\n# 3진법 뒤집기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [3진법 뒤집기](https://programmers.co.kr/learn/courses/30/lessons/68935)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `n`이 매개변수로 주어집니다. `n`을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `n`은 1 이상 100,000,000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|  45   |   7    |\r\n|  125  |  229   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n답을 도출하는 과정은 다음과 같습니다.\r\n\r\n| n (10진법) | n (3진법) | 앞뒤 반전(3진법) | 10진법으로 표현 |\r\n| :--------: | :-------: | :--------------: | :-------------: |\r\n|     45     |   1200    |       0021       |        7        |\r\n\r\n따라서 7을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n답을 도출하는 과정은 다음과 같습니다.\r\n\r\n| n (10진법) | n (3진법) | 앞뒤 반전(3진법) | 10진법으로 표현 |\r\n| :--------: | :-------: | :--------------: | :-------------: |\r\n|    125     |   11122   |      22111       |       229       |\r\n\r\n따라서 229를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n임의의 숫자를 3진법으로 치환하여 역순으로 배열하고, 이를 다시 10진법으로 치환하는 알고리즘이다.\r\n\r\n1. 10진법 -> 3진법 변환 알고리즘\r\n2. 3진법 -> 10진법 변환 알고리즘\r\n\r\n10진법과 3진법의 자유로운 변환이 이루어지도록 변환 모듈을 구성하는 것이 좋아보인다.\r\n\r\n또한, 3진법에서 숫자를 역순으로 배치해야하니, 각 숫자를 따로따로 `List`에 할당하여 한번에 역순으로 돌려버리는 방법을 차용하고자 한다.\r\n\r\n<br />\r\n\r\n10진법에서 3진법으로 변환하는 메소드는 아래와 같다.\r\n\r\n``` java\r\nprivate ArrayList<Integer> dec2ter(int num)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tint max = 0;\r\n\t\r\n\twhile (Math.pow(3, max) <= num)\r\n\t{\r\n\t\tmax++;\r\n\t}\r\n\t\r\n\tfor (int i = max - 1; i > -1; i--)\r\n\t{\r\n\t\tint pow = (int) Math.pow(3, i);\r\n\t\t\r\n\t\tlist.add(num / pow);\r\n\t\t\r\n\t\tnum %= pow;\r\n\t}\r\n\t\r\n\treturn list;\r\n}\r\n```\r\n\r\n정수 형태의 3진법은 크게 의미가 없다. 0이 앞에 나오게 되면 정수형으로 변환되면서 유실될 가능성도 크고, 굳이 정수형에서의 연산이 필요 없기 때문. 따라서 `ArrayList<Integer>`로 반환한다.\r\n\r\n``` java\r\nprivate int ter2dec(ArrayList<Integer> nums)\r\n{\r\n\tint flag = nums.size() - 1;\r\n\t\r\n\tint answer = 0;\r\n\t\r\n\tfor (int num : nums)\r\n\t{\r\n\t\tanswer += (int) Math.pow(3, flag) * num;\r\n\t\t\r\n\t\tflag--;\r\n\t}\r\n\t\r\n\treturn answer;\r\n}\r\n```\r\n\r\n3진법 -> 10진법 변환 알고리즘은 위와 같다.\r\n\r\n`dec2ter`으로 3진법 배열을 받아서, 이를 역순으로 배열하고 다시 `ter2dec` 메서드로 변환하면 된다. `Collections.reverse()` 메서드를 통해 `List` 같은 `Collection` 객체의 역순 배열을 수행할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * 3진법 뒤집기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 00:47:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tArrayList<Integer> list = dec2ter(n);\r\n\t\t\r\n\t\tCollections.reverse(list);\r\n\t\t\r\n\t\treturn ter2dec(list);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 10진법 -> 3진법 배열 반환 메서드\r\n\t *\r\n\t * @param num: [int] 자연수\r\n\t *\r\n\t * @return [ArrayList] 3진법 배열\r\n\t */\r\n\tprivate ArrayList<Integer> dec2ter(int num)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tint max = 0;\r\n\t\t\r\n\t\twhile (Math.pow(3, max) <= num)\r\n\t\t{\r\n\t\t\tmax++;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = max - 1; i > -1; i--)\r\n\t\t{\r\n\t\t\tint pow = (int) Math.pow(3, i);\r\n\t\t\t\r\n\t\t\tlist.add(num / pow);\r\n\t\t\t\r\n\t\t\tnum %= pow;\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 3진법 -> 10진법 반환 메서드\r\n\t *\r\n\t * @param nums: [ArrayList] 3진법 배열\r\n\t *\r\n\t * @return [int] 10진법 숫자\r\n\t */\r\n\tprivate int ter2dec(ArrayList<Integer> nums)\r\n\t{\r\n\t\tint flag = nums.size() - 1;\r\n\t\t\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int num : nums)\r\n\t\t{\r\n\t\t\tanswer += (int) Math.pow(3, flag) * num;\r\n\t\t\t\r\n\t\t\tflag--;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0020","2021","12","15","programmers-a0020"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 약수의 개수와 덧셈 (77884)","excerpt":"두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:29:31+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0019.md","content":"\r\n# 약수의 개수와 덧셈\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [약수의 개수와 덧셈](https://programmers.co.kr/learn/courses/30/lessons/77884)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n두 정수 `left`와 `right`가 매개변수로 주어집니다. `left`부터 `right`까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `left` ≤ `right` ≤ 1,000\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| left  | right | result |\r\n| :---: | :---: | :----: |\r\n|  13   |  17   |   43   |\r\n|  24   |  27   |   52   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다.\r\n\r\n|  수   |      약수      | 약수의 개수 |\r\n| :---: | :------------: | :---------: |\r\n|  13   |     1, 13      |      2      |\r\n|  14   |  1, 2, 7, 14   |      4      |\r\n|  15   |  1, 3, 5, 15   |      4      |\r\n|  16   | 1, 2, 4, 8, 16 |      5      |\r\n|  17   |     1, 17      |      2      |\r\n\r\n따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다.\r\n\r\n|  수   |           약수           | 약수의 개수 |\r\n| :---: | :----------------------: | :---------: |\r\n|  24   | 1, 2, 3, 4, 6, 8, 12, 24 |      8      |\r\n|  25   |         1, 5, 25         |      3      |\r\n|  26   |       1, 2, 13, 26       |      4      |\r\n|  27   |       1, 3, 9, 27        |      4      |\r\n\r\n따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n난이도가 낮은 간단한 문제. 약수를 구하는 알고리즘 정도만 구현하면 어렵지않게 풀 수 있다.\r\n\r\n1. 약수를 구한다.\r\n   * 약수를 알 필요는 없고, 갯수 정도만 있어도 무방하다.\r\n2. 약수 갯수의 홀짝여부를 비교한다.\r\n   1. 짝수일 경우 가산한다.\r\n   2. 홀수일 경우 감산한다.\r\n3. 누적한 값을 반환한다.\r\n\r\n``` java\r\nprivate int[] measure(int num)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tfor (int i = 1; i <= Math.sqrt(num); i++)\r\n\t{\r\n\t\t// 임의의 수와 나누어 떨어질 경우\r\n\t\tif (num % i == 0)\r\n\t\t{\r\n\t\t\tlist.add(i);\r\n\t\t\t\r\n\t\t\t// num의 제곱근값이 아닐 경우\r\n\t\t\tif (i * i != num)\r\n\t\t\t{\r\n\t\t\t\tlist.add(num / i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn list.stream().sorted().mapToInt(Integer::intValue).toArray();\r\n}\r\n```\r\n\r\n약수를 구하는 알고리즘은 위와 같다. 약수를 구할 땐 대상의 제곱근까지만 확인해도 무방하다.\r\n\r\n예를 들어, 16의 경우 `[ 1, 2, 4, 8, 16 ]`을 가진다. $\\sqrt{16} = 4$이므로 4까지만 비교하여 `[ 1, 2, 4 ]`까지만 구해도 약수의 전체를 알 수 있다.\r\n\r\n16은 `16 / 1`, 8은 `16 / 2`를 통해 유추할 수 있기 때문이다. `i * i != num`일 경우 `num`이 자신의 제곱근을 약수로 갖는 것으로, 다른 수와 달리 `num`과 나누지 않고 `i` 하나만 추가한다. 위 예시에선 4가 그 케이스다.\r\n\r\n<br />\r\n\r\n이후 약수의 갯수를 확인하여 홀짝 여부에 따라 값을 가감하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 약수의 개수와 덧셈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 00:33:56\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param left: [int] 정수 1\r\n\t * @param right: [int] 정수 2\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int left, int right)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = left; i <= right; i++)\r\n\t\t{\r\n\t\t\tint count = measure(i).length;\r\n\t\t\t\r\n\t\t\tanswer += count % 2 == 0 ? i : -i;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 약수 반환 메서드\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t *\r\n\t * @return [int[]] 약수\r\n\t */\r\n\tprivate int[] measure(int num)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int i = 1; i <= Math.sqrt(num); i++)\r\n\t\t{\r\n\t\t\t// 임의의 수와 나누어 떨어질 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\tlist.add(i);\r\n\t\t\t\t\r\n\t\t\t\t// num의 제곱근값이 아닐 경우\r\n\t\t\t\tif (i * i != num)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.add(num / i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().sorted().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0019","2021","12","15","programmers-a0019"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 실패율 (42889)","excerpt":"슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:17:08+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0018.md","content":"\r\n# 실패율\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [실패율](https://programmers.co.kr/learn/courses/30/lessons/42889)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.amazonaws.com/files/production/bde471d8ac/48ddf1cc-c4ea-499d-b431-9727ee799191.png)\r\n\r\n슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.\r\n\r\n이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.\r\n\r\n* 실패율은 다음과 같이 정의한다.\r\n  * 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수\r\n\r\n전체 스테이지의 개수 `N`, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 `stages`가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 `solution` 함수를 완성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\r\n* `stages`의 길이는 1 이상 200,000 이하이다.\r\n* `stages`에는 1 이상 `N + 1` 이하의 자연수가 담겨있다.\r\n  * 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.\r\n  * 단, `N + 1` 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.\r\n* 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.\r\n* 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   N   |           stages           |      result       |\r\n| :---: | :------------------------: | :---------------: |\r\n|   5   | { 2, 1, 2, 6, 2, 4, 3, 3 } | { 3, 4, 2, 1, 5 } |\r\n|   4   |     { 4, 4, 4, 4, 4 }      |  { 4, 1, 2, 3 }   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 1 번 스테이지 실패율 : 1/8\r\n\r\n2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 2 번 스테이지 실패율 : 3/7\r\n\r\n마찬가지로 나머지 스테이지의 실패율은 다음과 같다.\r\n\r\n* 3 번 스테이지 실패율 : 2/4\r\n* 4번 스테이지 실패율 : 1/2\r\n* 5번 스테이지 실패율 : 0/1\r\n\r\n각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.\r\n\r\n* { 3, 4, 2, 1, 5 }\r\n\r\n**입출력 예 #2**\r\n\r\n모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.\r\n\r\n* { 4, 1, 2, 3 }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n각 스테이지의 실패율을 구하는 문제. 해당 스테이지까지 도전한 사람과, 실패한 사람을 구한다. 이 정보로 실패율을 구하여 실패율 순으로 정렬 후, 반환하는 것이 목표다.\r\n\r\n문제 제대로 안 읽으면 해당 스테이지까지 도전한 사람이 아니라, 전체 사람에서 실패율을 나누게 될 수도 있으니 주의할 것.\r\n\r\n1. 각 스테이지에 머무르고 있는 사람의 수를 카운팅\r\n2. 각 스테이지를 플레이한 사람의 수를 카운팅\r\n   * 만약 스테이지 4에 머무르고 있다면, 1 ~ 4의 스테이지를 시도했고, 4 스테이지의 실패율에 반영된다.\r\n   * N + 1 스테이지일 경우, 전부 클리어한 것이므로 모든 스테이지를 시도한 것이다.\r\n3. 각 스테이지에 머무르고 있는 사람 / 각 스테이지를 플레이한 사람 * 100 으로 실패율 계산\r\n4. 실패율 순으로 정렬하여 스테이지의 번호를 반환\r\n   * 만약, 실패율이 동일하다면 스테이지 순으로 정렬\r\n\r\n위와 같은 흐름으로 구성하면 된다.\r\n\r\n<br />\r\n\r\n1번과 2번은 `stages`의 탐색을 통해 어렵지않게 구현할 수 있다. `N`개의 길이를 가진 정수 배열 `fails`, `users`를 생성하여 각각 클리어 실패자와 시도자를 카운팅한다.\r\n\r\n``` java\r\nint[] fails = new int[N];\r\nint[] users = new int[N];\r\n\r\n// 시도자, 실패자 카운트\r\nfor (int stage : stages)\r\n{\r\n\t// 마지막 스테이지를 깨지 않았을 경우\r\n\tif (stage != N + 1)\r\n\t{\r\n\t\t// 실패한 유저 카운트\r\n\t\tfails[stage - 1]++;\r\n\t\t\r\n\t\t// 시도한 유저 카운트\r\n\t\tfor (int i = 0; i < stage; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 마지막 스테이지를 깼을 경우\r\n\telse\r\n\t{\r\n\t\t// 시도한 유저 전부 카운트\r\n\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n4 스테이지에 머무르고 있을 경우, 실제론 `fails[3]`에 저장되므로 `fails[stage - 1]`에 반영해야 함에 유의하자.\r\n\r\n<br />\r\n\r\n3번은 단순 연산 정도로 끝나지만, 문제는 4번. 실제로 반환해야하는 건 실패율이 아닌 해당 실패율을 가진 스테이지 번호다.\r\n\r\n정렬도 편하게 할 겸 `ArrayList<Double[]>`을 선언하여 스테이지 번호와 실패율을 배열로 관리한다.\r\n\r\n실패율은 `스테이지 실패 인원 수 / 스테이지 도전 인원 수`로 구할 수 있다. 단, 그 누구도 스테이지에 도달하지 못할 경우, 0으로 나누게 되므로 `isNaN()` 메서드로 반드시 NaN 처리를 해야한다.\r\n\r\n예를 들어, `N = 5`, `[ 1, 2, 2, 3, 4 ]`일 경우가 그렇다. 스테이지 5의 경우 그 누구도 시도조차 하지 못 했으므로 스테이지 실패율은 `0 / 0`. 즉, NaN이 된다. 따라서 이 경우 0으로 바꿔야 한다.\r\n\r\n``` java\r\n// 실패율\r\nArrayList<Double[]> failRate = new ArrayList<>();\r\n\r\n// 실패율에 인덱스와 값 할당\r\nfor (int i = 0; i < N; i++)\r\n{\r\n\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\r\n\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n}\r\n```\r\n\r\n`failRate`에 스테이지 번호와 실패율이 담긴 배열을 저장하면 된다.\r\n\r\n<br />\r\n\r\n``` java\r\n// 정렬\r\nfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n```\r\n\r\n정렬은 위와 같다. 원래 `sort()`는 오름차순이므로, 내림차순으로 정렬하도록 별도로 수식을 지정해야한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 실패율 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.11 Sat 02:20:18\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param N: [int] 전체 스테이지 갯수\r\n\t * @param stages: [int[]] 현재 스테이지 번호\r\n\t *\r\n\t * @return [int[]] 실패율이 높은 스테이지\r\n\t */\r\n\tpublic int[] solution(int N, int[] stages)\r\n\t{\r\n\t\tint[] fails = new int[N];\r\n\t\tint[] users = new int[N];\r\n\t\t\r\n\t\t// 시도자, 실패자 카운트\r\n\t\tfor (int stage : stages)\r\n\t\t{\r\n\t\t\t// 마지막 스테이지를 깨지 않았을 경우\r\n\t\t\tif (stage != N + 1)\r\n\t\t\t{\r\n\t\t\t\t// 실패한 유저 카운트\r\n\t\t\t\tfails[stage - 1]++;\r\n\t\t\t\t\r\n\t\t\t\t// 시도한 유저 카운트\r\n\t\t\t\tfor (int i = 0; i < stage; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 스테이지를 깼을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 시도한 유저 전부 카운트\r\n\t\t\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 실패율\r\n\t\tArrayList<Double[]> failRate = new ArrayList<>();\r\n\t\t\r\n\t\t// 실패율에 인덱스와 값 할당\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\t\t\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\t\t\r\n\t\t\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬\r\n\t\tfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n\t\t\r\n\t\treturn failRate.stream().mapToInt(value -> value[0].intValue()).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0018","2021","12","15","programmers-a0018"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 폰켓몬 (1845)","excerpt":"당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T02:01:09+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0017.md","content":"\r\n# 폰켓몬\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [폰켓몬](https://programmers.co.kr/learn/courses/30/lessons/1845)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.\r\n홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.\r\n\r\n1. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택\r\n2. 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택\r\n3. 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택\r\n4. 두 번째(1번), 세 번째(2번) 폰켓몬을 선택\r\n5. 두 번째(1번), 네 번째(3번) 폰켓몬을 선택\r\n6. 세 번째(2번), 네 번째(3번) 폰켓몬을 선택\r\n\r\n이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.\r\n\r\n당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 `nums`가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `nums`는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.\r\n* `nums`의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.\r\n* 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.\r\n* 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         nums         | result |\r\n| :------------------: | :----: |\r\n|    { 3, 1, 2, 3 }    |   2    |\r\n| { 3, 3, 3, 2, 2, 4 } |   3    |\r\n| { 3, 3, 3, 2, 2, 2 } |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\r\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.\r\n\r\n**입출력 예 #3**\r\n\r\n6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\r\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\nN개의 폰켓몬 중 그 절반인 N / 2개의 폰켓몬을 가져갈 수 있다. N개 중 N / 2의 폰켓몬을 고르는 경우의 수 중에서 가장 많은 종류의 폰켓몬을 선택했을 때, 폰켓몬 종류 갯수를 요구하는 알고리즘이다.\r\n\r\n얼핏 보면 복잡해보일 수 있으나, 조금만 생각해보면 매우 간단하게 풀 수 있는 문제다.\r\n\r\n서로 다른 종류의 폰켓몬 N개가 있을 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 N / 2다.\r\n\r\n반면, N개의 폰켓몬이 있고, 종류는 고작 두가지일 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 2가 한계다.\r\n\r\n즉, 폰켓몬 배열 `nums`에서 폰켓몬의 종류와 `nums.length / 2` 중 더 작은 값을 반환하면 된다.\r\n\r\n* [1, 2, 3, 4, 5, 1] - 종류는 5개, N / 2는 3이므로, 가져갈 수 있는 최대 종류는 3개\r\n* [1, 1, 1, 1, 2, 2, 3, 3] - 종류는 3개, N / 2는 4이므로, 가져갈 수 있는 최대 종류는 3개\r\n\r\n폰켓몬의 종류를 구하기 위해 고유값만을 저장하는 `HashSet`을 활용하는 것이 적절해보인다.\r\n\r\n`HashSet`에 폰켓몬을 삽입하여 종류의 갯수를 얻어내고, 배열의 길이 / 2와 비교하여 더 작은 값을 반환하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 폰켓몬 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.11 Sat 01:56:08\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param nums: [int[]] 폰켓몬 종류 배열\r\n\t *\r\n\t * @return [int] 폰켓몬 종류 갯수\r\n\t */\r\n\tpublic int solution(int[] nums)\r\n\t{\r\n\t\tHashSet<Integer> set = new HashSet<>();\r\n\t\t\r\n\t\tfor (int num : nums)\r\n\t\t{\r\n\t\t\tset.add(num);\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.min(set.size(), nums.length / 2);\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0017","2021","12","15","programmers-a0017"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 이름이 없는 동물의 아이디 (59039)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:44:37+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0016.md","content":"\r\n# 이름이 없는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 없는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59039)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A368930  |     Dog     | 2014-06-08 13:20:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A368930  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `NAME`이 null인 데이터를 `ANIMAL_ID` 순으로 조회한다. 해당 데이터 중 `ANIMAL_ID`만을 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0016","2021","12","15","programmers-a0016"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 최댓값 구하기 (59415)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:41:43+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0015.md","content":"\r\n# 최댓값 구하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [최댓값 구하기](https://programmers.co.kr/learn/courses/30/lessons/59415)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A399552  |     Dog     | 2013-10-14 15:38:00 |      Normal      |   Jack   |  Neutered Male  |\r\n|  A379998  |     Dog     | 2013-10-23 11:42:00 |      Normal      | Disciple |   Intact Male   |\r\n|  A370852  |     Dog     | 2013-11-03 15:04:00 |      Normal      |  Katie   |  Spayed Female  |\r\n|  A403564  |     Dog     | 2013-11-18 17:03:00 |      Normal      |   Anna   |  Spayed Female  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n|        시간         |\r\n| :-----------------: |\r\n| 2013-11-18 17:03:00 |\r\n\r\n* 컬럼 이름(위 예제에서는 \"시간\")은 일치하지 않아도 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `DATETIME`이 가장 최근인 데이터 중 가장 상위의 데이터 하나만을 조회한다.\r\n\r\nMySQL에서 최상위 데이터 하나만 호출할 땐 `LIMIT 1`을 사용한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT DATETIME FROM ANIMAL_INS ORDER BY DATETIME DESC LIMIT 1;\r\n```","url":["2021-12-15-programmers-a0015","2021","12","15","programmers-a0015"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 모든 레코드 조회하기 (59034)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:38:22+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0014.md","content":"\r\n# 모든 레코드 조회하기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [모든 레코드 조회하기](https://programmers.co.kr/learn/courses/30/lessons/59034)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |  NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :----: | :-------------: |\r\n|  A349996  |     Cat     | 2018-01-22 14:32:00 |      Normal      | Sugar  |  Neutered Male  |\r\n|  A350276  |     Cat     | 2017-08-13 13:50:00 |      Normal      | Jewel  |  Spayed Female  |\r\n|  A350375  |     Cat     | 2017-03-06 15:01:00 |      Normal      |  Meo   |  Neutered Male  |\r\n|  A352555  |     Dog     | 2014-08-08 04:20:00 |      Normal      | Harley |  Spayed Female  |\r\n\r\n..이하 생략\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `ANIMAL_ID` 순으로 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT * FROM ANIMAL_INS ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0014","2021","12","15","programmers-a0014"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 체육복 (42862)","excerpt":"점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:18:41+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0013.md","content":"\r\n# 체육복\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\r\n\r\n전체 학생의 수 `n`, 체육복을 도난당한 학생들의 번호가 담긴 배열 `lost`, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 `reserve`가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 전체 학생의 수는 2명 이상 30명 이하입니다.\r\n* 체육복을 도난당한 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌의 체육복을 가져온 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\r\n* 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |   lost   |   reserve   | return |\r\n| :---: | :------: | :---------: | :----: |\r\n|   5   | { 2, 4 } | { 1, 3, 5 } |   5    |\r\n|   5   | { 2, 4 } |    { 3 }    |   4    |\r\n|   3   |  { 3 }   |    { 1 }    |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\r\n\r\n**예제 #2**\r\n\r\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n본인 체육복만 가지고 있는 학생, 여벌 체육복을 가진 학생, 체육복을 도난당한 학생 세 가지로 나뉜다. 이 중 체육복을 도난당한 학생은 여벌을 가진 학생으로부터 체육복을 빌릴 수는 있지만, 자신의 앞뒤 학생에게만 빌릴 수 있다는 제한이 있다. 즉, 여벌이 남아도 서로 앞뒤에 위치하지 않는다면 빌려줄 수 없다.\r\n\r\n`lost`와 `reserve`엔 학생 번호가 기록되어 있는데, 이 문제에서는 학생의 순서가 매우 중요하므로 반드시 정렬이 필요하다.\r\n\r\n`clothes` 배열을 선언하여 체육복의 갯수를 카운팅한다.\r\n\r\n``` java\r\n// 여벌 체육복을 가진 학생을 카운팅\r\nfor (int item : reserve)\r\n{\r\n\tclothes[item - 1]++;\r\n}\r\n\r\n// 체육복을 도난당한 학생을 카운팅\r\nfor (int item : lost)\r\n{\r\n\tclothes[item - 1]--;\r\n}\r\n```\r\n\r\n`for`문으로 체육복의 여부를 가감한다. 학생의 번호는 배열의 인덱스 + 1과 동일하게 다루면 된다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 체육복 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 23:38:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 전체 학생 수\r\n\t * @param lost: [int[]] 체육복을 도난당한 학생\r\n\t * @param reserve: [int[]] 체육복 여벌을 가진 학생\r\n\t *\r\n\t * @return [int] 체육 수업을 들을 수 있는 학생의 최대값\r\n\t */\r\n\tpublic int solution(int n, int[] lost, int[] reserve)\r\n\t{\r\n\t\tint[] clothes = new int[n];\r\n\t\t\r\n\t\t// 자신의 앞뒤 사람에게만 빌려줄 수 있으므로 학생 번호 순서가 중요함\r\n\t\tArrays.sort(lost);\r\n\t\tArrays.sort(reserve);\r\n\t\t\r\n\t\t// 여벌 체육복을 가진 학생을 카운팅\r\n\t\tfor (int item : reserve)\r\n\t\t{\r\n\t\t\tclothes[item - 1]++;\r\n\t\t}\r\n\t\t\r\n\t\t// 체육복을 도난당한 학생을 카운팅\r\n\t\tfor (int item : lost)\r\n\t\t{\r\n\t\t\tclothes[item - 1]--;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < clothes.length; i++)\r\n\t\t{\r\n\t\t\t// 도난당한 학생일 경우\r\n\t\t\tif (clothes[i] == -1)\r\n\t\t\t{\r\n\t\t\t\t// 첫 학생이 아니고, 앞 학생이 여벌을 가질 경우\r\n\t\t\t\tif (i != 0 && clothes[i - 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i - 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 마지막 학생이 아니고, 뒷 학생이 여벌을 가질 경우\r\n\t\t\t\telse if (i != clothes.length - 1 && clothes[i + 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i + 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Arrays.stream(clothes).filter(value -> value > -1).toArray().length;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0013","2021","12","14","programmers-a0013"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 모의고사 (42840)","excerpt":"수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ... 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ... 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ... 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:02:01+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0012.md","content":"\r\n# 모의고사\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\r\n\r\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r\n\r\n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r\n\r\n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r\n\r\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 `answers`가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 시험은 최대 10,000 문제로 구성되어있습니다.\r\n* 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\r\n* 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      answers      |   return    |\r\n| :---------------: | :---------: |\r\n| { 1, 2, 3, 4, 5 } |    { 1 }    |\r\n| { 1, 3, 2, 4, 2 } | { 1, 2, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n* 수포자 1은 모든 문제를 맞혔습니다.\r\n* 수포자 2는 모든 문제를 틀렸습니다.\r\n* 수포자 3은 모든 문제를 틀렸습니다.\r\n\r\n따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n* 모든 사람이 2문제씩을 맞췄습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n* 1번 수포자 패턴 - `[ 1, 2, 3, 4, 5 ]`\r\n* 2번 수포자 패턴 - `[ 2, 1, 2, 3, 2, 4, 2, 5 ]`\r\n* 3번 수포자 패턴 - `[ 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 ]`\r\n\r\n수포자마다 패턴도 다르고, 길이도 달라서 생각없이 접근할 순 없다. 각 패턴의 길이가 다르므로 인덱스 방식은 적절하지 않다. 패턴을 컨테이너 벨트처럼 순환시켜, 가장 앞 쪽의 숫자를 비교하는 것이 더 효과적일 것이다.\r\n\r\n이를 위해선 각 수포자별로 패턴을 순환시키는 로직이 필요하다. `[ 1, 2, 3, 4, 5 ]` -> `[ 2, 3, 4, 5, 1 ]` 자료구조 중 큐의 특성과 매우 유사하므로, 이 문제는 큐를 적극적으로 활용해볼 생각이다.\r\n\r\n각 패턴을 정의할 큐 `ONE`, `TWO`, `THREE`가 있으며, 아래와 같이 초기화를 수행한다.\r\n\r\n``` java\r\nprivate void initQueue()\r\n{\r\n\tONE.clear();\r\n\tTWO.clear();\r\n\tTHREE.clear();\r\n\t\r\n\tONE.add(1);\r\n\tONE.add(2);\r\n\tONE.add(3);\r\n\tONE.add(4);\r\n\tONE.add(5);\r\n\t\r\n\tTWO.add(2);\r\n\tTWO.add(1);\r\n\tTWO.add(2);\r\n\tTWO.add(3);\r\n\tTWO.add(2);\r\n\tTWO.add(4);\r\n\tTWO.add(2);\r\n\tTWO.add(5);\r\n\t\r\n\tTHREE.add(3);\r\n\tTHREE.add(3);\r\n\tTHREE.add(1);\r\n\tTHREE.add(1);\r\n\tTHREE.add(2);\r\n\tTHREE.add(2);\r\n\tTHREE.add(4);\r\n\tTHREE.add(4);\r\n\tTHREE.add(5);\r\n\tTHREE.add(5);\r\n}\r\n```\r\n\r\n패턴 순서대로 큐에 데이터를 집어넣는다. `poll()` 메서드를 통해 가장 앞에 위치한 데이터를 꺼낼 수 있다. `poll()`의 경우 데이터 호출과 동시에 데이터가 삭제된다.\r\n\r\n정답 비교 후, 사용한 데이터는 다시 큐에 집어넣는다. 이런 구조는 문제의 길이에 관계없이 각 수포자 별로 지속적인 순환이 가능할 것이다.\r\n\r\n``` java\r\nfor (int item : answers)\r\n{\r\n\tint one = Objects.requireNonNull(ONE.poll());\r\n\tint two = Objects.requireNonNull(TWO.poll());\r\n\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\r\n\tcounts[0] += item == one ? 1 : 0;\r\n\tcounts[1] += item == two ? 1 : 0;\r\n\tcounts[2] += item == three ? 1 : 0;\r\n\t\r\n\tONE.add(one);\r\n\tTWO.add(two);\r\n\tTHREE.add(three);\r\n}\r\n```\r\n\r\n정답 비교는 위와 같다. `Objects.requireNonNull`는 `poll()`이 `NullPointerException`을 유발할 가능성이 있으므로, 관련 경고를 제거하기 위한 조치다.\r\n\r\n각 수포자별 큐에서 패턴을 뽑고, 이를 문제의 정답과 비교하여 맞춘 경우 `counts` 배열에 카운팅한다.\r\n\r\n사용한 패턴은 `add` 메서드를 통해 큐에 다시 집어넣는 것을 확인할 수 있다.\r\n\r\n<br />\r\n\r\n점수를 모두 구했다면, 가장 고득점을 구하고, 고득점을 맞은 수포자를 반환하면 된다.\r\n\r\n`counts`에서 가장 큰 값을 구하면 아래와 같다.\r\n\r\n``` java\r\nint max = Arrays.stream(counts).max().getAsInt();\r\n```\r\n\r\n이후 `max`에 해당하는 점수를 받은 모든 인원을 탐색하여 배열로 나타내면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\nimport java.util.Objects;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 모의고사 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:43:26\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final Queue<Integer> ONE = new LinkedList<>();\r\n\tprivate static final Queue<Integer> TWO = new LinkedList<>();\r\n\tprivate static final Queue<Integer> THREE = new LinkedList<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param answers: [int[]] 최고 득점자\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] answers)\r\n\t{\r\n\t\tinitQueue();\r\n\t\t\r\n\t\tint[] counts = { 0, 0, 0 };\r\n\t\t\r\n\t\tfor (int item : answers)\r\n\t\t{\r\n\t\t\tint one = Objects.requireNonNull(ONE.poll());\r\n\t\t\tint two = Objects.requireNonNull(TWO.poll());\r\n\t\t\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\t\t\r\n\t\t\tcounts[0] += item == one ? 1 : 0;\r\n\t\t\tcounts[1] += item == two ? 1 : 0;\r\n\t\t\tcounts[2] += item == three ? 1 : 0;\r\n\t\t\t\r\n\t\t\tONE.add(one);\r\n\t\t\tTWO.add(two);\r\n\t\t\tTHREE.add(three);\r\n\t\t}\r\n\t\t\r\n\t\tint max = Arrays.stream(counts).max().getAsInt();\r\n\t\t\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int i = 0; i < counts.length; i++)\r\n\t\t{\r\n\t\t\t// 최고 점수를 얻었을 경우\r\n\t\t\tif (counts[i] == max)\r\n\t\t\t{\r\n\t\t\t\tlist.add(i + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 큐 초기화 메서드\r\n\t */\r\n\tprivate void initQueue()\r\n\t{\r\n\t\tONE.clear();\r\n\t\tTWO.clear();\r\n\t\tTHREE.clear();\r\n\t\t\r\n\t\tONE.add(1);\r\n\t\tONE.add(2);\r\n\t\tONE.add(3);\r\n\t\tONE.add(4);\r\n\t\tONE.add(5);\r\n\t\t\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(1);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(3);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(4);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(5);\r\n\t\t\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(5);\r\n\t\tTHREE.add(5);\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0012","2021","12","14","programmers-a0012"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 완주하지 못한 선수 (42576)","excerpt":"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T20:33:25+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0010.md","content":"\r\n# 완주하지 못한 선수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\r\n\r\n마라톤에 참여한 선수들의 이름이 담긴 배열 `participant`와 완주한 선수들의 이름이 담긴 배열 `completion`이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\r\n* `completion`의 길이는 `participant`의 길이보다 1 작습니다.\r\n* 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\r\n* 참가자 중에는 동명이인이 있을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                     participant                     |                 completion                 |  return  |\r\n| :-------------------------------------------------: | :----------------------------------------: | :------: |\r\n|              { \"leo\", \"kiki\", \"eden\" }              |             { \"eden\", \"kiki\" }             |  \"leo\"   |\r\n| { \"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\" } | { \"josipa\", \"filipa\", \"marina\", \"nikola\" } | \"vinko\"  |\r\n|       { \"mislav\", \"stanko\", \"mislav\", \"ana\" }       |       { \"stanko\", \"ana\", \"mislav\" }        | \"mislav\" |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #2**\r\n\r\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #3**\r\n\r\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n마라톤 경기에서 완주하지 못한 선수를 구하는 문제. 완주자 `completion`은 참가자 `participant` 보다 반드시 길이가 1 짧다. 즉, 완주자는 무조건 한 명이라는 뜻이다.\r\n\r\n또한 동명이인이 있을 수 있으므로, `HashSet`과 같이 고유값을 저장하는 형식은 적절하지 못하다.\r\n\r\n완주하지 못 한 사람이 한 명이므로, 완주한 사람의 이름과 횟수를 `HashMap`에 카운팅하면 완주한 사람은 물론, 동명이인도 커버할 수 있을 것이다.\r\n\r\n``` java\r\nHashMap<String, Integer> map = new HashMap<>();\r\n\r\nfor (String name : participant)\r\n{\r\n\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n}\r\n\r\nfor (String name : completion)\r\n{\r\n\tmap.put(name, map.get(name) - 1);\r\n}\r\n```\r\n\r\n`String`을 키로, `Integer`를 값으로 받는 `HashMap`을 선언한다. `participant` 요소를 탐색하면서 참가자 이름을 키로 하여 값을 1씩 증가시킨다.\r\n\r\n기본적으로 참가자들은 값 1을 가지지만, nikola라는 동명이인이 있다면, `map`의 nikola는 값 2를 가지게 된다.\r\n\r\n이후 `completion` 요소를 탐색하면서 완주자 이름을 키로 하여 값을 1씩 감소시킨다. 이 과정에서 완주하지 못한 사람은 값이 감소되지 않아 1을 가지게 된다.\r\n\r\n`map`을 탐색하며 값이 1인 키를 찾아 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 완주하지 못한 선수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:13:57\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param participant: [String[]] 참여한 선수\r\n\t * @param completion: [String[]] 완주한 선수\r\n\t *\r\n\t * @return [String] 완주하지 못한 선수 이름\r\n\t */\r\n\tpublic String solution(String[] participant, String[] completion)\r\n\t{\r\n\t\tString answer = \"\";\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\tfor (String name : participant)\r\n\t\t{\r\n\t\t\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : completion)\r\n\t\t{\r\n\t\t\tmap.put(name, map.get(name) - 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String key : map.keySet())\r\n\t\t{\r\n\t\t\t// 값이 하나 이상 있을 경우\r\n\t\t\tif (map.get(key) > 0)\r\n\t\t\t{\r\n\t\t\t\tanswer = key;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0010","2021","12","14","programmers-a0010"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 소수 만들기 (12977)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T19:06:57+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0009.md","content":"\r\n# 소수 만들기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [소수 만들기](https://programmers.co.kr/learn/courses/30/lessons/12977)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 `nums`가 매개변수로 주어질 때, `nums`에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `nums`에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.\r\n* `nums`의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       nums        | result |\r\n| :---------------: | :----: |\r\n|  { 1, 2, 3, 4 }   |   1    |\r\n| { 1, 2, 7, 6, 4 } |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n[1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n[1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n\r\n[1,4,6]을 이용해서 11을 만들 수 있습니다.\r\n\r\n[2,4,7]을 이용해서 13을 만들 수 있습니다.\r\n\r\n[4,6,7]을 이용해서 17을 만들 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n배열에서 임의의 요소 3가지를 선택하여 해당 수의 합이 소수가 되는 경우의 수를 구하는 문제.\r\n\r\n1. 임의의 요소 3가지 선택\r\n2. 요소의 합의 소수 여부 판별\r\n\r\n이 두 로직을 구현하는 것이 알고리즘의 핵심이다.\r\n\r\n보통 조합을 이용하지만, 간단하게 중첩 `for`문을 사용해 구현해보자.\r\n\r\n``` java\r\nfor (int i = 0; i < nums.length; i++)\r\n{\r\n\tfor (int j = i + 1; j < nums.length; j++)\r\n\t{\r\n\t\tfor (int k = j + 1; k < nums.length; k++)\r\n\t\t{\r\n\t\t\tint sum = nums[i] + nums[j] + nums[k];\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n임의의 세 가지 요소는 이와 같이 3중첩 `for`문을 통해 구할 수 있다. `j`, `k`의 인덱스를 유심히 살펴보자. 각 인덱스가 겹치지 않게끔 초기값이 구성되어있다.\r\n\r\n``` java\r\nprivate boolean isPrime(int num)\r\n{\r\n\tfor (int i = 2; i <= Math.sqrt(num); i++)\r\n\t{\r\n\t\t// 나눠 떨어질 경우\r\n\t\tif (num % i == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n```\r\n\r\n소수는 이와 같이 구할 수 있다. 굳이 `Math.sqrt(num)` 까지만 연산히는 이유는, 제곱근 이후로는 연산할 필요가 없다.\r\n\r\n예를 들어, 12의 경우 `1, 2, 3, 4, 6, 12`의 약수를 가지는데, $\\sqrt{12}$는 대략 3이다. 3 이후의 숫자인 4, 6은 각각 2와 3과 곱해져서 12를 만들게 되므로, 제곱근 이전에 나누어 떨어지는 수가 없다면 그 수는 소수라 봐도 무방하다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 소수 만들기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:21:09\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param nums: [int[]] 숫자 배열\r\n\t *\r\n\t * @return [int] 소수가 되는 경우의 수\r\n\t */\r\n\tpublic int solution(int[] nums)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < nums.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = i + 1; j < nums.length; j++)\r\n\t\t\t{\r\n\t\t\t\tfor (int k = j + 1; k < nums.length; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[k];\r\n\t\t\t\t\t\r\n\t\t\t\t\tanswer += isPrime(sum) ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 메서드\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i <= Math.sqrt(num); i++)\r\n\t\t{\r\n\t\t\t// 나눠 떨어질 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0009","2021","12","14","programmers-a0009"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 음양 더하기 (76501)","excerpt":"어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T17:01:15+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0007.md","content":"\r\n# 음양 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [음양 더하기](https://programmers.co.kr/learn/courses/30/lessons/76501)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 `absolutes`와 이 정수들의 부호를 차례대로 담은 불리언 배열 `signs`가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `absolutes`의 길이는 1 이상 1,000 이하입니다.\r\n  * `absolutes`의 모든 수는 각각 1 이상 1,000 이하입니다.\r\n* `signs`의 길이는 `absolutes`의 길이와 같습니다.\r\n  * `signs[i]` 가 참이면 `absolutes[i]` 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  absolutes   |         signs          | result |\r\n| :----------: | :--------------------: | :----: |\r\n| { 4, 7, 12 } | { true, false, true }  |   9    |\r\n| { 1, 2, 3 }  | { false, false, true } |   0    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`signs`가 { true, false, true } 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.\r\n\r\n따라서 세 수의 합인 9를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`signs`가 { false, false, true } 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.\r\n\r\n따라서 세 수의 합인 0을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`absolutes`는 수의 절대값을, `signs`은 수의 부호를 가진다. 인덱스별로 각 요소를 호출하여 `signs`의 값에 따라 `absolutes`를 가감하면 될 것이다.\r\n\r\n`absolutes`와 `signs` 크기는 동일하므로, 어떤 배열을 인덱스로 삼든 상관 없다.\r\n\r\n``` java\r\nfor (int i = 0; i < absolutes.length; i++)\r\n{\r\n\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n}\r\n```\r\n\r\n`signs[i]`의 값에 따라 `absolutes`를 가감하여 `answer`에 누적시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 음양 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:09:32\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param absolutes: [int[]] 정수 절대값 배열\r\n\t * @param signs: [boolean[]] 정수의 부호\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] absolutes, boolean[] signs)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < absolutes.length; i++)\r\n\t\t{\r\n\t\t\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0007","2021","12","14","programmers-a0007"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 K번째수 (42748)","excerpt":"배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0011.md","content":"\r\n# K번째수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n배열 `array`의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\r\n\r\n예를 들어 `array`가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\r\n\r\n1. `array`의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\r\n2. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\r\n3. 2에서 나온 배열의 3번째 숫자는 5입니다.\r\n\r\n배열 `array`, [i, j, k]를 원소로 가진 2차원 배열 `commands`가 매개변수로 주어질 때, `commands`의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `array`의 길이는 1 이상 100 이하입니다.\r\n* `array`의 각 원소는 1 이상 100 이하입니다.\r\n* `commands`의 길이는 1 이상 50 이하입니다.\r\n* `commands`의 각 원소는 길이가 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          array          |                 commands                  |   return    |\r\n| :---------------------: | :---------------------------------------: | :---------: |\r\n| { 1, 5, 2, 6, 3, 7, 4 } | { { 2, 5, 3 }, { 4, 4, 1 }, { 1, 7, 3 } } | { 5, 6, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. `commands` 요소별로 `i`, `j`, `k`를 구한다.\r\n2. `i`에서 `j`까지 `array`를 자른다.\r\n3. 자른 배열을 정렬한다.\r\n4. 자른 배열의 `k`번 째 요소를 찾는다.\r\n\r\n알고리즘 수행 과정은 위와 같을 것이다.\r\n\r\n``` java\r\nfor (int n = 0; n < answer.length; n++)\r\n{\r\n\tint i = commands[n][0];\r\n\tint j = commands[n][1];\r\n\tint k = commands[n][2];\r\n\t\r\n\tint length = j - i + 1;\r\n\t\r\n\tint[] temp = new int[length];\r\n\t\r\n\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\r\n\tArrays.sort(temp);\r\n\t\r\n\tanswer[n] = temp[--k];\r\n}\r\n```\r\n\r\n`i`, `j`, `k`를 구하고, `i`와 `j` 사이의 거리를 구한다. 해당 길이만큼의 배열을 선언하여 자를 것이다.\r\n\r\n`System.arraycopy()` 메서드를 활용하여 `temp` 배열로 `array`의 원하는 부분만을 잘라서 할당하는 것이 가능하다.\r\n\r\n이후 정렬을 수행하고, `k`번 째 요소를 찾으면 된다. 배열은 0부터 시작하므로 실제 인덱스는 `k - 1`이 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * K번째수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:28:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t * @param commands: [int[][]] 인덱스 배열\r\n\t *\r\n\t * @return [int[]] k번째의 수\r\n\t */\r\n\tpublic int[] solution(int[] array, int[][] commands)\r\n\t{\r\n\t\tint[] answer = new int[commands.length];\r\n\t\t\r\n\t\tfor (int n = 0; n < answer.length; n++)\r\n\t\t{\r\n\t\t\tint i = commands[n][0];\r\n\t\t\tint j = commands[n][1];\r\n\t\t\tint k = commands[n][2];\r\n\t\t\t\r\n\t\t\tint length = j - i + 1;\r\n\t\t\t\r\n\t\t\tint[] temp = new int[length];\r\n\t\t\t\r\n\t\t\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\t\t\r\n\t\t\tArrays.sort(temp);\r\n\t\t\t\r\n\t\t\tanswer[n] = temp[--k];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0011","2021","12","14","programmers-a0011"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 내적 (70128)","excerpt":"길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1] 입니다. (n은 a, b의 길이)","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0008.md","content":"\r\n# 내적\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [내적](https://programmers.co.kr/learn/courses/30/lessons/70128)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n길이가 같은 두 1차원 정수 배열 `a`, `b`가 매개변수로 주어집니다. `a`와 `b`의 내적을 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n이때, `a`와 `b`의 내적은 `a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1]` 입니다. (`n`은 `a`, `b`의 길이)\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `a`, `b`의 길이는 1 이상 1,000 이하입니다.\r\n* `a`, `b`의 모든 수는 -1,000 이상 1,000 이하입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       a        |        b         | result |\r\n| :------------: | :--------------: | :----: |\r\n| { 1, 2, 3, 4 } | { -3, -1, 0, 2 } |   3    |\r\n|  { -1, 0, 1 }  |   { 1, 0, -1 }   |   -2   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`a`와 `b`의 내적은 `1 * (-3) + 2 * (-1) + 3 * 0 + 4 * 2 = 3`입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`a`와 `b`의 내적은 `(-1) * 1 + 0 * 0 + 1 * (-1) = -2`입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n인덱스를 돌면서 `a`, `b` 요소를 곱한뒤 값을 누적시키면 될 것이다. `a`, `b`의 길이가 동일하므로 아무 배열이나 인덱스로 삼아도 된다.\r\n\r\n``` java\r\nfor (int i = 0; i < a.length; i++)\r\n{\r\n\tanswer += a[i] * b[i];\r\n}\r\n```\r\n\r\n위와 같이 각 요소별로 곱한 값을 `answer`에 누적한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 내적 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:17:10\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int[]] 정수 배열\r\n\t * @param b: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] a, int[] b)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t{\r\n\t\t\tanswer += a[i] * b[i];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0008","2021","12","14","programmers-a0008"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 없는 숫자 더하기 (86051)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0006.md","content":"\r\n# 없는 숫자 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [없는 숫자 더하기](https://programmers.co.kr/learn/courses/30/lessons/86051)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n0부터 9까지의 숫자 중 일부가 들어있는 배열 `numbers`가 매개변수로 주어집니다. `numbers`에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `numbers`의 길이 ≤ 9\r\n* 0 ≤ `numbers`의 모든 수 ≤ 9\r\n* `numbers`의 모든 수는 서로 다릅니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          numbers           | result |\r\n| :------------------------: | :----: |\r\n| { 1, 2, 3, 4, 6, 7, 8, 0 } |   14   |\r\n|  { 5, 8, 4, 0, 6, 7, 9 }   |   6    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n5, 9가 `numbers`에 없으므로, 5 + 9 = 14를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n1, 2, 3이 `numbers`에 없으므로, 1 + 2 + 3 = 6을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n0 ~ 9의 숫자가 중복되지 않게 포함된 배열이 있다. 우리는 이 배열에 포함되지 않는 수들의 합을 구하는 것이 목적이다.\r\n\r\n숫자도 한 자리로 제한되어있고, 중복도 없으므로 매우 간단하게 풀 수 있다.\r\n\r\n0 ~ 9의 총 합은 45다. 45에서 `numbers`의 값들을 전부 빼주면 포함되지 않는 수들의 합을 쉽게 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 없는 숫자 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:04:47\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 숫자 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] numbers)\r\n\t{\r\n\t\tint answer = 45;\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\tanswer -= number;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0006","2021","12","14","programmers-a0006"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 크레인 인형뽑기 게임 (64061)","excerpt":"게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. \"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0005.md","content":"\r\n# 크레인 인형뽑기 게임\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [크레인 인형뽑기 게임](https://programmers.co.kr/learn/courses/30/lessons/64061)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\r\n\"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png)\r\n\r\n게임 화면은 \"1 x 1\" 크기의 칸들로 이루어진 \"N x N\" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 \"5 x 5\" 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 \"1 x 1\" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png)\r\n\r\n만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif)\r\n\r\n크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\r\n\r\n게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 `moves`가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `board` 배열은 2차원 배열로 크기는 \"5 x 5\" 이상 \"30 x 30\" 이하입니다.\r\n* `board`의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.\r\n  * 0은 빈 칸을 나타냅니다.\r\n  * 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.\r\n* `moves` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `moves` 배열 각 원소들의 값은 1 이상이며 `board` 배열의 가로 크기 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                                               board                                               |           moves            | result |\r\n| :-----------------------------------------------------------------------------------------------: | :------------------------: | :----: |\r\n| { { 0, 0, 0, 0, 0 }, { 0, 0, 1, 0, 3 }, { 0, 2, 5, 0, 1 }, { 4, 2, 4, 4, 2 }, { 3, 5, 1, 3, 1 } } | { 1, 5, 3, 5, 1, 2, 1, 4 } |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/bb0f59c7-6b72-485a-8302-217fe53ea88f/crane_game_104.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. 인형을 뽑는다. 만약 해당 위치에 인형이 없다면 아무것도 뽑지 않는다.\r\n2. 뽑은 인형을 바구니에 담는다.\r\n3. 방금 뽑은 인형과 마지막으로 뽑았던 인형이 동일하면 삭제한다.\r\n4. 삭제한 인형 갯수를 카운팅한다. (삭제 작업 당 +2)\r\n\r\n삭제 횟수가 아니라 삭제한 인형의 갯수다. 2개씩 삭제됨에 유의.\r\n\r\n크레인을 움직이면서 인형을 하나씩 담는다. 이를 담을 배열이 필요하며, `ArrayList` 같은 가변 배열이 적절해보인다. 가장 최근에 들어온 데이터로 연산하므로, `Stack`의 특성을 적극 활용하고자 한다.\r\n\r\n``` java\r\nfor (int move : moves)\r\n{\r\n\tint j = move - 1;\r\n\t\r\n\tfor (int i = 0; i < board.length; i++)\r\n\t{\r\n\t\t// 인형을 뽑을 경우\r\n\t\tif (board[i][j] > 0)\r\n\t\t{\r\n\t\t\t// 동작\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n인형을 뽑는 동작은 위와 같다. 열 `j`를 기준으로 한 행씩 내려오면서 `board[i][j] > 0`인지 확인한다.\r\n\r\n해당 인형은 `board`에서 제거하고 인형을 스택에 넣는다. 이 때, 스택의 마지막 인형과 뽑은 인형이 같을 경우, 스택의 마지막 인형을 제거하고 삭제한 인형 카운트를 추가한다.\r\n\r\n인형이 서로 다르다면, 삭제하지 않고 인형만 스택에 넣는다.\r\n\r\n<br />\r\n\r\n문제를 보다보면 *\"인형을 일단 다 뽑고 삭제는 마지막에 한꺼번에 하면 되지 않을까?\"*라고 생각하기 쉽지만, 실제로 이렇게 접근하면 더 어렵다.\r\n\r\n나중에 한꺼번에 삭제하게 되면, 인형을 삭제하는 순간 다른 인형이 연결될 가능성이 생기므로, 연결된 인형이 없을 때까지 반복적인 연산이 필요하다.\r\n\r\n예를 들어, `1 3 2 2 3`의 경우 동일하게 붙은 인형인 `2`를 삭제하면 `1 3 3`이 된다. `2`가 삭제되며 `3`이 붙어버리므로 반복적인 연산이 강제된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 크레인 인형뽑기 게임 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 21:40:58\r\n */\r\nclass Solution\r\n{\r\n\tprivate final Stack<Integer> bag = new Stack<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param board: [int[][]] 보드 크기\r\n\t * @param moves: [int[]] 크레인 작동 위치\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[][] board, int[] moves)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int move : moves)\r\n\t\t{\r\n\t\t\tint j = move - 1;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < board.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 인형을 뽑을 경우\r\n\t\t\t\tif (board[i][j] > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 뽑은 인형이 있고, 마지막 인형과 방금 뽑은 인형이 동일할 경우\r\n\t\t\t\t\tif (!bag.isEmpty() && bag.peek() == board[i][j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.pop();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tanswer += 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 아닐 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.push(board[i][j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tboard[i][j] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0005","2021","12","14","programmers-a0005"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 키패드 누르기 (67256)","excerpt":"스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다. 맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T12:46:59+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0004.md","content":"\r\n# 키패드 누르기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [키패드 누르기](https://programmers.co.kr/learn/courses/30/lessons/67256)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)\r\n\r\n이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\r\n맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\r\n\r\n1. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.\r\n2. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.\r\n3. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.\r\n4. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\r\n\t* 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\r\n\r\n순서대로 누를 번호가 담긴 배열 `numbers`, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 `hand`가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `numbers` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `numbers` 배열 원소의 값은 0 이상 9 이하인 정수입니다.\r\n* `hand`는 \"left\" 또는 \"right\" 입니다.\r\n  * \"left\"는 왼손잡이, \"right\"는 오른손잡이를 의미합니다.\r\n* 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|              numbers              |  hand   |    result     |\r\n| :-------------------------------: | :-----: | :-----------: |\r\n| [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] | \"right\" | \"LRLLLRLLRRL\" |\r\n| [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] | \"left\"  | \"LRLLRRLLLRR\" |\r\n|  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]   | \"right\" | \"LLRLLRLLRL\"  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.\r\n\r\n| 왼손 위치 | 오른손 위치 | 눌러야 할 숫자 | 사용한 손 | 설명                                                             |\r\n| :-------: | :---------: | :------------: | :-------: | :--------------------------------------------------------------- |\r\n|     *     |      #      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      #      |       3        |     R     | 3은 오른손으로 누릅니다.                                         |\r\n|     1     |      3      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      3      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      3      |       8        |     L     | 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.      |\r\n|     8     |      3      |       2        |     R     | 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.    |\r\n|     8     |      2      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      2      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      2      |       5        |     R     | 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. |\r\n|     4     |      5      |       9        |     R     | 9는 오른손으로 누릅니다.                                         |\r\n|     4     |      9      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      9      |       -        |     -     |                                                                  |\r\n\r\n따라서 `LRLLLRLLRRL`를 return 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 `LRLLRRLLLRR`이 됩니다.\r\n\r\n**입출력 예 #3**\r\n\r\n오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 `LLRLLRLLRL`이 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1, 4, 7은 왼손, 3, 6, 9는 오른손을 쓰면 되므로 큰 문제는 없지만, 2, 5, 8, 0은 누르려는 숫자와 가장 가까이 위치한 손을 써야한다.\r\n\r\n즉, 번호를 누를 때마다 왼손과 오른손의 위치를 기록하고, 2, 5, 8, 0 중 숫자가 나올 경우, 기록했던 각 손의 위치와 해당 숫자의 거리를 비교하여 계산한다.\r\n\r\n키패드를 구현하기 위해 2차원 배열을 구성한다.\r\n\r\n``` java\r\nprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t{ 1, 2, 3 },\r\n\t\t{ 4, 5, 6 },\r\n\t\t{ 7, 8, 9 },\r\n\t\t{ -2, 0, -1 }\r\n};\r\n\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n```\r\n\r\n키패드의 특수문자 `*`과 `#`은 각각 `-2`, `-1`로 다룬다.\r\n\r\n조건에 초기 각 손의 위치는 왼손 `*`, 오른손 `#`이므로, 초기 위치 또한 `-2`, `-1`로 지정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n키패드의 위치를 계산할 수 있도록 메서드를 구성한다.\r\n\r\n``` java\r\nprivate int[] getPosition(int number)\r\n{\r\n\tint[] pos = new int[] { 0, 0 };\r\n\t\r\n\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t{\r\n\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t{\r\n\t\t\t\tpos[0] = i;\r\n\t\t\t\tpos[1] = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn pos;\r\n}\r\n```\r\n\r\n이중 배열을 탐색하여 입력한 키패드의 번호 `number`와 동일한 값을 가지는 배열의 인덱스를 반환한다.\r\n\r\n예를 들어, 키패드 5의 경우 `(1, 1)`의 위치를 가지며, 키패드 7의 경우 `(2, 0)`의 위치를 가진다.\r\n\r\n키패드 5와 7의 거리는 `|1 - 2| + |1 - 0| = 2`가 됨을 알 수 있다.\r\n\r\n``` java\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n\r\nint[] lPos = getPosition(left);\r\nint[] rPos = getPosition(right);\r\nint[] toPos = getPosition(number);\r\n\r\nint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\nint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\r\n// 왼쪽 엄지가 더 가까울 경우\r\nif (lLength > rLength)\r\n{\r\n\t// 왼손 이동\r\n}\r\n\r\n// 오른쪽 엄지가 더 가까울 경우\r\nelse if (lLength < rLength)\r\n{\r\n\t// 오른손 이동\r\n}\r\n\r\n// 둘 다 동일할 경우\r\nelse\r\n{\r\n\t// 왼손잡이일 경우\r\n\tif (hand.equals(\"left\"))\r\n\t{\r\n\t\t// 왼손 이동\r\n\t}\r\n\t\r\n\t// 오른손잡이일 경우\r\n\telse\r\n\t{\r\n\t\t// 오른손 이동\r\n\t}\r\n}\r\n```\r\n\r\n만약 2, 5, 8, 0 중 하나에 해당하는 키패드가 입력되었을 경우, 위와 같이 구현할 수 있다.\r\n\r\n`lPos`, `rPos`는 왼손, 오른손의 위치이며, `toPos`는 이동해야할 키패드의 위치다.\r\n\r\n이를 통해 각 손과 키패드의 거리인 `lLength`, `rLength`를 계산하여 이를 비교하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 키패드 누르기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 18:58:49\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t\t{ 1, 2, 3 },\r\n\t\t\t{ 4, 5, 6 },\r\n\t\t\t{ 7, 8, 9 },\r\n\t\t\t{ -2, 0, -1 }\r\n\t};\r\n\t\r\n\tprivate int left = -2;\r\n\tprivate int right = -1;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 순서대로 누를 번호\r\n\t * @param hand: [String] 주 손잡이 (left, right)\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int[] numbers, String hand)\r\n\t{\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\t// 왼쪽 번호일 경우\r\n\t\t\tif (number == 1 || number == 4 || number == 7)\r\n\t\t\t{\r\n\t\t\t\tleft = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 오른쪽 번호일 경우\r\n\t\t\telse if (number == 3 || number == 6 || number == 9)\r\n\t\t\t{\r\n\t\t\t\tright = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가운데 번호일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint[] lPos = getPosition(left);\r\n\t\t\t\tint[] rPos = getPosition(right);\r\n\t\t\t\tint[] toPos = getPosition(number);\r\n\t\t\t\t\r\n\t\t\t\tint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\n\t\t\t\tint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\t\t\t\t\r\n\t\t\t\t// 왼쪽 엄지가 더 가까울 경우\r\n\t\t\t\tif (lLength > rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tright = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 오른쪽 엄지가 더 가까울 경우\r\n\t\t\t\telse if (lLength < rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 둘 다 동일할 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// 왼손잡이일 경우\r\n\t\t\t\t\tif (hand.equals(\"left\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 오른손잡이일 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위치 반환 메서드\r\n\t *\r\n\t * @param number: [int] 키\r\n\t *\r\n\t * @return [int[]] 위치\r\n\t */\r\n\tprivate int[] getPosition(int number)\r\n\t{\r\n\t\tint[] pos = new int[] { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t\t{\r\n\t\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t\t{\r\n\t\t\t\t\tpos[0] = i;\r\n\t\t\t\t\tpos[1] = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn pos;\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다.","url":["2021-12-14-programmers-a0004","2021","12","14","programmers-a0004"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 숫자 문자열과 영단어 (81301)","excerpt":"네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T11:21:04+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0003.md","content":"\r\n# 숫자 문자열과 영단어\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [숫자 문자열과 영단어](https://programmers.co.kr/learn/courses/30/lessons/81301)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)\r\n\r\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.\r\n\r\n다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\r\n\r\n* 1478 → `one4seveneight`\r\n* 234567 → `23four5six7`\r\n* 10203 → `1zerotwozero3`\r\n\r\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\r\n\r\n| 숫자  | 영단어 |\r\n| :---: | :----: |\r\n|   0   |  zero  |\r\n|   1   |  one   |\r\n|   2   |  two   |\r\n|   3   | three  |\r\n|   4   |  four  |\r\n|   5   |  five  |\r\n|   6   |  six   |\r\n|   7   | seven  |\r\n|   8   | eight  |\r\n|   9   |  nine  |\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `s`의 길이 ≤ 50\r\n* `s`가 `zero` 또는 `0`으로 시작하는 경우는 주어지지 않습니다.\r\n* return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         s          | result |\r\n| :----------------: | :----: |\r\n|  `one4seveneight`  |  1478  |\r\n|   `23four5six7`    | 234567 |\r\n| `2three45sixseven` | 234567 |\r\n|       `123`        |  123   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #3**\r\n\r\n\"three\"는 3, \"six\"는 6, \"seven\"은 7에 대응되기 때문에 정답은 **입출력 예 #2**와 같은 234567이 됩니다.\r\n\r\n**입출력 예 #2**와 **#3**과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\r\n\r\n**입출력 예 #4**\r\n\r\ns에는 영단어로 바뀐 부분이 없습니다.\r\n\r\n\r\n\r\n### 제한시간 안내\r\n\r\n* 정확성 테스트 : 10초\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자의 영소문자를 전부 숫자로 변경하여, 최종적으로 `int` 형태로 반환하는 알고리즘을 구현해야한다.\r\n\r\n1. 문자열의 텍스트를 전부 숫자로 치환한다.\r\n2. 숫자화된 문자열을 `int`로 형변환한다.\r\n\r\n위 두 과정을 거치면 된다. 여러 방법이 있지만, 이왕 JAVA 쓰는거, `enum` 객체를 활용하여 구현하고자 한다.\r\n\r\n비교적 쉬운 로직에 생소한 패턴을 적용해보는 것도 연습에 도움이 된다.\r\n\r\n``` java\r\nprivate enum Number\r\n{\r\n\tZERO(\"0\"),\r\n\tONE(\"1\"),\r\n\tTWO(\"2\"),\r\n\tTHREE(\"3\"),\r\n\tFOUR(\"4\"),\r\n\tFIVE(\"5\"),\r\n\tSIX(\"6\"),\r\n\tSEVEN(\"7\"),\r\n\tEIGHT(\"8\"),\r\n\tNINE(\"9\");\r\n\t\r\n\tprivate final String num;\r\n\t\r\n\tNumber(String num)\r\n\t{\r\n\t\tthis.num = num;\r\n\t}\r\n\t\r\n\tpublic String getNum()\r\n\t{\r\n\t\treturn num;\r\n\t}\r\n}\r\n```\r\n\r\n`enum`은 위와 같이 설계한다. `Number.ONE.name().toLowerCase()`를 활용하여 `one` 문자열을 얻을 수 있다. 또한 `Number.ONE.getNum()`를 활용하여 이에 `one`에 매칭되는 숫자 `1`을 얻을 수 있다. 이 두 메서드를 활용하여 문자열을 치환한다.\r\n\r\n``` java\r\nfor (Number number : Number.values())\r\n{\r\n\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n}\r\n```\r\n\r\n`Number.values()`로 `Number`의 모든 요소를 배열 형태로 반환받을 수 있다. `for`문을 통해 각 숫자의 영문자에 해당하는 문자를 이에 매칭되는 숫자로 치환한다. `replaceAll`을 활용하여 해당하는 모든 문자들을 치환할 수 있다.\r\n\r\n`int` 변환은 `Integer.parseInt()` 메서드를 활용하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 숫자 문자열과 영단어 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Thu 18:47:19\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\tString answer = s;\r\n\t\t\r\n\t\tfor (Number number : Number.values())\r\n\t\t{\r\n\t\t\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n\t\t}\r\n\t\t\r\n\t\treturn Integer.parseInt(answer);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 숫자 enum\r\n\t */\r\n\tprivate enum Number\r\n\t{\r\n\t\tZERO(\"0\"),\r\n\t\tONE(\"1\"),\r\n\t\tTWO(\"2\"),\r\n\t\tTHREE(\"3\"),\r\n\t\tFOUR(\"4\"),\r\n\t\tFIVE(\"5\"),\r\n\t\tSIX(\"6\"),\r\n\t\tSEVEN(\"7\"),\r\n\t\tEIGHT(\"8\"),\r\n\t\tNINE(\"9\");\r\n\t\t\r\n\t\tprivate final String num;\r\n\t\t\r\n\t\t/**\r\n\t\t * 생성자 메서드\r\n\t\t *\r\n\t\t * @param num: [String] 숫자\r\n\t\t */\r\n\t\tNumber(String num)\r\n\t\t{\r\n\t\t\tthis.num = num;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * 숫자 반환 메서드\r\n\t\t *\r\n\t\t * @return [String] 숫자\r\n\t\t */\r\n\t\tpublic String getNum()\r\n\t\t{\r\n\t\t\treturn num;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`enum`이 싫다면 `Map`이나 배열 같이 친숙한 형태로도 구현할 수 있다.\r\n\r\n예를 들어, `int nums[] = new int[] { \"zero\", \"one\" ... \"nine\" };`과 같은 코드는 배열의 인덱스와 그 값을 통해 동일한 로직을 구성할 수 있다.\r\n\r\n`nums[0] = \"zero\"`이므로, 인덱스와 값을 적절히 사용하여 치환하는 것도 가능하다.","url":["2021-12-14-programmers-a0003","2021","12","14","programmers-a0003"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 신규 아이디 추천 (72410)","excerpt":"카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:11:28+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0002.md","content":"\r\n# 신규 아이디 추천\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.\r\n다음은 카카오 아이디의 규칙입니다.\r\n\r\n* 아이디의 길이는 3자 이상 15자 이하여야 합니다.\r\n* 아이디는 알파벳 소문자, 숫자, 빼기(`-`), 밑줄(`_`), 마침표(`.`) 문자만 사용할 수 있습니다.\r\n* 단, 마침표(`.`)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\r\n\r\n\"네오\"는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\r\n\r\n신규 유저가 입력한 아이디가 `new_id` 라고 한다면,\r\n\r\n* 1단계 `new_id`의 모든 대문자를 대응되는 소문자로 치환합니다.\r\n* 2단계 `new_id`에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\r\n* 3단계 `new_id`에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\r\n* 4단계 `new_id`에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\r\n* 5단계 `new_id`가 빈 문자열이라면, `new_id`에 \"a\"를 대입합니다.\r\n* 6단계 `new_id`의 길이가 16자 이상이면, `new_id`의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.  \r\n  만약 제거 후 마침표(.)가 `new_id`의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\r\n* 7단계 `new_id`의 길이가 2자 이하라면, `new_id`의 마지막 문자를 `new_id`의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\r\n\r\n예를 들어, `new_id` 값이 `...!@BaT#*..y.abcdefghijklm` 라면, 위 7단계를 거치고 나면 `new_id`는 아래와 같이 변경됩니다.\r\n\r\n* 1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다.\r\n  * `...!@BaT#*..y.abcdefghijklm` → `...!@bat#*..y.abcdefghijklm`\r\n\r\n* 2단계 '!', '@', '#', '*' 문자가 제거되었습니다.\r\n  * `...!@bat#*..y.abcdefghijklm` → `...bat..y.abcdefghijklm`\r\n\r\n* 3단계 '...'와 '..' 가 '.'로 바뀌었습니다.\r\n  * `...bat..y.abcdefghijklm` → `.bat.y.abcdefghijklm`\r\n\r\n* 4단계 아이디의 처음에 위치한 '.'가 제거되었습니다.\r\n  * `.bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghi`\r\n\r\n* 7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghi` → `bat.y.abcdefghi`\r\n\r\n따라서 신규 유저가 입력한 `new_id`가 `...!@BaT#*..y.abcdefghijklm`일 때, 네오의 프로그램이 추천하는 새로운 아이디는 `bat.y.abcdefghi` 입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 문제\r\n\r\n신규 유저가 입력한 아이디를 나타내는 `new_id`가 매개변수로 주어질 때, \"네오\"가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n`new_id`는 길이 1 이상 1,000 이하인 문자열입니다.\r\n\r\n`new_id`는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\r\n\r\n`new_id`에 나타날 수 있는 특수문자는 `-_.~!@#$%^&*()=+[{]}:?,<>/` 로 한정됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  no   |            new_id             |      result       |\r\n| :---: | :---------------------------: | :---------------: |\r\n|  예1  | `...!@BaT#*..y.abcdefghijklm` | `bat.y.abcdefghi` |\r\n|  예2  |           `z-+.^.`            |       `z--`       |\r\n|  예3  |             `=.=`             |       `aaa`       |\r\n|  예4  |          `123_.def`           |    `123_.def`     |\r\n|  예5  |      `abcdefghijklmn.p`       | `abcdefghijklmn`  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `z-+.^.` → `z-..`\r\n\r\n3단계 `z-..` → `z-.`\r\n\r\n4단계 `z-.` → `z-`\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `z-` → `z--`\r\n\r\n\r\n**입출력 예 #3**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `=.=` → `.`\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 `.` → `new_id`가 빈 문자열이 되었습니다.\r\n\r\n5단계 ` ` → `a`\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `a` → `aaa`\r\n\r\n\r\n**입출력 예 #4**\r\n\r\n1단계에서 7단계까지 거치는 동안 `new_id`(\"123_.def\")는 변하지 않습니다. 즉, `new_id`가 처음부터 카카오의 아이디 규칙에 맞습니다.\r\n\r\n**입출력 예 #5**\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 변화 없습니다.\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 변화 없습니다.\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 `abcdefghijklmn.p` → `abcdefghijklmn.` → `abcdefghijklmn`\r\n\r\n7단계 변화 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문제에 각 단계별로 수행해야하는 로직이 제시되어 있으므로, 이를 메서드로 구분하여 설계하는 것이 적절해보인다.\r\n\r\n\r\n\r\n\r\n\r\n## 1단계 - 소문자 치환\r\n\r\n입력된 문자열을 소문자로 치환한다.\r\n\r\n``` java\r\nprivate String step1(String new_id)\r\n{\r\n\treturn new_id.toLowerCase();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 2단계 - 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\r\n특정 문자만을 남기고 제외한다. 문자열을 `char[]`로 만들어 `for`문을 통해 비교하여 제거할 수도 있겠지만, 정규식을 활용하면 그보다 더 쉽고 간편하게 구현할 수 있다.\r\n\r\n``` java\r\nprivate String step2(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n}\r\n```\r\n\r\n* `[^]` - `[]` 내부에서 `^`는 부정(NOT)의 의미로 사용됨\r\n* `[a-z]` - 소문자 알파벳\r\n* `[0-9]` - 숫자\r\n\r\n`replaceAll`은 정규식을 사용할 수 있다. 위 정규식을 통해 영소문자, 숫자, 일부 특수문자에 해당하지 않는 숫자를 전부 지워버릴 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 3단계 - 두 개 이상 연속된 마침표(.)를 마침표 하나로 치환\r\n\r\n`...`이나 `....`을 전부 `.` 하나로 변경한다. 이 로직도 마찬가지로 정규식을 통해 쉽게 구현하자.\r\n\r\n``` java\r\nprivate String step3(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n}\r\n```\r\n\r\n* `.{2,}` - 두 개 이상인 마침표\r\n\r\n`replaceAll`을 활용하여 마침표가 두 개 연속으로 이어진 문자열을 마침표 하나로 변경한다.\r\n\r\n\r\n\r\n\r\n\r\n## 4단계 - 마침표가 처음이나 끝에 위치할 경우 제거\r\n\r\n문자열 앞이나 뒤에 마침표가 있을 경우 제거한다.\r\n\r\n``` java\r\nprivate String step4(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n}\r\n```\r\n\r\n* `^` - 문자열의 시작. `[]` 밖에서는 부정(NOT)이 아니다.\r\n* `$` - 문자열의 끝\r\n* `|` - OR 연산\r\n\r\n즉, 문자열 앞의 마침표나 문자열 끝의 마침표를 찾는 정규식이다. `replaceAll`을 활용하여 빈 문자로 치환하자.\r\n\r\n\r\n\r\n\r\n\r\n## 5단계 - 빈 문자열일 경우 a 대입\r\n\r\n문자열이 비었을 경우 `a`를 대입한다. 아닐 경우 그대로 둔다.\r\n\r\n``` java\r\nprivate String step5(String new_id)\r\n{\r\n\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 6단계 - 15자를 넘을 경우, 15자로 제한 후 4단계 적용\r\n\r\n글자수 제한과 동일한 개념이다. 단, 글자수를 자르면서 중간에 위치했던 마침표가 끝에 오게될 수도 있으므로, 4단계를 재젹용하라는 조건이 포함되어있다.\r\n\r\n예를 들어, 아이디 `aaaaaaaaaaaaaa.a`는 16글자로, 15자로 제한되면서 마침표가 끝에 오게 될 것이다.\r\n\r\n``` java\r\nprivate String step6(String new_id)\r\n{\r\n\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n}\r\n```\r\n\r\n`new_id`가 15자가 넘는다면, `substring` 메서드로 앞에서부터 15자까지 자른다. 이후 위에서 구현했던 `step4` 메서드를 호출하면 된다.\r\n\r\n이렇게 단계별로 메서드를 나누면 재사용에 유리하다.\r\n\r\n\r\n\r\n\r\n\r\n## 7단계 - 2자 이하일 경우, 3자가 될 때까지 마지막 글자 이어붙이기\r\n\r\n예를 들어, `ab`일 경우 글자가 3자가 될 때까지 마지막 글자 `b`를 이어붙인다. 결과는 `abb`가 될 것이다.\r\n\r\n``` java\r\nprivate String step7(String new_id)\r\n{\r\n\tint more = 3 - new_id.length();\r\n\t\r\n\t// 필요한 글자가 하나 이상 있을 경우\r\n\tif (more > 0)\r\n\t{\r\n\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(new_id);\r\n\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\treturn new_id;\r\n\t}\r\n}\r\n```\r\n\r\n`more`로 3자가 되기 위해 필요한 자리수를 계산한다. 이후 `charAt`로 마지막 글자를 구한다.\r\n\r\n`repeat` 메서드로 해당 글자를 `more`만큼 반복한 뒤, `new_id`에 붙인다.\r\n\r\n문자열 연결 연산엔 개인적인 선호로 `StringBuilder`를 사용한다. `+`를 사용해도 결과를 도출하는데 지장은 없으니, 편한걸로 사용하면 된다.\r\n\r\n> **문자열 연결 연산(+)과 StringBuilder**  \r\n> JAVA에서 `String` 더하기 연산은 편하지만 상대적으로 메모리 소모가 심하다. `String`이 불변객체이므로, 연산 과정에서 새로운 객체를 생성하고, 해제하게된다.  \r\n> `StringBuilder`를 활용하면 우리가 생각했던대로 문자열을 연결하여 연산하므로 상대적으로 연산에 요구되는 자원이 적어진다.  \r\n> JAVA의 최적화 수준과 컴퓨터의 성능이 좋지 않았던 과거의 문제를 해결하기 위한 것으로, 물론 현재는 JAVA도 많은 최적화가 이루어졌고, 컴퓨터 성능은 수 천배로 좋아졌으니, 너무 연연하지 않아도 될 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 신규 아이디 추천 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.07 Tue 00:47:16\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String new_id)\r\n\t{\r\n\t\tString answer = step1(new_id);\r\n\t\tanswer = step2(answer);\r\n\t\tanswer = step3(answer);\r\n\t\tanswer = step4(answer);\r\n\t\tanswer = step5(answer);\r\n\t\tanswer = step6(answer);\r\n\t\tanswer = step7(answer);\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1단계 결과 반환 메서드\r\n\t * 대문자를 모두 소문자로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 1단계 결과\r\n\t */\r\n\tprivate String step1(String new_id)\r\n\t{\r\n\t\treturn new_id.toLowerCase();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 2단계 결과 반환 메서드\r\n\t * 영문 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 2단계 결과\r\n\t */\r\n\tprivate String step2(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 3단계 결과 반환 메서드\r\n\t * 두번 이상 연속된 마침표 하나로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 3단계 결과\r\n\t */\r\n\tprivate String step3(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 4단계 결과 반환 메서드\r\n\t * 맨 앞이나 뒤에 마침표가 있을 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 4단계 결과\r\n\t */\r\n\tprivate String step4(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 5단계 결과 반환 메서드\r\n\t * 빈 문자열일 경우 a 대입\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 5단계 결과\r\n\t */\r\n\tprivate String step5(String new_id)\r\n\t{\r\n\t\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 6단계 결과 반환 메서드\r\n\t * 16자 이상일 경우, 15자로 제한. 끝에 마침표가 오게 될 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 6단계 결과\r\n\t */\r\n\tprivate String step6(String new_id)\r\n\t{\r\n\t\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 7단계 결과 반환 메서드\r\n\t * 2자 이하일 경우, 길이가 3이 될 때까지 마지막 글자 이어붙이기\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 7단계 결과\r\n\t */\r\n\tprivate String step7(String new_id)\r\n\t{\r\n\t\tint more = 3 - new_id.length();\r\n\t\t\r\n\t\t// 필요한 글자가 하나 이상 있을 경우\r\n\t\tif (more > 0)\r\n\t\t{\r\n\t\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\t\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(new_id);\r\n\t\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\t\r\n\t\t\treturn builder.toString();\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn new_id;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n전체 코드는 위와 같다.\r\n\r\n정규식에 대한 기초적인 이해가 있다면 쉽게 풀 수 있지만, 그렇지 않다면 조금 귀찮은 과정을 거쳐야할 것이다.","url":["2021-12-14-programmers-a0002","2021","12","14","programmers-a0002"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 로또의 최고 순위와 최저 순위 (77484)","excerpt":"로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:10:14+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0001.md","content":"\r\n# 로또의 최고 순위와 최저 순위\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [로또의 최고 순위와 최저 순위](https://programmers.co.kr/learn/courses/30/lessons/77484)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.\r\n\r\n|   순위   |   당첨 내용   |\r\n| :------: | :-----------: |\r\n|    1     | 6개 번호 일치 |\r\n|    2     | 5개 번호 일치 |\r\n|    3     | 4개 번호 일치 |\r\n|    4     | 3개 번호 일치 |\r\n|    5     | 2개 번호 일치 |\r\n| 6 (낙첨) |     그 외     |\r\n\r\n로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.\r\n\r\n알아볼 수 없는 번호를 `0`으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 `44, 1, 0, 0, 31 25`라고 가정해보겠습니다. 당첨 번호 6개가 `31, 10, 45, 1, 6, 19`라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.\r\n\r\n|   당첨 번호    |  31   |  10   |  45   |   1   |   6   |  19   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 |  31   | 0→10  |  44   |   1   |  0→6  |  25   | 4개 번호 일치, 3등 |\r\n| 최저 순위 번호 |  31   | 0→11  |  44   |   1   |  0→7  |  25   | 2개 번호 일치, 5등 |\r\n\r\n* 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.\r\n  * 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.\r\n  * 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.\r\n\r\n민우가 구매한 로또 번호를 담은 배열 `lottos`, 당첨 번호를 담은 배열 `win_nums`가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `lottos`는 길이 6인 정수 배열입니다.\r\n* `lottos`의 모든 원소는 0 이상 45 이하인 정수입니다.\r\n  * 0은 알아볼 수 없는 숫자를 의미합니다.\r\n  * 0을 제외한 다른 숫자들은 `lottos`에 2개 이상 담겨있지 않습니다.\r\n  * `lottos`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n* `win_nums`은 길이 6인 정수 배열입니다.\r\n* `win_nums`의 모든 원소는 1 이상 45 이하인 정수입니다.\r\n  * `win_nums`에는 같은 숫자가 2개 이상 담겨있지 않습니다.\r\n  * `win_nums`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|        lottos         |         win_nums         | result |\r\n| :-------------------: | :----------------------: | :----: |\r\n| [44, 1, 0, 0, 31, 25] |  [31, 10, 45, 1, 6, 19]  | [3, 5] |\r\n|  [0, 0, 0, 0, 0, 0]   | [38, 19, 20, 40, 15, 25] | [1, 6] |\r\n| [45, 4, 35, 20, 3, 9] |  [20, 9, 3, 45, 4, 35]   | [1, 1] |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.\r\n\r\n|   당첨 번호    |  38   |  19   |  20   |  40   |  15   |  25   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 | 0→38  | 0→19  | 0→20  | 0→40  | 0→15  | 0→25  | 6개 번호 일치, 1등 |\r\n| 최저 순위 번호 | 0→21  | 0→22  | 0→23  | 0→24  | 0→26  | 0→27  | 0개 번호 일치, 6등 |\r\n\r\n**입출력 예 #3**\r\n\r\n민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n로또의 일부 번호가 지워져 있으며, 이 경우 가질 수 있는 가장 높은 등수와 낮은 등수를 구하는 문제.\r\n\r\n* **가장 높은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수 + 지워진 번호의 갯수\r\n* **가장 낮은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수\r\n\r\n즉, 정확히 표시된 번호 중 당첨된 번호와 지워진 번호를 구분하는 것이 관건이다. 이후 이 갯수를 연산하여 답을 도출할 수 있을 것이다.\r\n\r\n지워진 번호는 `0`으로 표시되므로, `0`일 경우 지워진 번호로 체크하고, 유효한 번호를 가질 경우 `win_nums`와 비교하여 당첨 여부를 확인한다.\r\n\r\n``` java\r\nfor (int lotto : lottos)\r\n{\r\n\t// 번호를 알아볼 수 있을 경우\r\n\tif (lotto > 0)\r\n\t{\r\n\t\tfor (int win_num : win_nums)\r\n\t\t{\r\n\t\t\t// 당첨된 번호일 경우\r\n\t\t\tif (lotto == win_num)\r\n\t\t\t{\r\n\t\t\t\t// 당첨된 번호 카운팅\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 없을 경우\r\n\telse\r\n\t{\r\n\t\t// 지워진 번호 카운팅\r\n\t}\r\n}\r\n```\r\n\r\n위와 같은 로직으로 구성하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 로또의 최고 순위와 최저 순위 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Mon 23:35:13\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param lottos: [int[]] 로또 번호\r\n\t * @param win_nums: [int[]] 당첨 번호\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] lottos, int[] win_nums)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\tint zeros = 0;\r\n\t\t\r\n\t\tfor (int lotto : lottos)\r\n\t\t{\r\n\t\t\t// 번호를 알아볼 수 있을 경우\r\n\t\t\tif (lotto > 0)\r\n\t\t\t{\r\n\t\t\t\tfor (int win_num : win_nums)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 당첨된 번호일 경우\r\n\t\t\t\t\tif (lotto == win_num)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanswer++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 없을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tzeros++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { prize(answer + zeros), prize(answer) };\r\n\t}\r\n\t\r\n\t/**\r\n\t * 순위 반환 메서드\r\n\t *\r\n\t * @param num: [int] 당첨 갯수\r\n\t *\r\n\t * @return [int] 등수\r\n\t */\r\n\tprivate int prize(int num)\r\n\t{\r\n\t\treturn switch (num)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 6 -> 1;\r\n\t\t\t\t\tcase 5 -> 2;\r\n\t\t\t\t\tcase 4 -> 3;\r\n\t\t\t\t\tcase 3 -> 4;\r\n\t\t\t\t\tcase 2 -> 5;\r\n\t\t\t\t\tdefault -> 6;\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다. 당첨된 번호를 `answer`에 카운팅하고, 지워진 번호를 `zeros`에 카운팅한다.\r\n\r\n이후 가장 높은 등수 `answer + zeros`, 가장 낮은 등수 `answer`를 계산하여 배열로 반환한다.\r\n\r\n등수는 `prize` 메서드를 사용하여 얻는다.","url":["2021-12-14-programmers-a0001","2021","12","14","programmers-a0001"]}],"data":{"header":{"title":"[프로그래머스 / JAVA] Level 1 이상한 문자 만들기 (12930)","excerpt":"문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-18T18:27:43+09:00","type":"posts","category":"알고리즘","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-18-programmers-a0050.md","content":"<h1 id=\"이상한-문자 만들기\">이상한 문자 만들기 <a href=\"#이상한-문자 만들기\">🔗</a></h1>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">랭크</th>\n<th align=\"center\">사용 언어</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">Level 1</td>\n<td align=\"center\"><img src=\"https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange\" alt=\"JAVA\"></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>🔗 <a href=\"https://programmers.co.kr/learn/courses/30/lessons/12930\" target=\"_blank\">이상한 문자 만들기</a></p>\n<h2 id=\"문제-설명\">문제 설명 <a href=\"#문제-설명\">🔗</a></h2><p>문자열 <code class=\"inline-code\">s</code>는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, <code class=\"inline-code\">solution</code>을 완성하세요.</p>\n<h2 id=\"제한-사항\">제한 사항 <a href=\"#제한-사항\">🔗</a></h2><ul>\n<li>문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.</li>\n<li>첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.</li>\n</ul>\n<h2 id=\"입출력-예\">입출력 예 <a href=\"#입출력-예\">🔗</a></h2>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">s</th>\n<th align=\"center\">return</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">\"try hello world\"</td>\n<td align=\"center\">\"TrY HeLlO WoRlD\"</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<h3 id=\"입출력-예 설명\">입출력 예 설명 <a href=\"#입출력-예 설명\">🔗</a></h3><p>\"try hello world\"는 세 단어 \"try\", \"hello\", \"world\"로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 \"TrY\", \"HeLlO\", \"WoRlD\"입니다. 따라서 \"TrY HeLlO WoRlD\" 를 리턴합니다.</p>\n<h1 id=\"풀이\">풀이 <a href=\"#풀이\">🔗</a></h1><p>문자를 단어별로 구분하여 홀수 문자는 소문자, 짝수 문자는 대문자로 치환하여 반환한다.</p>\n<p>전체 문자열이 아니라, 문자열의 단어별로 반환하기 때문에, 공백으로 문자열을 구분하여 대소문자 치환을 수행하면 된다.</p>\n<br />\n\n<p><code class=\"inline-code\">s</code>를 한 글자씩 분리하여 반복문을 돌리고, 문자 인덱스를 비교하여 대소문자를 치환한다. 공백을 만날 경우 인덱스를 초기화한다.</p>\n<h2 id=\"코드\">코드 <a href=\"#코드\">🔗</a></h2>\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 이상한 문자 만들기 클래스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.12.13 Mon 18:03:00</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 해답 반환 메서드</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param s: [String] 문자열</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @return [String] 해답</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>        <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> answer <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>        </td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>        </td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> answer<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23>            <span class=\"token comment\" data-tag=\"new\">// 공백일 경우</span></td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25>            <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26>                index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=27><td class=\"line-number\" data-number=\"27\">27</td><td class=\"line-code\" data-number=27>                answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=28><td class=\"line-number\" data-number=\"28\">28</td><td class=\"line-code\" data-number=28>            <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=29><td class=\"line-number\" data-number=\"29\">29</td><td class=\"line-code\" data-number=29>            </td></tr>\n<tr data-number=30><td class=\"line-number\" data-number=\"30\">30</td><td class=\"line-code\" data-number=30>            <span class=\"token comment\" data-tag=\"new\">// 문자열일 경우</span></td></tr>\n<tr data-number=31><td class=\"line-number\" data-number=\"31\">31</td><td class=\"line-code\" data-number=31>            <span class=\"token keyword\">else</span></td></tr>\n<tr data-number=32><td class=\"line-number\" data-number=\"32\">32</td><td class=\"line-code\" data-number=32>            <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=33><td class=\"line-number\" data-number=\"33\">33</td><td class=\"line-code\" data-number=33>                <span class=\"token comment\" data-tag=\"new\">// 짝수 인덱스일 경우</span></td></tr>\n<tr data-number=34><td class=\"line-number\" data-number=\"34\">34</td><td class=\"line-code\" data-number=34>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=35><td class=\"line-number\" data-number=\"35\">35</td><td class=\"line-code\" data-number=35>                <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=36><td class=\"line-number\" data-number=\"36\">36</td><td class=\"line-code\" data-number=36>                    answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=37><td class=\"line-number\" data-number=\"37\">37</td><td class=\"line-code\" data-number=37>                <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=38><td class=\"line-number\" data-number=\"38\">38</td><td class=\"line-code\" data-number=38>                </td></tr>\n<tr data-number=39><td class=\"line-number\" data-number=\"39\">39</td><td class=\"line-code\" data-number=39>                <span class=\"token comment\" data-tag=\"new\">// 홀수 인덱스일 경우</span></td></tr>\n<tr data-number=40><td class=\"line-number\" data-number=\"40\">40</td><td class=\"line-code\" data-number=40>                <span class=\"token keyword\">else</span></td></tr>\n<tr data-number=41><td class=\"line-number\" data-number=\"41\">41</td><td class=\"line-code\" data-number=41>                <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=42><td class=\"line-number\" data-number=\"42\">42</td><td class=\"line-code\" data-number=42>                    answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=43><td class=\"line-number\" data-number=\"43\">43</td><td class=\"line-code\" data-number=43>                <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=44><td class=\"line-number\" data-number=\"44\">44</td><td class=\"line-code\" data-number=44>                </td></tr>\n<tr data-number=45><td class=\"line-number\" data-number=\"45\">45</td><td class=\"line-code\" data-number=45>                index<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=46><td class=\"line-number\" data-number=\"46\">46</td><td class=\"line-code\" data-number=46>            <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=47><td class=\"line-number\" data-number=\"47\">47</td><td class=\"line-code\" data-number=47>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=48><td class=\"line-number\" data-number=\"48\">48</td><td class=\"line-code\" data-number=48>        </td></tr>\n<tr data-number=49><td class=\"line-number\" data-number=\"49\">49</td><td class=\"line-code\" data-number=49>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> answer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=50><td class=\"line-number\" data-number=\"50\">50</td><td class=\"line-code\" data-number=50>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=51><td class=\"line-number\" data-number=\"51\">51</td><td class=\"line-code\" data-number=51><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t","url":["2021-12-18-programmers-a0050","2021","12","18","programmers-a0050"],"toc":[{"text":"이상한 문자 만들기","tag":"이상한-문자 만들기","depth":1},{"text":"문제 설명","tag":"문제-설명","depth":2},{"text":"제한 사항","tag":"제한-사항","depth":2},{"text":"입출력 예","tag":"입출력-예","depth":2},{"text":"입출력 예 설명","tag":"입출력-예 설명","depth":3},{"text":"풀이","tag":"풀이","depth":1},{"text":"코드","tag":"코드","depth":2}]},"hash":"82254c7e122"},"__N_SSG":true}