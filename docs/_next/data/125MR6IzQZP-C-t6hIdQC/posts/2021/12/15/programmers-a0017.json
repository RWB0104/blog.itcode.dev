{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[프로그래머스 / MySQL] Level 1 이름이 없는 동물의 아이디 (59039)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:44:37+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0016.md","content":"\r\n# 이름이 없는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 없는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59039)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A368930  |     Dog     | 2014-06-08 13:20:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A368930  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `NAME`이 null인 데이터를 `ANIMAL_ID` 순으로 조회한다. 해당 데이터 중 `ANIMAL_ID`만을 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0016","2021","12","15","programmers-a0016"]},"next":{"header":{"title":"[프로그래머스 / JAVA] Level 1 실패율 (42889)","excerpt":"슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:17:08+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0018.md","content":"\r\n# 실패율\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [실패율](https://programmers.co.kr/learn/courses/30/lessons/42889)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.amazonaws.com/files/production/bde471d8ac/48ddf1cc-c4ea-499d-b431-9727ee799191.png)\r\n\r\n슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.\r\n\r\n이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.\r\n\r\n* 실패율은 다음과 같이 정의한다.\r\n  * 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수\r\n\r\n전체 스테이지의 개수 `N`, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 `stages`가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 `solution` 함수를 완성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\r\n* `stages`의 길이는 1 이상 200,000 이하이다.\r\n* `stages`에는 1 이상 `N + 1` 이하의 자연수가 담겨있다.\r\n  * 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.\r\n  * 단, `N + 1` 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.\r\n* 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.\r\n* 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   N   |           stages           |      result       |\r\n| :---: | :------------------------: | :---------------: |\r\n|   5   | { 2, 1, 2, 6, 2, 4, 3, 3 } | { 3, 4, 2, 1, 5 } |\r\n|   4   |     { 4, 4, 4, 4, 4 }      |  { 4, 1, 2, 3 }   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 1 번 스테이지 실패율 : 1/8\r\n\r\n2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 2 번 스테이지 실패율 : 3/7\r\n\r\n마찬가지로 나머지 스테이지의 실패율은 다음과 같다.\r\n\r\n* 3 번 스테이지 실패율 : 2/4\r\n* 4번 스테이지 실패율 : 1/2\r\n* 5번 스테이지 실패율 : 0/1\r\n\r\n각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.\r\n\r\n* { 3, 4, 2, 1, 5 }\r\n\r\n**입출력 예 #2**\r\n\r\n모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.\r\n\r\n* { 4, 1, 2, 3 }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n각 스테이지의 실패율을 구하는 문제. 해당 스테이지까지 도전한 사람과, 실패한 사람을 구한다. 이 정보로 실패율을 구하여 실패율 순으로 정렬 후, 반환하는 것이 목표다.\r\n\r\n문제 제대로 안 읽으면 해당 스테이지까지 도전한 사람이 아니라, 전체 사람에서 실패율을 나누게 될 수도 있으니 주의할 것.\r\n\r\n1. 각 스테이지에 머무르고 있는 사람의 수를 카운팅\r\n2. 각 스테이지를 플레이한 사람의 수를 카운팅\r\n   * 만약 스테이지 4에 머무르고 있다면, 1 ~ 4의 스테이지를 시도했고, 4 스테이지의 실패율에 반영된다.\r\n   * N + 1 스테이지일 경우, 전부 클리어한 것이므로 모든 스테이지를 시도한 것이다.\r\n3. 각 스테이지에 머무르고 있는 사람 / 각 스테이지를 플레이한 사람 * 100 으로 실패율 계산\r\n4. 실패율 순으로 정렬하여 스테이지의 번호를 반환\r\n   * 만약, 실패율이 동일하다면 스테이지 순으로 정렬\r\n\r\n위와 같은 흐름으로 구성하면 된다.\r\n\r\n<br />\r\n\r\n1번과 2번은 `stages`의 탐색을 통해 어렵지않게 구현할 수 있다. `N`개의 길이를 가진 정수 배열 `fails`, `users`를 생성하여 각각 클리어 실패자와 시도자를 카운팅한다.\r\n\r\n``` java\r\nint[] fails = new int[N];\r\nint[] users = new int[N];\r\n\r\n// 시도자, 실패자 카운트\r\nfor (int stage : stages)\r\n{\r\n\t// 마지막 스테이지를 깨지 않았을 경우\r\n\tif (stage != N + 1)\r\n\t{\r\n\t\t// 실패한 유저 카운트\r\n\t\tfails[stage - 1]++;\r\n\t\t\r\n\t\t// 시도한 유저 카운트\r\n\t\tfor (int i = 0; i < stage; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 마지막 스테이지를 깼을 경우\r\n\telse\r\n\t{\r\n\t\t// 시도한 유저 전부 카운트\r\n\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n4 스테이지에 머무르고 있을 경우, 실제론 `fails[3]`에 저장되므로 `fails[stage - 1]`에 반영해야 함에 유의하자.\r\n\r\n<br />\r\n\r\n3번은 단순 연산 정도로 끝나지만, 문제는 4번. 실제로 반환해야하는 건 실패율이 아닌 해당 실패율을 가진 스테이지 번호다.\r\n\r\n정렬도 편하게 할 겸 `ArrayList<Double[]>`을 선언하여 스테이지 번호와 실패율을 배열로 관리한다.\r\n\r\n실패율은 `스테이지 실패 인원 수 / 스테이지 도전 인원 수`로 구할 수 있다. 단, 그 누구도 스테이지에 도달하지 못할 경우, 0으로 나누게 되므로 `isNaN()` 메서드로 반드시 NaN 처리를 해야한다.\r\n\r\n예를 들어, `N = 5`, `[ 1, 2, 2, 3, 4 ]`일 경우가 그렇다. 스테이지 5의 경우 그 누구도 시도조차 하지 못 했으므로 스테이지 실패율은 `0 / 0`. 즉, NaN이 된다. 따라서 이 경우 0으로 바꿔야 한다.\r\n\r\n``` java\r\n// 실패율\r\nArrayList<Double[]> failRate = new ArrayList<>();\r\n\r\n// 실패율에 인덱스와 값 할당\r\nfor (int i = 0; i < N; i++)\r\n{\r\n\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\r\n\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n}\r\n```\r\n\r\n`failRate`에 스테이지 번호와 실패율이 담긴 배열을 저장하면 된다.\r\n\r\n<br />\r\n\r\n``` java\r\n// 정렬\r\nfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n```\r\n\r\n정렬은 위와 같다. 원래 `sort()`는 오름차순이므로, 내림차순으로 정렬하도록 별도로 수식을 지정해야한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 실패율 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.11 Sat 02:20:18\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param N: [int] 전체 스테이지 갯수\r\n\t * @param stages: [int[]] 현재 스테이지 번호\r\n\t *\r\n\t * @return [int[]] 실패율이 높은 스테이지\r\n\t */\r\n\tpublic int[] solution(int N, int[] stages)\r\n\t{\r\n\t\tint[] fails = new int[N];\r\n\t\tint[] users = new int[N];\r\n\t\t\r\n\t\t// 시도자, 실패자 카운트\r\n\t\tfor (int stage : stages)\r\n\t\t{\r\n\t\t\t// 마지막 스테이지를 깨지 않았을 경우\r\n\t\t\tif (stage != N + 1)\r\n\t\t\t{\r\n\t\t\t\t// 실패한 유저 카운트\r\n\t\t\t\tfails[stage - 1]++;\r\n\t\t\t\t\r\n\t\t\t\t// 시도한 유저 카운트\r\n\t\t\t\tfor (int i = 0; i < stage; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 스테이지를 깼을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 시도한 유저 전부 카운트\r\n\t\t\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 실패율\r\n\t\tArrayList<Double[]> failRate = new ArrayList<>();\r\n\t\t\r\n\t\t// 실패율에 인덱스와 값 할당\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\t\t\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\t\t\r\n\t\t\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬\r\n\t\tfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n\t\t\r\n\t\treturn failRate.stream().mapToInt(value -> value[0].intValue()).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0018","2021","12","15","programmers-a0018"]}},"group":[{"header":{"title":"[프로그래머스 / JAVA] Level 1 비밀지도 (17681)","excerpt":"네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T01:02:41+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0032.md","content":"\r\n# 비밀지도\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [비밀지도](https://programmers.co.kr/learn/courses/30/lessons/17681)\r\n\r\n\r\n\r\n\r\n\r\n## 부족한 금액 계산하기\r\n\r\n네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\r\n\r\n1. 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 \"공백\"(\" \") 또는 \"벽\"(\"#\") 두 종류로 이루어져 있다.\r\n2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \"지도 1\"과 \"지도 2\"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.\r\n3. \"지도 1\"과 \"지도 2\"는 각각 정수 배열로 암호화되어 있다.\r\n4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\r\n\r\n![image](http://t1.kakaocdn.net/welcome2018/secret8.png)\r\n\r\n네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 입력 형식\r\n\r\n입력으로 지도의 한 변 크기 `n`과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.\r\n\r\n* 1 ≦ n ≦ 16\r\n* arr1, arr2는 길이 n인 정수 배열로 주어진다.\r\n* 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.\r\n\r\n\r\n\r\n\r\n\r\n## 출력 형식\r\n\r\n원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예제\r\n\r\n| 매개변수 |                      값                       |\r\n| :------: | :-------------------------------------------: |\r\n|    n     |                       5                       |\r\n|   arr1   |             { 9, 20, 28, 18, 11 }             |\r\n|   arr2   |             { 30, 1, 21, 17, 28 }             |\r\n|   출력   | { \"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\" } |\r\n\r\n| 매개변수 |                              값                              |\r\n| :------: | :----------------------------------------------------------: |\r\n|    n     |                              6                               |\r\n|   arr1   |                  { 46, 33, 33, 22, 31, 50 }                  |\r\n|   arr2   |                  { 27, 56, 19, 14, 14, 10 }                  |\r\n|   출력   | { \"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \" } |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n두 개의 지도가 있으며, 이 지도를 겹쳐서 진짜 지도를 확인해야 한다. 두 지도 중 하나라도 벽(#)이 있을 경우 해당 공간은 벽이다.\r\n\r\n`10101 -> # # #`이므로, `# = 1`, `공백 = 0`으로 볼 수 있다. 두 값 중 하나라도 1(#)일 경우 해당 지역은 1(#)이 되므로, OR 연산을 구현하면 된다.\r\n\r\n|   a   |   b   |  값   |\r\n| :---: | :---: | :---: |\r\n|   1   |   1   |   1   |\r\n|   1   |   0   |   1   |\r\n|   0   |   1   |   1   |\r\n|   0   |   0   |   0   |\r\n\r\nOR 연산은 `a`와 `b` 중 하나라도 1일 경우 1이 된다.\r\n\r\n<br />\r\n\r\n남은 건 10진수를 2진수로 변경하여 1을 #, 0을 공백으로 치환하기만 하면 된다.\r\n\r\n``` java\r\nprivate int[] dec2bin(int n, int num)\r\n{\r\n\tint[] arr = new int[n];\r\n\t\r\n\tfor (int i = 0; i < n; i++)\r\n\t{\r\n\t\tarr[n - i - 1] = num % 2;\r\n\t\t\r\n\t\tnum /= 2;\r\n\t}\r\n\t\r\n\treturn arr;\r\n}\r\n```\r\n\r\n2진수 변환 메서드는 위와 같다. 10진수 `num`을 `n`자리의 2진수로 변환하며 배열로 반환한다.\r\n\r\n반환된 배열의 값을 토대로 #과 공백을 나누어 문자열로 만들면 될 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 비밀지도 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:54:09\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 지도 길이\r\n\t * @param arr1: [int[]] 지도 1\r\n\t * @param arr2: [int[]] 지도 2\r\n\t *\r\n\t * @return [String[]] 해답\r\n\t */\r\n\tpublic String[] solution(int n, int[] arr1, int[] arr2)\r\n\t{\r\n\t\tString[] map = new String[n];\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tint[] map1 = dec2bin(n, arr1[i]);\r\n\t\t\tint[] map2 = dec2bin(n, arr2[i]);\r\n\t\t\t\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < n; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하나라도 벽이 있을 경우 그 공간은 벽(#)\r\n\t\t\t\tbuilder.append((map1[j] | map2[j]) == 1 ? \"#\" : \" \");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmap[i] = builder.toString();\r\n\t\t}\r\n\t\t\r\n\t\treturn map;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 10진수 -> 2진수 배열 반환 메서드\r\n\t *\r\n\t * @param n: [int] 크기\r\n\t * @param num: [int] 10진수\r\n\t *\r\n\t * @return [int[]] 2진수 배열\r\n\t */\r\n\tprivate int[] dec2bin(int n, int num)\r\n\t{\r\n\t\tint[] arr = new int[n];\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tarr[n - i - 1] = num % 2;\r\n\t\t\t\r\n\t\t\tnum /= 2;\r\n\t\t}\r\n\t\t\r\n\t\treturn arr;\r\n\t}\r\n}\r\n```","url":["2021-12-16-programmers-a0032","2021","12","16","programmers-a0032"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 부족한 금액 계산하기 (82612)","excerpt":"새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다. 놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-16T00:52:21+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-16-programmers-a0031.md","content":"\r\n# 부족한 금액 계산하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [부족한 금액 계산하기](https://programmers.co.kr/learn/courses/30/lessons/82612)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 `N`번 째 이용한다면 원래 이용료의 `N`배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\r\n놀이기구를 `count`번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 `solution` 함수를 완성하세요.\r\n단, 금액이 부족하지 않으면 0을 return 하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 놀이기구의 이용료 `price` : 1 ≤ `price` ≤ 2,500, `price`는 자연수\r\n* 처음 가지고 있던 금액 `money` : 1 ≤ `money` ≤ 1,000,000,000, `money`는 자연수\r\n* 놀이기구의 이용 횟수 `count` : 1 ≤ `count` ≤ 2,500, `count`는 자연수\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| price | money | count | result |\r\n| :---: | :---: | :---: | :----: |\r\n|   3   |  20   |   4   |   10   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n시대상을 역행하는 놀이기구다. 타면 탈 수록 가격을 더 받는다니...\r\n\r\n`count` 횟수만큼 `for`문을 수행하여 `price * count`를 누적하여 반환한다.\r\n\r\n반환값이 `long`임에 주의하자. 간혹 아무 생각없이 `int`로 변수를 선언해서 반환해버리는 경우가 있는데, `int`에서 더 많은 범위를 가지는 `long`으로의 변환은 아무런 문제없이 자동으로 이루어지므로, `int`를 반환해도 문제가 없다. 하지만 체점 과정에서 `int`의 범위를 넘어버리는 수가 생길 경우 온전히 표현하지 못하게 되므로 오답이 발생한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 부족한 금액 계산하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:43:20\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param price: [int] 이용료\r\n\t * @param money: [int] 소지금\r\n\t * @param count: [int] 놀이기구를 이용한 횟수\r\n\t *\r\n\t * @return [long] 해답\r\n\t */\r\n\tpublic long solution(int price, int money, int count)\r\n\t{\r\n\t\tlong total = 0;\r\n\t\t\r\n\t\twhile (count > 0)\r\n\t\t{\r\n\t\t\ttotal += (long) price * count;\r\n\t\t\t\r\n\t\t\tcount--;\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.max(total - money, 0);\r\n\t}\r\n}\r\n```\r\n\r\n`total`을 `int`로 반환하지 않도록 주의하자.","url":["2021-12-16-programmers-a0031","2021","12","16","programmers-a0031"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 동물의 아이디와 이름 (59403)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:58:28+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0030.md","content":"\r\n# 동물의 아이디와 이름\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [동물의 아이디와 이름](https://programmers.co.kr/learn/courses/30/lessons/59403)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 아이디와 이름을 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID |     NAME     |\r\n| :-------: | :----------: |\r\n|  A349996  |    Sugar     |\r\n|  A350276  |    Jewel     |\r\n|  A350375  |     Meo      |\r\n|  A352555  |    Harley    |\r\n|  A352713  |     Gia      |\r\n|  A352872  | Peanutbutter |\r\n|  A353259  |      Bj      |\r\n\r\n((이하 생략))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n모든 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0030","2021","12","15","programmers-a0030"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 나머지가 1이 되는 수 찾기 (87389)","excerpt":"자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:36:45+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0029.md","content":"\r\n# 나머지가 1이 되는 수 찾기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [나머지가 1이 되는 수 찾기](https://programmers.co.kr/learn/courses/30/lessons/87389)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `n`이 매개변수로 주어집니다. `n`을 `x`로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 `x`를 return 하도록 `solution` 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 3 ≤ `n` ≤ 1,000,000\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|  10   |   3    |\r\n|  12   |   11   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n10을 3으로 나눈 나머지가 1이고, 3보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 3을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n12를 11로 나눈 나머지가 1이고, 11보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 11을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n별다른 요구사항은 없다. 그냥 `n`이라는 자연수를 나눴을 때, 나머지가 1이 되는 가장 작은 수 `x`를 반환하면 된다.\r\n\r\n그냥 `x = 1` 부터 나눠서 `n % x == 1`일 때까지 `x`를 증가시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 나머지가 1이 되는 수 찾기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:35:58\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tint x = 1;\r\n\t\t\r\n\t\twhile (n % x != 1)\r\n\t\t{\r\n\t\t\tx++;\r\n\t\t}\r\n\t\t\r\n\t\treturn x;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0029","2021","12","15","programmers-a0029"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 최소직사각형 (86491)","excerpt":"명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다. 아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:22:00+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0028.md","content":"\r\n# 최소직사각형\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [최소직사각형](https://programmers.co.kr/learn/courses/30/lessons/86491)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.\r\n\r\n아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.\r\n\r\n| 명함 번호 | 가로 길이 | 세로 길이 |\r\n| :-------: | :-------: | :-------: |\r\n|     1     |    60     |    50     |\r\n|     2     |    30     |    70     |\r\n|     3     |    60     |    30     |\r\n|     4     |    80     |    40     |\r\n\r\n가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.\r\n\r\n모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 `sizes`가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `sizes`의 길이는 1 이상 10,000 이하입니다.\r\n* `sizes`의 원소는 `[ w, h ]` 형식입니다.\r\n* `w`는 명함의 가로 길이를 나타냅니다.\r\n* `h`는 명함의 세로 길이를 나타냅니다.\r\n* `w`와 `h`는 1 이상 1,000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                           sizes                           | result |\r\n| :-------------------------------------------------------: | :----: |\r\n|    { { 60, 50 }, { 30, 70 }, { 60, 30 }, { 80, 40 } }     |  4000  |\r\n| { { 10, 7 }, { 12, 3 }, { 8, 15 }, { 14, 7 }, { 5, 15 } } |  120   |\r\n| { { 14, 4 }, { 19, 6 }, { 6, 16 }, { 18, 7 }, { 7, 11 } } |  133   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.\r\n\r\n**입출력 예 #3**\r\n\r\n명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n일상생활에서 보는 명함의 크기는 제각각이다. 물론 어느정도의 규격은 가지는 것 같지만, 동일하다곤 할 수 없다. 또한 어떤 명함은 세로형이고, 어떤 명함은 가로형이다.\r\n\r\n이 문제에선 이렇게 다양한 명함들이 있는데, 이 명함을 문제없이 수납 가능한 지갑을 만드는 것이 목표다.\r\n\r\n<br />\r\n\r\n우리가 명함을 정리한다고 생각해보자. 크기나 앞뒤, 방향 상관없이 모든 명함이 긴 쪽으로 정렬하는 것이 보통이다.\r\n\r\n우리도 마찬가지로, 코드 상에서 우선 명함의 방향을 정렬할 필요가 있다. 조건에 관계없이, 우선 두 길이 중 긴 길이를 우선하여 정렬한다.\r\n\r\n그럼 상대적으로 `[ 명함의 긴 쪽, 명함의 짧은 쪽 ]`으로 정렬된다.\r\n\r\n이후 `for`문을 통해 하나하나 탐색해가며 명함의 긴 쪽 중 가장 큰 값, 명함의 짧은 쪽 중 가장 큰 값을 구하면 모든 명함을 문제없이 수납할 수 있을 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 최소직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 16:20:39\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param sizes: [int[][]] 가로 세로 길이\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[][] sizes)\r\n\t{\r\n\t\tint w = 0;\r\n\t\tint h = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < sizes.length; i++)\r\n\t\t{\r\n\t\t\tint a = sizes[i][0];\r\n\t\t\tint b = sizes[i][1];\r\n\t\t\t\r\n\t\t\t// 방향 상관없이 더 큰 길이를 sizes[i][0]에, 짧은 길이를 sizes[i][1]에 배치\r\n\t\t\tsizes[i][0] = Math.max(a, b);\r\n\t\t\tsizes[i][1] = Math.min(a, b);\r\n\t\t\t\r\n\t\t\t// 더 큰 길이의 최대값과, 더 작은 길이의 최대값을 구함\r\n\t\t\tw = Math.max(w, sizes[i][0]);\r\n\t\t\th = Math.max(h, sizes[i][1]);\r\n\t\t}\r\n\t\t\r\n\t\treturn w * h;\r\n\t}\r\n}\r\n```\r\n\r\n원한다면 `w = Math.max(w, Math.max(sizes[i][0], sizes[i][1]));`의 형태와 같이 간소화할 수도 있다.","url":["2021-12-15-programmers-a0028","2021","12","15","programmers-a0028"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 어린 동물 찾기 (59037)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T23:03:19+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0027.md","content":"\r\n# 어린 동물 찾기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [어린 동물 찾기](https://programmers.co.kr/learn/courses/30/lessons/59037)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 젊은 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A365172  |     Dog     | 2014-08-26 12:53:00 |      Normal      |  Diablo  |  Neutered Male  |\r\n|  A367012  |     Dog     | 2015-09-16 09:06:00 |       Sick       |  Miller  |  Neutered Male  |\r\n|  A365302  |     Dog     | 2017-01-08 16:34:00 |       Aged       |  Minnie  |  Spayed Female  |\r\n|  A381217  |     Dog     | 2017-07-08 09:41:00 |       Sick       | Cherokee |  Neutered Male  |\r\n\r\n이 중 젊은 동물은 Diablo, Miller, Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |  NAME   |\r\n| :-------: | :-----: |\r\n|  A365172  | Diablo  |\r\n|  A367012  | Miller  |\r\n|  A381217  | Cheroke |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`INTAKE_CONDITION`이 `Aged`가 아닌 젊은 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS WHERE INTAKE_CONDITION != 'Aged' ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0027","2021","12","15","programmers-a0027"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 2016년 (12901)","excerpt":"2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a, b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN, MON, TUE, WED, THU, FRI, SAT 입니다. 예를 들어 a = 5, b = 24라면 5월 24일은 화요일이므로 문자열 \"TUE\"를 반환하세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:58:49+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0026.md","content":"\r\n# 2016년\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [2016년](https://programmers.co.kr/learn/courses/30/lessons/12901)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 `a`, `b`를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, `solution`을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN, MON, TUE, WED, THU, FRI, SAT 입니다. 예를 들어 `a = 5`, `b = 24`라면 5월 24일은 화요일이므로 문자열 \"TUE\"를 반환하세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 2016년은 윤년입니다.\r\n* 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   a   |   b   | result |\r\n| :---: | :---: | :----- |\r\n|   5   |  24   | \"TUE\"  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n2016년 중 특정 날짜에 해당하는 요일을 요구하는 문제. 날짜 객체를 사용하면 별다른 연산 없이 쉽게 구할 수 있다.\r\n\r\n여기서는 `Date` 객체를 활용하여, `yyyy-MM-dd` 형태의 문자열을 `Date` 객체로 변환하여 요일을 빼낼 것이다.\r\n\r\n`Date.valueOf(\"yyyy-MM-dd\").toLocalDate().getDayOfWeek().getValue()`를 통해 요일을 빼낼 수 있다.\r\n\r\n다행히 월요일을 1부터 시작해서, 7인 일요일로 끝난다. 간혹 언어나 설정에 따라 1을 일요일로 치거나, 0을 월요일 혹은 일요일로 시작하기도 한다.\r\n\r\n코드를 간소화하기 위해 1 ~ 7 사이의 숫자를 입력하면 요일로 반환하는 메서드를 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.sql.Date;\r\n\r\n/**\r\n * 2016년 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:38:13\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int] 월\r\n\t * @param b: [int] 일\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int a, int b)\r\n\t{\r\n\t\tString dateStr = new StringBuilder().append(\"2016-\").append(a).append(\"-\").append(b).toString();\r\n\t\t\r\n\t\tint dayOfWeek = Date.valueOf(dateStr).toLocalDate().getDayOfWeek().getValue();\r\n\t\t\r\n\t\treturn getDayName(dayOfWeek);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요일 이름 반환 메서드\r\n\t *\r\n\t * @param dayOfWeek: [int] 주별 요일 번호\r\n\t *\r\n\t * @return [String] 요일 이름\r\n\t */\r\n\tprivate String getDayName(int dayOfWeek)\r\n\t{\r\n\t\treturn switch (dayOfWeek)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1 -> \"MON\";\r\n\t\t\t\t\tcase 2 -> \"TUE\";\r\n\t\t\t\t\tcase 3 -> \"WED\";\r\n\t\t\t\t\tcase 4 -> \"THU\";\r\n\t\t\t\t\tcase 5 -> \"FRI\";\r\n\t\t\t\t\tcase 6 -> \"SAT\";\r\n\t\t\t\t\tdefault -> \"SUN\";\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0026","2021","12","15","programmers-a0026"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 아픈 동물 찾기 (59036)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:50:59+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0025.md","content":"\r\n# 아픈 동물 찾기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [아픈 동물 찾기](https://programmers.co.kr/learn/courses/30/lessons/59036)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중 아픈 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A365172  |     Dog     | 2014-08-26 12:53:00 |      Normal      |  Diablo  |  Neutered Male  |\r\n|  A367012  |     Dog     | 2015-09-16 09:06:00 |       Sick       |  Miller  |  Neutered Male  |\r\n|  A365302  |     Dog     | 2017-01-08 16:34:00 |       Aged       |  Minnie  |  Spayed Female  |\r\n|  A381217  |     Dog     | 2017-07-08 09:41:00 |       Sick       | Cherokee |  Neutered Male  |\r\n\r\n이 중 아픈 동물은 Miller와 Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |   NAME   |\r\n| :-------: | :------: |\r\n|  A367012  |  Miller  |\r\n|  A381217  | Cherokee |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`INTAKE_CONDITION`이 `Sick`으로 표기된 아픈 동물의 `ANIMAL_ID`, `NAME`을 조회한다. 결과는 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID, NAME FROM ANIMAL_INS WHERE INTAKE_CONDITION = 'Sick' ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0025","2021","12","15","programmers-a0025"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 두 개 뽑아서 더하기 (68644)","excerpt":"정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:47:44+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0024.md","content":"\r\n# 두 개 뽑아서 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n정수 배열 `numbers`가 주어집니다. `numbers`에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `numbers`의 길이는 2 이상 100 이하입니다.\r\n  * `numbers`의 모든 수는 0 이상 100 이하입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      numbers      |        result        |\r\n| :---------------: | :------------------: |\r\n| { 2, 1, 3, 4, 1 } | { 2, 3, 4, 5, 6, 7 } |\r\n|  { 5, 0, 2, 7 }   |  { 2, 5, 7, 9, 12 }  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n* 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)\r\n* 3 = 2 + 1 입니다.\r\n* 4 = 1 + 3 입니다.\r\n* 5 = 1 + 4 = 2 + 3 입니다.\r\n* 6 = 2 + 4 입니다.\r\n* 7 = 3 + 4 입니다.\r\n  \r\n따라서 { 2, 3, 4, 5, 6, 7 } 을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n* 2 = 0 + 2 입니다.\r\n* 5 = 5 + 0 입니다.\r\n* 7 = 0 + 7 = 5 + 2 입니다.\r\n* 9 = 2 + 7 입니다.\r\n* 12 = 5 + 7 입니다.\r\n  \r\n따라서 { 2, 5, 7, 9, 12 } 를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n정수 배열 `numbers`에서 임의의 정수 두 개를 뽑아 더할 때, 나올 수 있는 모든 수의 배열을 요구하는 알고리즘이다.\r\n\r\n1. 배열에서 임의의 요소 두 개를 뽑아내는 알고리즘\r\n2. 두 수를 더한 값 저장\r\n\r\n1번의 경우 이중 `for`로도 충분히 구현할 수 있지만, 이번에는 좀 더 알고리즘적인 측면에서 접근하고자 한다. 백트래킹을 활용한 조합 알고리즘을 통해 요소를 뽑아내보자.\r\n\r\n2번의 경우 `HashSet`을 사용하여 더한 값의 고유값만을 지정하도록 하자.\r\n\r\n<br />\r\n\r\n``` java\r\n/**\r\n * 조합 메서드 (백트래킹)\r\n *\r\n * @param numbers: [int[]] 대상 배열\r\n * @param isCheck: [int[]] 백트래킹 체크 여부 배열\r\n * @param start: [int] 시작값\r\n * @param target: [int] 조합할 갯수\r\n */\r\nprivate void combination(int[] numbers, boolean[] isCheck, int start, int target)\r\n{\r\n\t// 조합할 갯수가 0개일 경우 (탐색 완료)\r\n\tif (target == 0)\r\n\t{\r\n\t\tint sum = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < numbers.length; i++)\r\n\t\t{\r\n\t\t\t// 백트래킹 체크일 경우\r\n\t\t\tif (isCheck[i])\r\n\t\t\t{\r\n\t\t\t\tsum += numbers[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tset.add(sum);\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tfor (int i = start; i < numbers.length; i++)\r\n\t\t{\r\n\t\t\tisCheck[i] = true;\r\n\t\t\t\r\n\t\t\tcombination(numbers, isCheck, i + 1, target - 1);\r\n\t\t\t\r\n\t\t\tisCheck[i] = false;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n백트래킹 조합 알고리즘은 위와 같다.\r\n\r\n조합을 수행한 뒤 선택된 두 값을 더해 `HashSet` 객체에 입력한다.\r\n\r\n이후 해당값을 정렬하여 배열로 반환한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * 두 개 뽑아서 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:19:39\r\n */\r\nclass Solution\r\n{\r\n\tprivate HashSet<Integer> set;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] numbers)\r\n\t{\r\n\t\tset = new HashSet<>();\r\n\t\t\r\n\t\tboolean[] isCheck = new boolean[numbers.length];\r\n\t\t\r\n\t\tcombination(numbers, isCheck, 0, 2);\r\n\t\t\r\n\t\treturn set.stream().mapToInt(Integer::intValue).sorted().toArray();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 메서드 (백트래킹)\r\n\t *\r\n\t * @param numbers: [int[]] 대상 배열\r\n\t * @param isCheck: [int[]] 백트래킹 체크 여부 배열\r\n\t * @param start: [int] 시작값\r\n\t * @param target: [int] 조합할 갯수\r\n\t */\r\n\tprivate void combination(int[] numbers, boolean[] isCheck, int start, int target)\r\n\t{\r\n\t\t// 조합할 갯수가 0개일 경우 (탐색 완료)\r\n\t\tif (target == 0)\r\n\t\t{\r\n\t\t\tint sum = 0;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < numbers.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 백트래킹 체크일 경우\r\n\t\t\t\tif (isCheck[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tsum += numbers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tset.add(sum);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = start; i < numbers.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisCheck[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(numbers, isCheck, i + 1, target - 1);\r\n\t\t\t\t\r\n\t\t\t\tisCheck[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0024","2021","12","15","programmers-a0024"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 이름이 있는 동물의 아이디 (59407)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:21:06+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0023.md","content":"\r\n# 이름이 있는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 있는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59407)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 ANIMAL_INS 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A434523  |     Cat     | 2015-11-20 14:18:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A562649  |     Dog     | 2014-03-20 18:06:00 |       Sick       |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n이름이 있는 동물의 ID는 A524634와 A465637입니다. 따라서 SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A465637  |\r\n|  A524634  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`NAME`을 가진 동물들을 `ANIMAL_ID`의 오름차순으로 정렬한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NOT NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0023","2021","12","15","programmers-a0023"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 두 개 뽑아서 더하기 (12982)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:10:27+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0022.md","content":"\r\n# 두 개 뽑아서 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [예산](https://programmers.co.kr/learn/courses/30/lessons/12982)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\nS사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.\r\n\r\n물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.\r\n\r\n부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.\r\n* `d`의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.\r\n* `budget`은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         d         | budget | result |\r\n| :---------------: | :----: | :----: |\r\n| { 1, 3, 2, 5, 4 } |   9    |   3    |\r\n|  { 2, 2, 3, 3 }   |   10   |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.\r\n\r\n* 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.\r\n* 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.\r\n\r\n3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n생각을 조금만 해보면 크게 어렵지 않다. 최대한 많은 부서에 예산을 할당하는 것이 목표며, 예산을 줄거면 주고, 말거면 말아야한다. 즉, 반만 주거나 일부만 줘선 안된다는 얘기다.\r\n\r\n복잡하게 생각할 것 없이, 예산 순으로 정렬하여, 가장 예산을 적게 요청한 부서부터 순서대로 카운팅하면 된다.\r\n\r\n예산이 한정되어 있으므로, 예산을 적게 요청한 부서 순으로 주면 더욱 많은 부서에 예산을 줄 확률이 높아진다.\r\n\r\n1. 예산 순으로 정렬\r\n2. 예산이 0보다 작아질 때까지 요청한 예산 감산\r\n\r\n0이 넘어가는 순간 예산 초과이므로, 해당 부서부터는 예산을 줄 수 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 예산 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:07:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param d: [int[]] 부서별 신청 금액\r\n\t * @param budget: [int] 예산\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] d, int budget)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tArrays.sort(d);\r\n\t\t\r\n\t\tfor (int j : d)\r\n\t\t{\r\n\t\t\tbudget -= j;\r\n\t\t\t\r\n\t\t\t// 예산을 초과할 경우\r\n\t\t\tif (budget < 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tanswer++;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0022","2021","12","15","programmers-a0022"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 예산 (12982)","excerpt":"S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T22:10:27+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0021.md","content":"\r\n# 예산\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [예산](https://programmers.co.kr/learn/courses/30/lessons/12982)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\nS사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.\r\n\r\n물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.\r\n\r\n부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.\r\n* `d`의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.\r\n* `budget`은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         d         | budget | result |\r\n| :---------------: | :----: | :----: |\r\n| { 1, 3, 2, 5, 4 } |   9    |   3    |\r\n|  { 2, 2, 3, 3 }   |   10   |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.\r\n\r\n* 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.\r\n* 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n* 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.\r\n\r\n3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n생각을 조금만 해보면 크게 어렵지 않다. 최대한 많은 부서에 예산을 할당하는 것이 목표며, 예산을 줄거면 주고, 말거면 말아야한다. 즉, 반만 주거나 일부만 줘선 안된다는 얘기다.\r\n\r\n복잡하게 생각할 것 없이, 예산 순으로 정렬하여, 가장 예산을 적게 요청한 부서부터 순서대로 카운팅하면 된다.\r\n\r\n예산이 한정되어 있으므로, 예산을 적게 요청한 부서 순으로 주면 더욱 많은 부서에 예산을 줄 확률이 높아진다.\r\n\r\n1. 예산 순으로 정렬\r\n2. 예산이 0보다 작아질 때까지 요청한 예산 감산\r\n\r\n0이 넘어가는 순간 예산 초과이므로, 해당 부서부터는 예산을 줄 수 없다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 예산 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 03:07:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param d: [int[]] 부서별 신청 금액\r\n\t * @param budget: [int] 예산\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] d, int budget)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tArrays.sort(d);\r\n\t\t\r\n\t\tfor (int j : d)\r\n\t\t{\r\n\t\t\tbudget -= j;\r\n\t\t\t\r\n\t\t\t// 예산을 초과할 경우\r\n\t\t\tif (budget < 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tanswer++;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0021","2021","12","15","programmers-a0021"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 3진법 뒤집기 (68935)","excerpt":"자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:48:12+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0020.md","content":"\r\n# 3진법 뒤집기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [3진법 뒤집기](https://programmers.co.kr/learn/courses/30/lessons/68935)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n자연수 `n`이 매개변수로 주어집니다. `n`을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `n`은 1 이상 100,000,000 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   | result |\r\n| :---: | :----: |\r\n|  45   |   7    |\r\n|  125  |  229   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n답을 도출하는 과정은 다음과 같습니다.\r\n\r\n| n (10진법) | n (3진법) | 앞뒤 반전(3진법) | 10진법으로 표현 |\r\n| :--------: | :-------: | :--------------: | :-------------: |\r\n|     45     |   1200    |       0021       |        7        |\r\n\r\n따라서 7을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n답을 도출하는 과정은 다음과 같습니다.\r\n\r\n| n (10진법) | n (3진법) | 앞뒤 반전(3진법) | 10진법으로 표현 |\r\n| :--------: | :-------: | :--------------: | :-------------: |\r\n|    125     |   11122   |      22111       |       229       |\r\n\r\n따라서 229를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n임의의 숫자를 3진법으로 치환하여 역순으로 배열하고, 이를 다시 10진법으로 치환하는 알고리즘이다.\r\n\r\n1. 10진법 -> 3진법 변환 알고리즘\r\n2. 3진법 -> 10진법 변환 알고리즘\r\n\r\n10진법과 3진법의 자유로운 변환이 이루어지도록 변환 모듈을 구성하는 것이 좋아보인다.\r\n\r\n또한, 3진법에서 숫자를 역순으로 배치해야하니, 각 숫자를 따로따로 `List`에 할당하여 한번에 역순으로 돌려버리는 방법을 차용하고자 한다.\r\n\r\n<br />\r\n\r\n10진법에서 3진법으로 변환하는 메소드는 아래와 같다.\r\n\r\n``` java\r\nprivate ArrayList<Integer> dec2ter(int num)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tint max = 0;\r\n\t\r\n\twhile (Math.pow(3, max) <= num)\r\n\t{\r\n\t\tmax++;\r\n\t}\r\n\t\r\n\tfor (int i = max - 1; i > -1; i--)\r\n\t{\r\n\t\tint pow = (int) Math.pow(3, i);\r\n\t\t\r\n\t\tlist.add(num / pow);\r\n\t\t\r\n\t\tnum %= pow;\r\n\t}\r\n\t\r\n\treturn list;\r\n}\r\n```\r\n\r\n정수 형태의 3진법은 크게 의미가 없다. 0이 앞에 나오게 되면 정수형으로 변환되면서 유실될 가능성도 크고, 굳이 정수형에서의 연산이 필요 없기 때문. 따라서 `ArrayList<Integer>`로 반환한다.\r\n\r\n``` java\r\nprivate int ter2dec(ArrayList<Integer> nums)\r\n{\r\n\tint flag = nums.size() - 1;\r\n\t\r\n\tint answer = 0;\r\n\t\r\n\tfor (int num : nums)\r\n\t{\r\n\t\tanswer += (int) Math.pow(3, flag) * num;\r\n\t\t\r\n\t\tflag--;\r\n\t}\r\n\t\r\n\treturn answer;\r\n}\r\n```\r\n\r\n3진법 -> 10진법 변환 알고리즘은 위와 같다.\r\n\r\n`dec2ter`으로 3진법 배열을 받아서, 이를 역순으로 배열하고 다시 `ter2dec` 메서드로 변환하면 된다. `Collections.reverse()` 메서드를 통해 `List` 같은 `Collection` 객체의 역순 배열을 수행할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * 3진법 뒤집기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 00:47:33\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 자연수\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int n)\r\n\t{\r\n\t\tArrayList<Integer> list = dec2ter(n);\r\n\t\t\r\n\t\tCollections.reverse(list);\r\n\t\t\r\n\t\treturn ter2dec(list);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 10진법 -> 3진법 배열 반환 메서드\r\n\t *\r\n\t * @param num: [int] 자연수\r\n\t *\r\n\t * @return [ArrayList] 3진법 배열\r\n\t */\r\n\tprivate ArrayList<Integer> dec2ter(int num)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tint max = 0;\r\n\t\t\r\n\t\twhile (Math.pow(3, max) <= num)\r\n\t\t{\r\n\t\t\tmax++;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = max - 1; i > -1; i--)\r\n\t\t{\r\n\t\t\tint pow = (int) Math.pow(3, i);\r\n\t\t\t\r\n\t\t\tlist.add(num / pow);\r\n\t\t\t\r\n\t\t\tnum %= pow;\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 3진법 -> 10진법 반환 메서드\r\n\t *\r\n\t * @param nums: [ArrayList] 3진법 배열\r\n\t *\r\n\t * @return [int] 10진법 숫자\r\n\t */\r\n\tprivate int ter2dec(ArrayList<Integer> nums)\r\n\t{\r\n\t\tint flag = nums.size() - 1;\r\n\t\t\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int num : nums)\r\n\t\t{\r\n\t\t\tanswer += (int) Math.pow(3, flag) * num;\r\n\t\t\t\r\n\t\t\tflag--;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0020","2021","12","15","programmers-a0020"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 약수의 개수와 덧셈 (77884)","excerpt":"두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:29:31+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0019.md","content":"\r\n# 약수의 개수와 덧셈\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [약수의 개수와 덧셈](https://programmers.co.kr/learn/courses/30/lessons/77884)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n두 정수 `left`와 `right`가 매개변수로 주어집니다. `left`부터 `right`까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `left` ≤ `right` ≤ 1,000\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n| left  | right | result |\r\n| :---: | :---: | :----: |\r\n|  13   |  17   |   43   |\r\n|  24   |  27   |   52   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다.\r\n\r\n|  수   |      약수      | 약수의 개수 |\r\n| :---: | :------------: | :---------: |\r\n|  13   |     1, 13      |      2      |\r\n|  14   |  1, 2, 7, 14   |      4      |\r\n|  15   |  1, 3, 5, 15   |      4      |\r\n|  16   | 1, 2, 4, 8, 16 |      5      |\r\n|  17   |     1, 17      |      2      |\r\n\r\n따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다.\r\n\r\n|  수   |           약수           | 약수의 개수 |\r\n| :---: | :----------------------: | :---------: |\r\n|  24   | 1, 2, 3, 4, 6, 8, 12, 24 |      8      |\r\n|  25   |         1, 5, 25         |      3      |\r\n|  26   |       1, 2, 13, 26       |      4      |\r\n|  27   |       1, 3, 9, 27        |      4      |\r\n\r\n따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n난이도가 낮은 간단한 문제. 약수를 구하는 알고리즘 정도만 구현하면 어렵지않게 풀 수 있다.\r\n\r\n1. 약수를 구한다.\r\n   * 약수를 알 필요는 없고, 갯수 정도만 있어도 무방하다.\r\n2. 약수 갯수의 홀짝여부를 비교한다.\r\n   1. 짝수일 경우 가산한다.\r\n   2. 홀수일 경우 감산한다.\r\n3. 누적한 값을 반환한다.\r\n\r\n``` java\r\nprivate int[] measure(int num)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tfor (int i = 1; i <= Math.sqrt(num); i++)\r\n\t{\r\n\t\t// 임의의 수와 나누어 떨어질 경우\r\n\t\tif (num % i == 0)\r\n\t\t{\r\n\t\t\tlist.add(i);\r\n\t\t\t\r\n\t\t\t// num의 제곱근값이 아닐 경우\r\n\t\t\tif (i * i != num)\r\n\t\t\t{\r\n\t\t\t\tlist.add(num / i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn list.stream().sorted().mapToInt(Integer::intValue).toArray();\r\n}\r\n```\r\n\r\n약수를 구하는 알고리즘은 위와 같다. 약수를 구할 땐 대상의 제곱근까지만 확인해도 무방하다.\r\n\r\n예를 들어, 16의 경우 `[ 1, 2, 4, 8, 16 ]`을 가진다. $\\sqrt{16} = 4$이므로 4까지만 비교하여 `[ 1, 2, 4 ]`까지만 구해도 약수의 전체를 알 수 있다.\r\n\r\n16은 `16 / 1`, 8은 `16 / 2`를 통해 유추할 수 있기 때문이다. `i * i != num`일 경우 `num`이 자신의 제곱근을 약수로 갖는 것으로, 다른 수와 달리 `num`과 나누지 않고 `i` 하나만 추가한다. 위 예시에선 4가 그 케이스다.\r\n\r\n<br />\r\n\r\n이후 약수의 갯수를 확인하여 홀짝 여부에 따라 값을 가감하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 약수의 개수와 덧셈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.12 Sun 00:33:56\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param left: [int] 정수 1\r\n\t * @param right: [int] 정수 2\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int left, int right)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = left; i <= right; i++)\r\n\t\t{\r\n\t\t\tint count = measure(i).length;\r\n\t\t\t\r\n\t\t\tanswer += count % 2 == 0 ? i : -i;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 약수 반환 메서드\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t *\r\n\t * @return [int[]] 약수\r\n\t */\r\n\tprivate int[] measure(int num)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int i = 1; i <= Math.sqrt(num); i++)\r\n\t\t{\r\n\t\t\t// 임의의 수와 나누어 떨어질 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\tlist.add(i);\r\n\t\t\t\t\r\n\t\t\t\t// num의 제곱근값이 아닐 경우\r\n\t\t\t\tif (i * i != num)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.add(num / i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().sorted().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0019","2021","12","15","programmers-a0019"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 실패율 (42889)","excerpt":"슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T21:17:08+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0018.md","content":"\r\n# 실패율\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [실패율](https://programmers.co.kr/learn/courses/30/lessons/42889)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.amazonaws.com/files/production/bde471d8ac/48ddf1cc-c4ea-499d-b431-9727ee799191.png)\r\n\r\n슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.\r\n\r\n이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.\r\n\r\n* 실패율은 다음과 같이 정의한다.\r\n  * 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수\r\n\r\n전체 스테이지의 개수 `N`, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 `stages`가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 `solution` 함수를 완성하라.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\r\n* `stages`의 길이는 1 이상 200,000 이하이다.\r\n* `stages`에는 1 이상 `N + 1` 이하의 자연수가 담겨있다.\r\n  * 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.\r\n  * 단, `N + 1` 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.\r\n* 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.\r\n* 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   N   |           stages           |      result       |\r\n| :---: | :------------------------: | :---------------: |\r\n|   5   | { 2, 1, 2, 6, 2, 4, 3, 3 } | { 3, 4, 2, 1, 5 } |\r\n|   4   |     { 4, 4, 4, 4, 4 }      |  { 4, 1, 2, 3 }   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 1 번 스테이지 실패율 : 1/8\r\n\r\n2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.\r\n\r\n* 2 번 스테이지 실패율 : 3/7\r\n\r\n마찬가지로 나머지 스테이지의 실패율은 다음과 같다.\r\n\r\n* 3 번 스테이지 실패율 : 2/4\r\n* 4번 스테이지 실패율 : 1/2\r\n* 5번 스테이지 실패율 : 0/1\r\n\r\n각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.\r\n\r\n* { 3, 4, 2, 1, 5 }\r\n\r\n**입출력 예 #2**\r\n\r\n모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.\r\n\r\n* { 4, 1, 2, 3 }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n각 스테이지의 실패율을 구하는 문제. 해당 스테이지까지 도전한 사람과, 실패한 사람을 구한다. 이 정보로 실패율을 구하여 실패율 순으로 정렬 후, 반환하는 것이 목표다.\r\n\r\n문제 제대로 안 읽으면 해당 스테이지까지 도전한 사람이 아니라, 전체 사람에서 실패율을 나누게 될 수도 있으니 주의할 것.\r\n\r\n1. 각 스테이지에 머무르고 있는 사람의 수를 카운팅\r\n2. 각 스테이지를 플레이한 사람의 수를 카운팅\r\n   * 만약 스테이지 4에 머무르고 있다면, 1 ~ 4의 스테이지를 시도했고, 4 스테이지의 실패율에 반영된다.\r\n   * N + 1 스테이지일 경우, 전부 클리어한 것이므로 모든 스테이지를 시도한 것이다.\r\n3. 각 스테이지에 머무르고 있는 사람 / 각 스테이지를 플레이한 사람 * 100 으로 실패율 계산\r\n4. 실패율 순으로 정렬하여 스테이지의 번호를 반환\r\n   * 만약, 실패율이 동일하다면 스테이지 순으로 정렬\r\n\r\n위와 같은 흐름으로 구성하면 된다.\r\n\r\n<br />\r\n\r\n1번과 2번은 `stages`의 탐색을 통해 어렵지않게 구현할 수 있다. `N`개의 길이를 가진 정수 배열 `fails`, `users`를 생성하여 각각 클리어 실패자와 시도자를 카운팅한다.\r\n\r\n``` java\r\nint[] fails = new int[N];\r\nint[] users = new int[N];\r\n\r\n// 시도자, 실패자 카운트\r\nfor (int stage : stages)\r\n{\r\n\t// 마지막 스테이지를 깨지 않았을 경우\r\n\tif (stage != N + 1)\r\n\t{\r\n\t\t// 실패한 유저 카운트\r\n\t\tfails[stage - 1]++;\r\n\t\t\r\n\t\t// 시도한 유저 카운트\r\n\t\tfor (int i = 0; i < stage; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 마지막 스테이지를 깼을 경우\r\n\telse\r\n\t{\r\n\t\t// 시도한 유저 전부 카운트\r\n\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t{\r\n\t\t\tusers[i]++;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n4 스테이지에 머무르고 있을 경우, 실제론 `fails[3]`에 저장되므로 `fails[stage - 1]`에 반영해야 함에 유의하자.\r\n\r\n<br />\r\n\r\n3번은 단순 연산 정도로 끝나지만, 문제는 4번. 실제로 반환해야하는 건 실패율이 아닌 해당 실패율을 가진 스테이지 번호다.\r\n\r\n정렬도 편하게 할 겸 `ArrayList<Double[]>`을 선언하여 스테이지 번호와 실패율을 배열로 관리한다.\r\n\r\n실패율은 `스테이지 실패 인원 수 / 스테이지 도전 인원 수`로 구할 수 있다. 단, 그 누구도 스테이지에 도달하지 못할 경우, 0으로 나누게 되므로 `isNaN()` 메서드로 반드시 NaN 처리를 해야한다.\r\n\r\n예를 들어, `N = 5`, `[ 1, 2, 2, 3, 4 ]`일 경우가 그렇다. 스테이지 5의 경우 그 누구도 시도조차 하지 못 했으므로 스테이지 실패율은 `0 / 0`. 즉, NaN이 된다. 따라서 이 경우 0으로 바꿔야 한다.\r\n\r\n``` java\r\n// 실패율\r\nArrayList<Double[]> failRate = new ArrayList<>();\r\n\r\n// 실패율에 인덱스와 값 할당\r\nfor (int i = 0; i < N; i++)\r\n{\r\n\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\r\n\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n}\r\n```\r\n\r\n`failRate`에 스테이지 번호와 실패율이 담긴 배열을 저장하면 된다.\r\n\r\n<br />\r\n\r\n``` java\r\n// 정렬\r\nfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n```\r\n\r\n정렬은 위와 같다. 원래 `sort()`는 오름차순이므로, 내림차순으로 정렬하도록 별도로 수식을 지정해야한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 실패율 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.11 Sat 02:20:18\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param N: [int] 전체 스테이지 갯수\r\n\t * @param stages: [int[]] 현재 스테이지 번호\r\n\t *\r\n\t * @return [int[]] 실패율이 높은 스테이지\r\n\t */\r\n\tpublic int[] solution(int N, int[] stages)\r\n\t{\r\n\t\tint[] fails = new int[N];\r\n\t\tint[] users = new int[N];\r\n\t\t\r\n\t\t// 시도자, 실패자 카운트\r\n\t\tfor (int stage : stages)\r\n\t\t{\r\n\t\t\t// 마지막 스테이지를 깨지 않았을 경우\r\n\t\t\tif (stage != N + 1)\r\n\t\t\t{\r\n\t\t\t\t// 실패한 유저 카운트\r\n\t\t\t\tfails[stage - 1]++;\r\n\t\t\t\t\r\n\t\t\t\t// 시도한 유저 카운트\r\n\t\t\t\tfor (int i = 0; i < stage; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 스테이지를 깼을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 시도한 유저 전부 카운트\r\n\t\t\t\tfor (int i = 0; i < users.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tusers[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 실패율\r\n\t\tArrayList<Double[]> failRate = new ArrayList<>();\r\n\t\t\r\n\t\t// 실패율에 인덱스와 값 할당\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\t// 시도자, 실패자가 아무도 없을 경우 0을 나누게 되므로 NaN 처리 필요\r\n\t\t\tdouble rate = Double.isNaN((double) fails[i] / users[i]) ? 0 : (double) fails[i] / users[i];\r\n\t\t\t\r\n\t\t\tfailRate.add(new Double[] { (double) i + 1, rate });\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬\r\n\t\tfailRate.sort((o1, o2) -> Double.compare(o2[1], o1[1]));\r\n\t\t\r\n\t\treturn failRate.stream().mapToInt(value -> value[0].intValue()).toArray();\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0018","2021","12","15","programmers-a0018"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 이름이 없는 동물의 아이디 (59039)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:44:37+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0016.md","content":"\r\n# 이름이 없는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 없는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59039)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A368930  |     Dog     | 2014-06-08 13:20:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A368930  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `NAME`이 null인 데이터를 `ANIMAL_ID` 순으로 조회한다. 해당 데이터 중 `ANIMAL_ID`만을 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0016","2021","12","15","programmers-a0016"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 최댓값 구하기 (59415)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:41:43+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0015.md","content":"\r\n# 최댓값 구하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [최댓값 구하기](https://programmers.co.kr/learn/courses/30/lessons/59415)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A399552  |     Dog     | 2013-10-14 15:38:00 |      Normal      |   Jack   |  Neutered Male  |\r\n|  A379998  |     Dog     | 2013-10-23 11:42:00 |      Normal      | Disciple |   Intact Male   |\r\n|  A370852  |     Dog     | 2013-11-03 15:04:00 |      Normal      |  Katie   |  Spayed Female  |\r\n|  A403564  |     Dog     | 2013-11-18 17:03:00 |      Normal      |   Anna   |  Spayed Female  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n|        시간         |\r\n| :-----------------: |\r\n| 2013-11-18 17:03:00 |\r\n\r\n* 컬럼 이름(위 예제에서는 \"시간\")은 일치하지 않아도 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `DATETIME`이 가장 최근인 데이터 중 가장 상위의 데이터 하나만을 조회한다.\r\n\r\nMySQL에서 최상위 데이터 하나만 호출할 땐 `LIMIT 1`을 사용한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT DATETIME FROM ANIMAL_INS ORDER BY DATETIME DESC LIMIT 1;\r\n```","url":["2021-12-15-programmers-a0015","2021","12","15","programmers-a0015"]},{"header":{"title":"[프로그래머스 / MySQL] Level 1 모든 레코드 조회하기 (59034)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:38:22+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0014.md","content":"\r\n# 모든 레코드 조회하기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [모든 레코드 조회하기](https://programmers.co.kr/learn/courses/30/lessons/59034)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |  NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :----: | :-------------: |\r\n|  A349996  |     Cat     | 2018-01-22 14:32:00 |      Normal      | Sugar  |  Neutered Male  |\r\n|  A350276  |     Cat     | 2017-08-13 13:50:00 |      Normal      | Jewel  |  Spayed Female  |\r\n|  A350375  |     Cat     | 2017-03-06 15:01:00 |      Normal      |  Meo   |  Neutered Male  |\r\n|  A352555  |     Dog     | 2014-08-08 04:20:00 |      Normal      | Harley |  Spayed Female  |\r\n\r\n..이하 생략\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `ANIMAL_ID` 순으로 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT * FROM ANIMAL_INS ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0014","2021","12","15","programmers-a0014"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 체육복 (42862)","excerpt":"점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:18:41+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0013.md","content":"\r\n# 체육복\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\r\n\r\n전체 학생의 수 `n`, 체육복을 도난당한 학생들의 번호가 담긴 배열 `lost`, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 `reserve`가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 전체 학생의 수는 2명 이상 30명 이하입니다.\r\n* 체육복을 도난당한 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌의 체육복을 가져온 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\r\n* 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |   lost   |   reserve   | return |\r\n| :---: | :------: | :---------: | :----: |\r\n|   5   | { 2, 4 } | { 1, 3, 5 } |   5    |\r\n|   5   | { 2, 4 } |    { 3 }    |   4    |\r\n|   3   |  { 3 }   |    { 1 }    |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\r\n\r\n**예제 #2**\r\n\r\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n본인 체육복만 가지고 있는 학생, 여벌 체육복을 가진 학생, 체육복을 도난당한 학생 세 가지로 나뉜다. 이 중 체육복을 도난당한 학생은 여벌을 가진 학생으로부터 체육복을 빌릴 수는 있지만, 자신의 앞뒤 학생에게만 빌릴 수 있다는 제한이 있다. 즉, 여벌이 남아도 서로 앞뒤에 위치하지 않는다면 빌려줄 수 없다.\r\n\r\n`lost`와 `reserve`엔 학생 번호가 기록되어 있는데, 이 문제에서는 학생의 순서가 매우 중요하므로 반드시 정렬이 필요하다.\r\n\r\n`clothes` 배열을 선언하여 체육복의 갯수를 카운팅한다.\r\n\r\n``` java\r\n// 여벌 체육복을 가진 학생을 카운팅\r\nfor (int item : reserve)\r\n{\r\n\tclothes[item - 1]++;\r\n}\r\n\r\n// 체육복을 도난당한 학생을 카운팅\r\nfor (int item : lost)\r\n{\r\n\tclothes[item - 1]--;\r\n}\r\n```\r\n\r\n`for`문으로 체육복의 여부를 가감한다. 학생의 번호는 배열의 인덱스 + 1과 동일하게 다루면 된다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 체육복 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 23:38:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 전체 학생 수\r\n\t * @param lost: [int[]] 체육복을 도난당한 학생\r\n\t * @param reserve: [int[]] 체육복 여벌을 가진 학생\r\n\t *\r\n\t * @return [int] 체육 수업을 들을 수 있는 학생의 최대값\r\n\t */\r\n\tpublic int solution(int n, int[] lost, int[] reserve)\r\n\t{\r\n\t\tint[] clothes = new int[n];\r\n\t\t\r\n\t\t// 자신의 앞뒤 사람에게만 빌려줄 수 있으므로 학생 번호 순서가 중요함\r\n\t\tArrays.sort(lost);\r\n\t\tArrays.sort(reserve);\r\n\t\t\r\n\t\t// 여벌 체육복을 가진 학생을 카운팅\r\n\t\tfor (int item : reserve)\r\n\t\t{\r\n\t\t\tclothes[item - 1]++;\r\n\t\t}\r\n\t\t\r\n\t\t// 체육복을 도난당한 학생을 카운팅\r\n\t\tfor (int item : lost)\r\n\t\t{\r\n\t\t\tclothes[item - 1]--;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < clothes.length; i++)\r\n\t\t{\r\n\t\t\t// 도난당한 학생일 경우\r\n\t\t\tif (clothes[i] == -1)\r\n\t\t\t{\r\n\t\t\t\t// 첫 학생이 아니고, 앞 학생이 여벌을 가질 경우\r\n\t\t\t\tif (i != 0 && clothes[i - 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i - 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 마지막 학생이 아니고, 뒷 학생이 여벌을 가질 경우\r\n\t\t\t\telse if (i != clothes.length - 1 && clothes[i + 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i + 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Arrays.stream(clothes).filter(value -> value > -1).toArray().length;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0013","2021","12","14","programmers-a0013"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 모의고사 (42840)","excerpt":"수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ... 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ... 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ... 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:02:01+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0012.md","content":"\r\n# 모의고사\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\r\n\r\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r\n\r\n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r\n\r\n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r\n\r\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 `answers`가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 시험은 최대 10,000 문제로 구성되어있습니다.\r\n* 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\r\n* 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      answers      |   return    |\r\n| :---------------: | :---------: |\r\n| { 1, 2, 3, 4, 5 } |    { 1 }    |\r\n| { 1, 3, 2, 4, 2 } | { 1, 2, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n* 수포자 1은 모든 문제를 맞혔습니다.\r\n* 수포자 2는 모든 문제를 틀렸습니다.\r\n* 수포자 3은 모든 문제를 틀렸습니다.\r\n\r\n따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n* 모든 사람이 2문제씩을 맞췄습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n* 1번 수포자 패턴 - `[ 1, 2, 3, 4, 5 ]`\r\n* 2번 수포자 패턴 - `[ 2, 1, 2, 3, 2, 4, 2, 5 ]`\r\n* 3번 수포자 패턴 - `[ 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 ]`\r\n\r\n수포자마다 패턴도 다르고, 길이도 달라서 생각없이 접근할 순 없다. 각 패턴의 길이가 다르므로 인덱스 방식은 적절하지 않다. 패턴을 컨테이너 벨트처럼 순환시켜, 가장 앞 쪽의 숫자를 비교하는 것이 더 효과적일 것이다.\r\n\r\n이를 위해선 각 수포자별로 패턴을 순환시키는 로직이 필요하다. `[ 1, 2, 3, 4, 5 ]` -> `[ 2, 3, 4, 5, 1 ]` 자료구조 중 큐의 특성과 매우 유사하므로, 이 문제는 큐를 적극적으로 활용해볼 생각이다.\r\n\r\n각 패턴을 정의할 큐 `ONE`, `TWO`, `THREE`가 있으며, 아래와 같이 초기화를 수행한다.\r\n\r\n``` java\r\nprivate void initQueue()\r\n{\r\n\tONE.clear();\r\n\tTWO.clear();\r\n\tTHREE.clear();\r\n\t\r\n\tONE.add(1);\r\n\tONE.add(2);\r\n\tONE.add(3);\r\n\tONE.add(4);\r\n\tONE.add(5);\r\n\t\r\n\tTWO.add(2);\r\n\tTWO.add(1);\r\n\tTWO.add(2);\r\n\tTWO.add(3);\r\n\tTWO.add(2);\r\n\tTWO.add(4);\r\n\tTWO.add(2);\r\n\tTWO.add(5);\r\n\t\r\n\tTHREE.add(3);\r\n\tTHREE.add(3);\r\n\tTHREE.add(1);\r\n\tTHREE.add(1);\r\n\tTHREE.add(2);\r\n\tTHREE.add(2);\r\n\tTHREE.add(4);\r\n\tTHREE.add(4);\r\n\tTHREE.add(5);\r\n\tTHREE.add(5);\r\n}\r\n```\r\n\r\n패턴 순서대로 큐에 데이터를 집어넣는다. `poll()` 메서드를 통해 가장 앞에 위치한 데이터를 꺼낼 수 있다. `poll()`의 경우 데이터 호출과 동시에 데이터가 삭제된다.\r\n\r\n정답 비교 후, 사용한 데이터는 다시 큐에 집어넣는다. 이런 구조는 문제의 길이에 관계없이 각 수포자 별로 지속적인 순환이 가능할 것이다.\r\n\r\n``` java\r\nfor (int item : answers)\r\n{\r\n\tint one = Objects.requireNonNull(ONE.poll());\r\n\tint two = Objects.requireNonNull(TWO.poll());\r\n\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\r\n\tcounts[0] += item == one ? 1 : 0;\r\n\tcounts[1] += item == two ? 1 : 0;\r\n\tcounts[2] += item == three ? 1 : 0;\r\n\t\r\n\tONE.add(one);\r\n\tTWO.add(two);\r\n\tTHREE.add(three);\r\n}\r\n```\r\n\r\n정답 비교는 위와 같다. `Objects.requireNonNull`는 `poll()`이 `NullPointerException`을 유발할 가능성이 있으므로, 관련 경고를 제거하기 위한 조치다.\r\n\r\n각 수포자별 큐에서 패턴을 뽑고, 이를 문제의 정답과 비교하여 맞춘 경우 `counts` 배열에 카운팅한다.\r\n\r\n사용한 패턴은 `add` 메서드를 통해 큐에 다시 집어넣는 것을 확인할 수 있다.\r\n\r\n<br />\r\n\r\n점수를 모두 구했다면, 가장 고득점을 구하고, 고득점을 맞은 수포자를 반환하면 된다.\r\n\r\n`counts`에서 가장 큰 값을 구하면 아래와 같다.\r\n\r\n``` java\r\nint max = Arrays.stream(counts).max().getAsInt();\r\n```\r\n\r\n이후 `max`에 해당하는 점수를 받은 모든 인원을 탐색하여 배열로 나타내면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\nimport java.util.Objects;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 모의고사 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:43:26\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final Queue<Integer> ONE = new LinkedList<>();\r\n\tprivate static final Queue<Integer> TWO = new LinkedList<>();\r\n\tprivate static final Queue<Integer> THREE = new LinkedList<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param answers: [int[]] 최고 득점자\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] answers)\r\n\t{\r\n\t\tinitQueue();\r\n\t\t\r\n\t\tint[] counts = { 0, 0, 0 };\r\n\t\t\r\n\t\tfor (int item : answers)\r\n\t\t{\r\n\t\t\tint one = Objects.requireNonNull(ONE.poll());\r\n\t\t\tint two = Objects.requireNonNull(TWO.poll());\r\n\t\t\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\t\t\r\n\t\t\tcounts[0] += item == one ? 1 : 0;\r\n\t\t\tcounts[1] += item == two ? 1 : 0;\r\n\t\t\tcounts[2] += item == three ? 1 : 0;\r\n\t\t\t\r\n\t\t\tONE.add(one);\r\n\t\t\tTWO.add(two);\r\n\t\t\tTHREE.add(three);\r\n\t\t}\r\n\t\t\r\n\t\tint max = Arrays.stream(counts).max().getAsInt();\r\n\t\t\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int i = 0; i < counts.length; i++)\r\n\t\t{\r\n\t\t\t// 최고 점수를 얻었을 경우\r\n\t\t\tif (counts[i] == max)\r\n\t\t\t{\r\n\t\t\t\tlist.add(i + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 큐 초기화 메서드\r\n\t */\r\n\tprivate void initQueue()\r\n\t{\r\n\t\tONE.clear();\r\n\t\tTWO.clear();\r\n\t\tTHREE.clear();\r\n\t\t\r\n\t\tONE.add(1);\r\n\t\tONE.add(2);\r\n\t\tONE.add(3);\r\n\t\tONE.add(4);\r\n\t\tONE.add(5);\r\n\t\t\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(1);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(3);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(4);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(5);\r\n\t\t\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(5);\r\n\t\tTHREE.add(5);\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0012","2021","12","14","programmers-a0012"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 완주하지 못한 선수 (42576)","excerpt":"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T20:33:25+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0010.md","content":"\r\n# 완주하지 못한 선수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\r\n\r\n마라톤에 참여한 선수들의 이름이 담긴 배열 `participant`와 완주한 선수들의 이름이 담긴 배열 `completion`이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\r\n* `completion`의 길이는 `participant`의 길이보다 1 작습니다.\r\n* 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\r\n* 참가자 중에는 동명이인이 있을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                     participant                     |                 completion                 |  return  |\r\n| :-------------------------------------------------: | :----------------------------------------: | :------: |\r\n|              { \"leo\", \"kiki\", \"eden\" }              |             { \"eden\", \"kiki\" }             |  \"leo\"   |\r\n| { \"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\" } | { \"josipa\", \"filipa\", \"marina\", \"nikola\" } | \"vinko\"  |\r\n|       { \"mislav\", \"stanko\", \"mislav\", \"ana\" }       |       { \"stanko\", \"ana\", \"mislav\" }        | \"mislav\" |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #2**\r\n\r\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #3**\r\n\r\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n마라톤 경기에서 완주하지 못한 선수를 구하는 문제. 완주자 `completion`은 참가자 `participant` 보다 반드시 길이가 1 짧다. 즉, 완주자는 무조건 한 명이라는 뜻이다.\r\n\r\n또한 동명이인이 있을 수 있으므로, `HashSet`과 같이 고유값을 저장하는 형식은 적절하지 못하다.\r\n\r\n완주하지 못 한 사람이 한 명이므로, 완주한 사람의 이름과 횟수를 `HashMap`에 카운팅하면 완주한 사람은 물론, 동명이인도 커버할 수 있을 것이다.\r\n\r\n``` java\r\nHashMap<String, Integer> map = new HashMap<>();\r\n\r\nfor (String name : participant)\r\n{\r\n\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n}\r\n\r\nfor (String name : completion)\r\n{\r\n\tmap.put(name, map.get(name) - 1);\r\n}\r\n```\r\n\r\n`String`을 키로, `Integer`를 값으로 받는 `HashMap`을 선언한다. `participant` 요소를 탐색하면서 참가자 이름을 키로 하여 값을 1씩 증가시킨다.\r\n\r\n기본적으로 참가자들은 값 1을 가지지만, nikola라는 동명이인이 있다면, `map`의 nikola는 값 2를 가지게 된다.\r\n\r\n이후 `completion` 요소를 탐색하면서 완주자 이름을 키로 하여 값을 1씩 감소시킨다. 이 과정에서 완주하지 못한 사람은 값이 감소되지 않아 1을 가지게 된다.\r\n\r\n`map`을 탐색하며 값이 1인 키를 찾아 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 완주하지 못한 선수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:13:57\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param participant: [String[]] 참여한 선수\r\n\t * @param completion: [String[]] 완주한 선수\r\n\t *\r\n\t * @return [String] 완주하지 못한 선수 이름\r\n\t */\r\n\tpublic String solution(String[] participant, String[] completion)\r\n\t{\r\n\t\tString answer = \"\";\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\tfor (String name : participant)\r\n\t\t{\r\n\t\t\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : completion)\r\n\t\t{\r\n\t\t\tmap.put(name, map.get(name) - 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String key : map.keySet())\r\n\t\t{\r\n\t\t\t// 값이 하나 이상 있을 경우\r\n\t\t\tif (map.get(key) > 0)\r\n\t\t\t{\r\n\t\t\t\tanswer = key;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0010","2021","12","14","programmers-a0010"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 소수 만들기 (12977)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T19:06:57+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0009.md","content":"\r\n# 소수 만들기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [소수 만들기](https://programmers.co.kr/learn/courses/30/lessons/12977)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 `nums`가 매개변수로 주어질 때, `nums`에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `nums`에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.\r\n* `nums`의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       nums        | result |\r\n| :---------------: | :----: |\r\n|  { 1, 2, 3, 4 }   |   1    |\r\n| { 1, 2, 7, 6, 4 } |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n[1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n[1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n\r\n[1,4,6]을 이용해서 11을 만들 수 있습니다.\r\n\r\n[2,4,7]을 이용해서 13을 만들 수 있습니다.\r\n\r\n[4,6,7]을 이용해서 17을 만들 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n배열에서 임의의 요소 3가지를 선택하여 해당 수의 합이 소수가 되는 경우의 수를 구하는 문제.\r\n\r\n1. 임의의 요소 3가지 선택\r\n2. 요소의 합의 소수 여부 판별\r\n\r\n이 두 로직을 구현하는 것이 알고리즘의 핵심이다.\r\n\r\n보통 조합을 이용하지만, 간단하게 중첩 `for`문을 사용해 구현해보자.\r\n\r\n``` java\r\nfor (int i = 0; i < nums.length; i++)\r\n{\r\n\tfor (int j = i + 1; j < nums.length; j++)\r\n\t{\r\n\t\tfor (int k = j + 1; k < nums.length; k++)\r\n\t\t{\r\n\t\t\tint sum = nums[i] + nums[j] + nums[k];\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n임의의 세 가지 요소는 이와 같이 3중첩 `for`문을 통해 구할 수 있다. `j`, `k`의 인덱스를 유심히 살펴보자. 각 인덱스가 겹치지 않게끔 초기값이 구성되어있다.\r\n\r\n``` java\r\nprivate boolean isPrime(int num)\r\n{\r\n\tfor (int i = 2; i <= Math.sqrt(num); i++)\r\n\t{\r\n\t\t// 나눠 떨어질 경우\r\n\t\tif (num % i == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n```\r\n\r\n소수는 이와 같이 구할 수 있다. 굳이 `Math.sqrt(num)` 까지만 연산히는 이유는, 제곱근 이후로는 연산할 필요가 없다.\r\n\r\n예를 들어, 12의 경우 `1, 2, 3, 4, 6, 12`의 약수를 가지는데, $\\sqrt{12}$는 대략 3이다. 3 이후의 숫자인 4, 6은 각각 2와 3과 곱해져서 12를 만들게 되므로, 제곱근 이전에 나누어 떨어지는 수가 없다면 그 수는 소수라 봐도 무방하다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 소수 만들기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:21:09\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param nums: [int[]] 숫자 배열\r\n\t *\r\n\t * @return [int] 소수가 되는 경우의 수\r\n\t */\r\n\tpublic int solution(int[] nums)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < nums.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = i + 1; j < nums.length; j++)\r\n\t\t\t{\r\n\t\t\t\tfor (int k = j + 1; k < nums.length; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[k];\r\n\t\t\t\t\t\r\n\t\t\t\t\tanswer += isPrime(sum) ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 메서드\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i <= Math.sqrt(num); i++)\r\n\t\t{\r\n\t\t\t// 나눠 떨어질 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0009","2021","12","14","programmers-a0009"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 음양 더하기 (76501)","excerpt":"어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T17:01:15+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0007.md","content":"\r\n# 음양 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [음양 더하기](https://programmers.co.kr/learn/courses/30/lessons/76501)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 `absolutes`와 이 정수들의 부호를 차례대로 담은 불리언 배열 `signs`가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `absolutes`의 길이는 1 이상 1,000 이하입니다.\r\n  * `absolutes`의 모든 수는 각각 1 이상 1,000 이하입니다.\r\n* `signs`의 길이는 `absolutes`의 길이와 같습니다.\r\n  * `signs[i]` 가 참이면 `absolutes[i]` 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  absolutes   |         signs          | result |\r\n| :----------: | :--------------------: | :----: |\r\n| { 4, 7, 12 } | { true, false, true }  |   9    |\r\n| { 1, 2, 3 }  | { false, false, true } |   0    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`signs`가 { true, false, true } 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.\r\n\r\n따라서 세 수의 합인 9를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`signs`가 { false, false, true } 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.\r\n\r\n따라서 세 수의 합인 0을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`absolutes`는 수의 절대값을, `signs`은 수의 부호를 가진다. 인덱스별로 각 요소를 호출하여 `signs`의 값에 따라 `absolutes`를 가감하면 될 것이다.\r\n\r\n`absolutes`와 `signs` 크기는 동일하므로, 어떤 배열을 인덱스로 삼든 상관 없다.\r\n\r\n``` java\r\nfor (int i = 0; i < absolutes.length; i++)\r\n{\r\n\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n}\r\n```\r\n\r\n`signs[i]`의 값에 따라 `absolutes`를 가감하여 `answer`에 누적시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 음양 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:09:32\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param absolutes: [int[]] 정수 절대값 배열\r\n\t * @param signs: [boolean[]] 정수의 부호\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] absolutes, boolean[] signs)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < absolutes.length; i++)\r\n\t\t{\r\n\t\t\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0007","2021","12","14","programmers-a0007"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 K번째수 (42748)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0011.md","content":"\r\n# K번째수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n배열 `array`의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\r\n\r\n예를 들어 `array`가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\r\n\r\n1. `array`의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\r\n2. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\r\n3. 2에서 나온 배열의 3번째 숫자는 5입니다.\r\n\r\n배열 `array`, [i, j, k]를 원소로 가진 2차원 배열 `commands`가 매개변수로 주어질 때, `commands`의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `array`의 길이는 1 이상 100 이하입니다.\r\n* `array`의 각 원소는 1 이상 100 이하입니다.\r\n* `commands`의 길이는 1 이상 50 이하입니다.\r\n* `commands`의 각 원소는 길이가 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          array          |                 commands                  |   return    |\r\n| :---------------------: | :---------------------------------------: | :---------: |\r\n| { 1, 5, 2, 6, 3, 7, 4 } | { { 2, 5, 3 }, { 4, 4, 1 }, { 1, 7, 3 } } | { 5, 6, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. `commands` 요소별로 `i`, `j`, `k`를 구한다.\r\n2. `i`에서 `j`까지 `array`를 자른다.\r\n3. 자른 배열을 정렬한다.\r\n4. 자른 배열의 `k`번 째 요소를 찾는다.\r\n\r\n알고리즘 수행 과정은 위와 같을 것이다.\r\n\r\n``` java\r\nfor (int n = 0; n < answer.length; n++)\r\n{\r\n\tint i = commands[n][0];\r\n\tint j = commands[n][1];\r\n\tint k = commands[n][2];\r\n\t\r\n\tint length = j - i + 1;\r\n\t\r\n\tint[] temp = new int[length];\r\n\t\r\n\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\r\n\tArrays.sort(temp);\r\n\t\r\n\tanswer[n] = temp[--k];\r\n}\r\n```\r\n\r\n`i`, `j`, `k`를 구하고, `i`와 `j` 사이의 거리를 구한다. 해당 길이만큼의 배열을 선언하여 자를 것이다.\r\n\r\n`System.arraycopy()` 메서드를 활용하여 `temp` 배열로 `array`의 원하는 부분만을 잘라서 할당하는 것이 가능하다.\r\n\r\n이후 정렬을 수행하고, `k`번 째 요소를 찾으면 된다. 배열은 0부터 시작하므로 실제 인덱스는 `k - 1`이 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * K번째수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:28:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t * @param commands: [int[][]] 인덱스 배열\r\n\t *\r\n\t * @return [int[]] k번째의 수\r\n\t */\r\n\tpublic int[] solution(int[] array, int[][] commands)\r\n\t{\r\n\t\tint[] answer = new int[commands.length];\r\n\t\t\r\n\t\tfor (int n = 0; n < answer.length; n++)\r\n\t\t{\r\n\t\t\tint i = commands[n][0];\r\n\t\t\tint j = commands[n][1];\r\n\t\t\tint k = commands[n][2];\r\n\t\t\t\r\n\t\t\tint length = j - i + 1;\r\n\t\t\t\r\n\t\t\tint[] temp = new int[length];\r\n\t\t\t\r\n\t\t\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\t\t\r\n\t\t\tArrays.sort(temp);\r\n\t\t\t\r\n\t\t\tanswer[n] = temp[--k];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0011","2021","12","14","programmers-a0011"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 내적 (70128)","excerpt":"길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1] 입니다. (n은 a, b의 길이)","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0008.md","content":"\r\n# 내적\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [내적](https://programmers.co.kr/learn/courses/30/lessons/70128)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n길이가 같은 두 1차원 정수 배열 `a`, `b`가 매개변수로 주어집니다. `a`와 `b`의 내적을 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n이때, `a`와 `b`의 내적은 `a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1]` 입니다. (`n`은 `a`, `b`의 길이)\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `a`, `b`의 길이는 1 이상 1,000 이하입니다.\r\n* `a`, `b`의 모든 수는 -1,000 이상 1,000 이하입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       a        |        b         | result |\r\n| :------------: | :--------------: | :----: |\r\n| { 1, 2, 3, 4 } | { -3, -1, 0, 2 } |   3    |\r\n|  { -1, 0, 1 }  |   { 1, 0, -1 }   |   -2   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`a`와 `b`의 내적은 `1 * (-3) + 2 * (-1) + 3 * 0 + 4 * 2 = 3`입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`a`와 `b`의 내적은 `(-1) * 1 + 0 * 0 + 1 * (-1) = -2`입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n인덱스를 돌면서 `a`, `b` 요소를 곱한뒤 값을 누적시키면 될 것이다. `a`, `b`의 길이가 동일하므로 아무 배열이나 인덱스로 삼아도 된다.\r\n\r\n``` java\r\nfor (int i = 0; i < a.length; i++)\r\n{\r\n\tanswer += a[i] * b[i];\r\n}\r\n```\r\n\r\n위와 같이 각 요소별로 곱한 값을 `answer`에 누적한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 내적 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:17:10\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int[]] 정수 배열\r\n\t * @param b: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] a, int[] b)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t{\r\n\t\t\tanswer += a[i] * b[i];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0008","2021","12","14","programmers-a0008"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 없는 숫자 더하기 (86051)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0006.md","content":"\r\n# 없는 숫자 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [없는 숫자 더하기](https://programmers.co.kr/learn/courses/30/lessons/86051)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n0부터 9까지의 숫자 중 일부가 들어있는 배열 `numbers`가 매개변수로 주어집니다. `numbers`에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `numbers`의 길이 ≤ 9\r\n* 0 ≤ `numbers`의 모든 수 ≤ 9\r\n* `numbers`의 모든 수는 서로 다릅니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          numbers           | result |\r\n| :------------------------: | :----: |\r\n| { 1, 2, 3, 4, 6, 7, 8, 0 } |   14   |\r\n|  { 5, 8, 4, 0, 6, 7, 9 }   |   6    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n5, 9가 `numbers`에 없으므로, 5 + 9 = 14를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n1, 2, 3이 `numbers`에 없으므로, 1 + 2 + 3 = 6을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n0 ~ 9의 숫자가 중복되지 않게 포함된 배열이 있다. 우리는 이 배열에 포함되지 않는 수들의 합을 구하는 것이 목적이다.\r\n\r\n숫자도 한 자리로 제한되어있고, 중복도 없으므로 매우 간단하게 풀 수 있다.\r\n\r\n0 ~ 9의 총 합은 45다. 45에서 `numbers`의 값들을 전부 빼주면 포함되지 않는 수들의 합을 쉽게 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 없는 숫자 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:04:47\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 숫자 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] numbers)\r\n\t{\r\n\t\tint answer = 45;\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\tanswer -= number;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0006","2021","12","14","programmers-a0006"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 크레인 인형뽑기 게임 (64061)","excerpt":"게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. \"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0005.md","content":"\r\n# 크레인 인형뽑기 게임\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [크레인 인형뽑기 게임](https://programmers.co.kr/learn/courses/30/lessons/64061)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\r\n\"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png)\r\n\r\n게임 화면은 \"1 x 1\" 크기의 칸들로 이루어진 \"N x N\" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 \"5 x 5\" 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 \"1 x 1\" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png)\r\n\r\n만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif)\r\n\r\n크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\r\n\r\n게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 `moves`가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `board` 배열은 2차원 배열로 크기는 \"5 x 5\" 이상 \"30 x 30\" 이하입니다.\r\n* `board`의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.\r\n  * 0은 빈 칸을 나타냅니다.\r\n  * 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.\r\n* `moves` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `moves` 배열 각 원소들의 값은 1 이상이며 `board` 배열의 가로 크기 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                                               board                                               |           moves            | result |\r\n| :-----------------------------------------------------------------------------------------------: | :------------------------: | :----: |\r\n| { { 0, 0, 0, 0, 0 }, { 0, 0, 1, 0, 3 }, { 0, 2, 5, 0, 1 }, { 4, 2, 4, 4, 2 }, { 3, 5, 1, 3, 1 } } | { 1, 5, 3, 5, 1, 2, 1, 4 } |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/bb0f59c7-6b72-485a-8302-217fe53ea88f/crane_game_104.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. 인형을 뽑는다. 만약 해당 위치에 인형이 없다면 아무것도 뽑지 않는다.\r\n2. 뽑은 인형을 바구니에 담는다.\r\n3. 방금 뽑은 인형과 마지막으로 뽑았던 인형이 동일하면 삭제한다.\r\n4. 삭제한 인형 갯수를 카운팅한다. (삭제 작업 당 +2)\r\n\r\n삭제 횟수가 아니라 삭제한 인형의 갯수다. 2개씩 삭제됨에 유의.\r\n\r\n크레인을 움직이면서 인형을 하나씩 담는다. 이를 담을 배열이 필요하며, `ArrayList` 같은 가변 배열이 적절해보인다. 가장 최근에 들어온 데이터로 연산하므로, `Stack`의 특성을 적극 활용하고자 한다.\r\n\r\n``` java\r\nfor (int move : moves)\r\n{\r\n\tint j = move - 1;\r\n\t\r\n\tfor (int i = 0; i < board.length; i++)\r\n\t{\r\n\t\t// 인형을 뽑을 경우\r\n\t\tif (board[i][j] > 0)\r\n\t\t{\r\n\t\t\t// 동작\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n인형을 뽑는 동작은 위와 같다. 열 `j`를 기준으로 한 행씩 내려오면서 `board[i][j] > 0`인지 확인한다.\r\n\r\n해당 인형은 `board`에서 제거하고 인형을 스택에 넣는다. 이 때, 스택의 마지막 인형과 뽑은 인형이 같을 경우, 스택의 마지막 인형을 제거하고 삭제한 인형 카운트를 추가한다.\r\n\r\n인형이 서로 다르다면, 삭제하지 않고 인형만 스택에 넣는다.\r\n\r\n<br />\r\n\r\n문제를 보다보면 *\"인형을 일단 다 뽑고 삭제는 마지막에 한꺼번에 하면 되지 않을까?\"*라고 생각하기 쉽지만, 실제로 이렇게 접근하면 더 어렵다.\r\n\r\n나중에 한꺼번에 삭제하게 되면, 인형을 삭제하는 순간 다른 인형이 연결될 가능성이 생기므로, 연결된 인형이 없을 때까지 반복적인 연산이 필요하다.\r\n\r\n예를 들어, `1 3 2 2 3`의 경우 동일하게 붙은 인형인 `2`를 삭제하면 `1 3 3`이 된다. `2`가 삭제되며 `3`이 붙어버리므로 반복적인 연산이 강제된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 크레인 인형뽑기 게임 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 21:40:58\r\n */\r\nclass Solution\r\n{\r\n\tprivate final Stack<Integer> bag = new Stack<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param board: [int[][]] 보드 크기\r\n\t * @param moves: [int[]] 크레인 작동 위치\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[][] board, int[] moves)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int move : moves)\r\n\t\t{\r\n\t\t\tint j = move - 1;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < board.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 인형을 뽑을 경우\r\n\t\t\t\tif (board[i][j] > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 뽑은 인형이 있고, 마지막 인형과 방금 뽑은 인형이 동일할 경우\r\n\t\t\t\t\tif (!bag.isEmpty() && bag.peek() == board[i][j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.pop();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tanswer += 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 아닐 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.push(board[i][j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tboard[i][j] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0005","2021","12","14","programmers-a0005"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 키패드 누르기 (67256)","excerpt":"스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다. 맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T12:46:59+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0004.md","content":"\r\n# 키패드 누르기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [키패드 누르기](https://programmers.co.kr/learn/courses/30/lessons/67256)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)\r\n\r\n이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\r\n맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\r\n\r\n1. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.\r\n2. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.\r\n3. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.\r\n4. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\r\n\t* 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\r\n\r\n순서대로 누를 번호가 담긴 배열 `numbers`, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 `hand`가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `numbers` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `numbers` 배열 원소의 값은 0 이상 9 이하인 정수입니다.\r\n* `hand`는 \"left\" 또는 \"right\" 입니다.\r\n  * \"left\"는 왼손잡이, \"right\"는 오른손잡이를 의미합니다.\r\n* 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|              numbers              |  hand   |    result     |\r\n| :-------------------------------: | :-----: | :-----------: |\r\n| [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] | \"right\" | \"LRLLLRLLRRL\" |\r\n| [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] | \"left\"  | \"LRLLRRLLLRR\" |\r\n|  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]   | \"right\" | \"LLRLLRLLRL\"  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.\r\n\r\n| 왼손 위치 | 오른손 위치 | 눌러야 할 숫자 | 사용한 손 | 설명                                                             |\r\n| :-------: | :---------: | :------------: | :-------: | :--------------------------------------------------------------- |\r\n|     *     |      #      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      #      |       3        |     R     | 3은 오른손으로 누릅니다.                                         |\r\n|     1     |      3      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      3      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      3      |       8        |     L     | 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.      |\r\n|     8     |      3      |       2        |     R     | 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.    |\r\n|     8     |      2      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      2      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      2      |       5        |     R     | 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. |\r\n|     4     |      5      |       9        |     R     | 9는 오른손으로 누릅니다.                                         |\r\n|     4     |      9      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      9      |       -        |     -     |                                                                  |\r\n\r\n따라서 `LRLLLRLLRRL`를 return 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 `LRLLRRLLLRR`이 됩니다.\r\n\r\n**입출력 예 #3**\r\n\r\n오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 `LLRLLRLLRL`이 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1, 4, 7은 왼손, 3, 6, 9는 오른손을 쓰면 되므로 큰 문제는 없지만, 2, 5, 8, 0은 누르려는 숫자와 가장 가까이 위치한 손을 써야한다.\r\n\r\n즉, 번호를 누를 때마다 왼손과 오른손의 위치를 기록하고, 2, 5, 8, 0 중 숫자가 나올 경우, 기록했던 각 손의 위치와 해당 숫자의 거리를 비교하여 계산한다.\r\n\r\n키패드를 구현하기 위해 2차원 배열을 구성한다.\r\n\r\n``` java\r\nprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t{ 1, 2, 3 },\r\n\t\t{ 4, 5, 6 },\r\n\t\t{ 7, 8, 9 },\r\n\t\t{ -2, 0, -1 }\r\n};\r\n\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n```\r\n\r\n키패드의 특수문자 `*`과 `#`은 각각 `-2`, `-1`로 다룬다.\r\n\r\n조건에 초기 각 손의 위치는 왼손 `*`, 오른손 `#`이므로, 초기 위치 또한 `-2`, `-1`로 지정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n키패드의 위치를 계산할 수 있도록 메서드를 구성한다.\r\n\r\n``` java\r\nprivate int[] getPosition(int number)\r\n{\r\n\tint[] pos = new int[] { 0, 0 };\r\n\t\r\n\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t{\r\n\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t{\r\n\t\t\t\tpos[0] = i;\r\n\t\t\t\tpos[1] = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn pos;\r\n}\r\n```\r\n\r\n이중 배열을 탐색하여 입력한 키패드의 번호 `number`와 동일한 값을 가지는 배열의 인덱스를 반환한다.\r\n\r\n예를 들어, 키패드 5의 경우 `(1, 1)`의 위치를 가지며, 키패드 7의 경우 `(2, 0)`의 위치를 가진다.\r\n\r\n키패드 5와 7의 거리는 `|1 - 2| + |1 - 0| = 2`가 됨을 알 수 있다.\r\n\r\n``` java\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n\r\nint[] lPos = getPosition(left);\r\nint[] rPos = getPosition(right);\r\nint[] toPos = getPosition(number);\r\n\r\nint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\nint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\r\n// 왼쪽 엄지가 더 가까울 경우\r\nif (lLength > rLength)\r\n{\r\n\t// 왼손 이동\r\n}\r\n\r\n// 오른쪽 엄지가 더 가까울 경우\r\nelse if (lLength < rLength)\r\n{\r\n\t// 오른손 이동\r\n}\r\n\r\n// 둘 다 동일할 경우\r\nelse\r\n{\r\n\t// 왼손잡이일 경우\r\n\tif (hand.equals(\"left\"))\r\n\t{\r\n\t\t// 왼손 이동\r\n\t}\r\n\t\r\n\t// 오른손잡이일 경우\r\n\telse\r\n\t{\r\n\t\t// 오른손 이동\r\n\t}\r\n}\r\n```\r\n\r\n만약 2, 5, 8, 0 중 하나에 해당하는 키패드가 입력되었을 경우, 위와 같이 구현할 수 있다.\r\n\r\n`lPos`, `rPos`는 왼손, 오른손의 위치이며, `toPos`는 이동해야할 키패드의 위치다.\r\n\r\n이를 통해 각 손과 키패드의 거리인 `lLength`, `rLength`를 계산하여 이를 비교하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 키패드 누르기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 18:58:49\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t\t{ 1, 2, 3 },\r\n\t\t\t{ 4, 5, 6 },\r\n\t\t\t{ 7, 8, 9 },\r\n\t\t\t{ -2, 0, -1 }\r\n\t};\r\n\t\r\n\tprivate int left = -2;\r\n\tprivate int right = -1;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 순서대로 누를 번호\r\n\t * @param hand: [String] 주 손잡이 (left, right)\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int[] numbers, String hand)\r\n\t{\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\t// 왼쪽 번호일 경우\r\n\t\t\tif (number == 1 || number == 4 || number == 7)\r\n\t\t\t{\r\n\t\t\t\tleft = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 오른쪽 번호일 경우\r\n\t\t\telse if (number == 3 || number == 6 || number == 9)\r\n\t\t\t{\r\n\t\t\t\tright = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가운데 번호일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint[] lPos = getPosition(left);\r\n\t\t\t\tint[] rPos = getPosition(right);\r\n\t\t\t\tint[] toPos = getPosition(number);\r\n\t\t\t\t\r\n\t\t\t\tint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\n\t\t\t\tint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\t\t\t\t\r\n\t\t\t\t// 왼쪽 엄지가 더 가까울 경우\r\n\t\t\t\tif (lLength > rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tright = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 오른쪽 엄지가 더 가까울 경우\r\n\t\t\t\telse if (lLength < rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 둘 다 동일할 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// 왼손잡이일 경우\r\n\t\t\t\t\tif (hand.equals(\"left\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 오른손잡이일 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위치 반환 메서드\r\n\t *\r\n\t * @param number: [int] 키\r\n\t *\r\n\t * @return [int[]] 위치\r\n\t */\r\n\tprivate int[] getPosition(int number)\r\n\t{\r\n\t\tint[] pos = new int[] { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t\t{\r\n\t\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t\t{\r\n\t\t\t\t\tpos[0] = i;\r\n\t\t\t\t\tpos[1] = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn pos;\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다.","url":["2021-12-14-programmers-a0004","2021","12","14","programmers-a0004"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 숫자 문자열과 영단어 (81301)","excerpt":"네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T11:21:04+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0003.md","content":"\r\n# 숫자 문자열과 영단어\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [숫자 문자열과 영단어](https://programmers.co.kr/learn/courses/30/lessons/81301)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)\r\n\r\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.\r\n\r\n다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\r\n\r\n* 1478 → `one4seveneight`\r\n* 234567 → `23four5six7`\r\n* 10203 → `1zerotwozero3`\r\n\r\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\r\n\r\n| 숫자  | 영단어 |\r\n| :---: | :----: |\r\n|   0   |  zero  |\r\n|   1   |  one   |\r\n|   2   |  two   |\r\n|   3   | three  |\r\n|   4   |  four  |\r\n|   5   |  five  |\r\n|   6   |  six   |\r\n|   7   | seven  |\r\n|   8   | eight  |\r\n|   9   |  nine  |\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `s`의 길이 ≤ 50\r\n* `s`가 `zero` 또는 `0`으로 시작하는 경우는 주어지지 않습니다.\r\n* return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         s          | result |\r\n| :----------------: | :----: |\r\n|  `one4seveneight`  |  1478  |\r\n|   `23four5six7`    | 234567 |\r\n| `2three45sixseven` | 234567 |\r\n|       `123`        |  123   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #3**\r\n\r\n\"three\"는 3, \"six\"는 6, \"seven\"은 7에 대응되기 때문에 정답은 **입출력 예 #2**와 같은 234567이 됩니다.\r\n\r\n**입출력 예 #2**와 **#3**과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\r\n\r\n**입출력 예 #4**\r\n\r\ns에는 영단어로 바뀐 부분이 없습니다.\r\n\r\n\r\n\r\n### 제한시간 안내\r\n\r\n* 정확성 테스트 : 10초\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자의 영소문자를 전부 숫자로 변경하여, 최종적으로 `int` 형태로 반환하는 알고리즘을 구현해야한다.\r\n\r\n1. 문자열의 텍스트를 전부 숫자로 치환한다.\r\n2. 숫자화된 문자열을 `int`로 형변환한다.\r\n\r\n위 두 과정을 거치면 된다. 여러 방법이 있지만, 이왕 JAVA 쓰는거, `enum` 객체를 활용하여 구현하고자 한다.\r\n\r\n비교적 쉬운 로직에 생소한 패턴을 적용해보는 것도 연습에 도움이 된다.\r\n\r\n``` java\r\nprivate enum Number\r\n{\r\n\tZERO(\"0\"),\r\n\tONE(\"1\"),\r\n\tTWO(\"2\"),\r\n\tTHREE(\"3\"),\r\n\tFOUR(\"4\"),\r\n\tFIVE(\"5\"),\r\n\tSIX(\"6\"),\r\n\tSEVEN(\"7\"),\r\n\tEIGHT(\"8\"),\r\n\tNINE(\"9\");\r\n\t\r\n\tprivate final String num;\r\n\t\r\n\tNumber(String num)\r\n\t{\r\n\t\tthis.num = num;\r\n\t}\r\n\t\r\n\tpublic String getNum()\r\n\t{\r\n\t\treturn num;\r\n\t}\r\n}\r\n```\r\n\r\n`enum`은 위와 같이 설계한다. `Number.ONE.name().toLowerCase()`를 활용하여 `one` 문자열을 얻을 수 있다. 또한 `Number.ONE.getNum()`를 활용하여 이에 `one`에 매칭되는 숫자 `1`을 얻을 수 있다. 이 두 메서드를 활용하여 문자열을 치환한다.\r\n\r\n``` java\r\nfor (Number number : Number.values())\r\n{\r\n\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n}\r\n```\r\n\r\n`Number.values()`로 `Number`의 모든 요소를 배열 형태로 반환받을 수 있다. `for`문을 통해 각 숫자의 영문자에 해당하는 문자를 이에 매칭되는 숫자로 치환한다. `replaceAll`을 활용하여 해당하는 모든 문자들을 치환할 수 있다.\r\n\r\n`int` 변환은 `Integer.parseInt()` 메서드를 활용하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 숫자 문자열과 영단어 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Thu 18:47:19\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\tString answer = s;\r\n\t\t\r\n\t\tfor (Number number : Number.values())\r\n\t\t{\r\n\t\t\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n\t\t}\r\n\t\t\r\n\t\treturn Integer.parseInt(answer);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 숫자 enum\r\n\t */\r\n\tprivate enum Number\r\n\t{\r\n\t\tZERO(\"0\"),\r\n\t\tONE(\"1\"),\r\n\t\tTWO(\"2\"),\r\n\t\tTHREE(\"3\"),\r\n\t\tFOUR(\"4\"),\r\n\t\tFIVE(\"5\"),\r\n\t\tSIX(\"6\"),\r\n\t\tSEVEN(\"7\"),\r\n\t\tEIGHT(\"8\"),\r\n\t\tNINE(\"9\");\r\n\t\t\r\n\t\tprivate final String num;\r\n\t\t\r\n\t\t/**\r\n\t\t * 생성자 메서드\r\n\t\t *\r\n\t\t * @param num: [String] 숫자\r\n\t\t */\r\n\t\tNumber(String num)\r\n\t\t{\r\n\t\t\tthis.num = num;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * 숫자 반환 메서드\r\n\t\t *\r\n\t\t * @return [String] 숫자\r\n\t\t */\r\n\t\tpublic String getNum()\r\n\t\t{\r\n\t\t\treturn num;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`enum`이 싫다면 `Map`이나 배열 같이 친숙한 형태로도 구현할 수 있다.\r\n\r\n예를 들어, `int nums[] = new int[] { \"zero\", \"one\" ... \"nine\" };`과 같은 코드는 배열의 인덱스와 그 값을 통해 동일한 로직을 구성할 수 있다.\r\n\r\n`nums[0] = \"zero\"`이므로, 인덱스와 값을 적절히 사용하여 치환하는 것도 가능하다.","url":["2021-12-14-programmers-a0003","2021","12","14","programmers-a0003"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 신규 아이디 추천 (72410)","excerpt":"카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:11:28+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0002.md","content":"\r\n# 신규 아이디 추천\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.\r\n다음은 카카오 아이디의 규칙입니다.\r\n\r\n* 아이디의 길이는 3자 이상 15자 이하여야 합니다.\r\n* 아이디는 알파벳 소문자, 숫자, 빼기(`-`), 밑줄(`_`), 마침표(`.`) 문자만 사용할 수 있습니다.\r\n* 단, 마침표(`.`)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\r\n\r\n\"네오\"는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\r\n\r\n신규 유저가 입력한 아이디가 `new_id` 라고 한다면,\r\n\r\n* 1단계 `new_id`의 모든 대문자를 대응되는 소문자로 치환합니다.\r\n* 2단계 `new_id`에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\r\n* 3단계 `new_id`에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\r\n* 4단계 `new_id`에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\r\n* 5단계 `new_id`가 빈 문자열이라면, `new_id`에 \"a\"를 대입합니다.\r\n* 6단계 `new_id`의 길이가 16자 이상이면, `new_id`의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.  \r\n  만약 제거 후 마침표(.)가 `new_id`의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\r\n* 7단계 `new_id`의 길이가 2자 이하라면, `new_id`의 마지막 문자를 `new_id`의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\r\n\r\n예를 들어, `new_id` 값이 `...!@BaT#*..y.abcdefghijklm` 라면, 위 7단계를 거치고 나면 `new_id`는 아래와 같이 변경됩니다.\r\n\r\n* 1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다.\r\n  * `...!@BaT#*..y.abcdefghijklm` → `...!@bat#*..y.abcdefghijklm`\r\n\r\n* 2단계 '!', '@', '#', '*' 문자가 제거되었습니다.\r\n  * `...!@bat#*..y.abcdefghijklm` → `...bat..y.abcdefghijklm`\r\n\r\n* 3단계 '...'와 '..' 가 '.'로 바뀌었습니다.\r\n  * `...bat..y.abcdefghijklm` → `.bat.y.abcdefghijklm`\r\n\r\n* 4단계 아이디의 처음에 위치한 '.'가 제거되었습니다.\r\n  * `.bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghi`\r\n\r\n* 7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghi` → `bat.y.abcdefghi`\r\n\r\n따라서 신규 유저가 입력한 `new_id`가 `...!@BaT#*..y.abcdefghijklm`일 때, 네오의 프로그램이 추천하는 새로운 아이디는 `bat.y.abcdefghi` 입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 문제\r\n\r\n신규 유저가 입력한 아이디를 나타내는 `new_id`가 매개변수로 주어질 때, \"네오\"가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n`new_id`는 길이 1 이상 1,000 이하인 문자열입니다.\r\n\r\n`new_id`는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\r\n\r\n`new_id`에 나타날 수 있는 특수문자는 `-_.~!@#$%^&*()=+[{]}:?,<>/` 로 한정됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  no   |            new_id             |      result       |\r\n| :---: | :---------------------------: | :---------------: |\r\n|  예1  | `...!@BaT#*..y.abcdefghijklm` | `bat.y.abcdefghi` |\r\n|  예2  |           `z-+.^.`            |       `z--`       |\r\n|  예3  |             `=.=`             |       `aaa`       |\r\n|  예4  |          `123_.def`           |    `123_.def`     |\r\n|  예5  |      `abcdefghijklmn.p`       | `abcdefghijklmn`  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `z-+.^.` → `z-..`\r\n\r\n3단계 `z-..` → `z-.`\r\n\r\n4단계 `z-.` → `z-`\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `z-` → `z--`\r\n\r\n\r\n**입출력 예 #3**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `=.=` → `.`\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 `.` → `new_id`가 빈 문자열이 되었습니다.\r\n\r\n5단계 ` ` → `a`\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `a` → `aaa`\r\n\r\n\r\n**입출력 예 #4**\r\n\r\n1단계에서 7단계까지 거치는 동안 `new_id`(\"123_.def\")는 변하지 않습니다. 즉, `new_id`가 처음부터 카카오의 아이디 규칙에 맞습니다.\r\n\r\n**입출력 예 #5**\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 변화 없습니다.\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 변화 없습니다.\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 `abcdefghijklmn.p` → `abcdefghijklmn.` → `abcdefghijklmn`\r\n\r\n7단계 변화 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문제에 각 단계별로 수행해야하는 로직이 제시되어 있으므로, 이를 메서드로 구분하여 설계하는 것이 적절해보인다.\r\n\r\n\r\n\r\n\r\n\r\n## 1단계 - 소문자 치환\r\n\r\n입력된 문자열을 소문자로 치환한다.\r\n\r\n``` java\r\nprivate String step1(String new_id)\r\n{\r\n\treturn new_id.toLowerCase();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 2단계 - 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\r\n특정 문자만을 남기고 제외한다. 문자열을 `char[]`로 만들어 `for`문을 통해 비교하여 제거할 수도 있겠지만, 정규식을 활용하면 그보다 더 쉽고 간편하게 구현할 수 있다.\r\n\r\n``` java\r\nprivate String step2(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n}\r\n```\r\n\r\n* `[^]` - `[]` 내부에서 `^`는 부정(NOT)의 의미로 사용됨\r\n* `[a-z]` - 소문자 알파벳\r\n* `[0-9]` - 숫자\r\n\r\n`replaceAll`은 정규식을 사용할 수 있다. 위 정규식을 통해 영소문자, 숫자, 일부 특수문자에 해당하지 않는 숫자를 전부 지워버릴 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 3단계 - 두 개 이상 연속된 마침표(.)를 마침표 하나로 치환\r\n\r\n`...`이나 `....`을 전부 `.` 하나로 변경한다. 이 로직도 마찬가지로 정규식을 통해 쉽게 구현하자.\r\n\r\n``` java\r\nprivate String step3(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n}\r\n```\r\n\r\n* `.{2,}` - 두 개 이상인 마침표\r\n\r\n`replaceAll`을 활용하여 마침표가 두 개 연속으로 이어진 문자열을 마침표 하나로 변경한다.\r\n\r\n\r\n\r\n\r\n\r\n## 4단계 - 마침표가 처음이나 끝에 위치할 경우 제거\r\n\r\n문자열 앞이나 뒤에 마침표가 있을 경우 제거한다.\r\n\r\n``` java\r\nprivate String step4(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n}\r\n```\r\n\r\n* `^` - 문자열의 시작. `[]` 밖에서는 부정(NOT)이 아니다.\r\n* `$` - 문자열의 끝\r\n* `|` - OR 연산\r\n\r\n즉, 문자열 앞의 마침표나 문자열 끝의 마침표를 찾는 정규식이다. `replaceAll`을 활용하여 빈 문자로 치환하자.\r\n\r\n\r\n\r\n\r\n\r\n## 5단계 - 빈 문자열일 경우 a 대입\r\n\r\n문자열이 비었을 경우 `a`를 대입한다. 아닐 경우 그대로 둔다.\r\n\r\n``` java\r\nprivate String step5(String new_id)\r\n{\r\n\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 6단계 - 15자를 넘을 경우, 15자로 제한 후 4단계 적용\r\n\r\n글자수 제한과 동일한 개념이다. 단, 글자수를 자르면서 중간에 위치했던 마침표가 끝에 오게될 수도 있으므로, 4단계를 재젹용하라는 조건이 포함되어있다.\r\n\r\n예를 들어, 아이디 `aaaaaaaaaaaaaa.a`는 16글자로, 15자로 제한되면서 마침표가 끝에 오게 될 것이다.\r\n\r\n``` java\r\nprivate String step6(String new_id)\r\n{\r\n\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n}\r\n```\r\n\r\n`new_id`가 15자가 넘는다면, `substring` 메서드로 앞에서부터 15자까지 자른다. 이후 위에서 구현했던 `step4` 메서드를 호출하면 된다.\r\n\r\n이렇게 단계별로 메서드를 나누면 재사용에 유리하다.\r\n\r\n\r\n\r\n\r\n\r\n## 7단계 - 2자 이하일 경우, 3자가 될 때까지 마지막 글자 이어붙이기\r\n\r\n예를 들어, `ab`일 경우 글자가 3자가 될 때까지 마지막 글자 `b`를 이어붙인다. 결과는 `abb`가 될 것이다.\r\n\r\n``` java\r\nprivate String step7(String new_id)\r\n{\r\n\tint more = 3 - new_id.length();\r\n\t\r\n\t// 필요한 글자가 하나 이상 있을 경우\r\n\tif (more > 0)\r\n\t{\r\n\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(new_id);\r\n\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\treturn new_id;\r\n\t}\r\n}\r\n```\r\n\r\n`more`로 3자가 되기 위해 필요한 자리수를 계산한다. 이후 `charAt`로 마지막 글자를 구한다.\r\n\r\n`repeat` 메서드로 해당 글자를 `more`만큼 반복한 뒤, `new_id`에 붙인다.\r\n\r\n문자열 연결 연산엔 개인적인 선호로 `StringBuilder`를 사용한다. `+`를 사용해도 결과를 도출하는데 지장은 없으니, 편한걸로 사용하면 된다.\r\n\r\n> **문자열 연결 연산(+)과 StringBuilder**  \r\n> JAVA에서 `String` 더하기 연산은 편하지만 상대적으로 메모리 소모가 심하다. `String`이 불변객체이므로, 연산 과정에서 새로운 객체를 생성하고, 해제하게된다.  \r\n> `StringBuilder`를 활용하면 우리가 생각했던대로 문자열을 연결하여 연산하므로 상대적으로 연산에 요구되는 자원이 적어진다.  \r\n> JAVA의 최적화 수준과 컴퓨터의 성능이 좋지 않았던 과거의 문제를 해결하기 위한 것으로, 물론 현재는 JAVA도 많은 최적화가 이루어졌고, 컴퓨터 성능은 수 천배로 좋아졌으니, 너무 연연하지 않아도 될 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 신규 아이디 추천 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.07 Tue 00:47:16\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String new_id)\r\n\t{\r\n\t\tString answer = step1(new_id);\r\n\t\tanswer = step2(answer);\r\n\t\tanswer = step3(answer);\r\n\t\tanswer = step4(answer);\r\n\t\tanswer = step5(answer);\r\n\t\tanswer = step6(answer);\r\n\t\tanswer = step7(answer);\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1단계 결과 반환 메서드\r\n\t * 대문자를 모두 소문자로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 1단계 결과\r\n\t */\r\n\tprivate String step1(String new_id)\r\n\t{\r\n\t\treturn new_id.toLowerCase();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 2단계 결과 반환 메서드\r\n\t * 영문 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 2단계 결과\r\n\t */\r\n\tprivate String step2(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 3단계 결과 반환 메서드\r\n\t * 두번 이상 연속된 마침표 하나로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 3단계 결과\r\n\t */\r\n\tprivate String step3(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 4단계 결과 반환 메서드\r\n\t * 맨 앞이나 뒤에 마침표가 있을 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 4단계 결과\r\n\t */\r\n\tprivate String step4(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 5단계 결과 반환 메서드\r\n\t * 빈 문자열일 경우 a 대입\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 5단계 결과\r\n\t */\r\n\tprivate String step5(String new_id)\r\n\t{\r\n\t\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 6단계 결과 반환 메서드\r\n\t * 16자 이상일 경우, 15자로 제한. 끝에 마침표가 오게 될 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 6단계 결과\r\n\t */\r\n\tprivate String step6(String new_id)\r\n\t{\r\n\t\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 7단계 결과 반환 메서드\r\n\t * 2자 이하일 경우, 길이가 3이 될 때까지 마지막 글자 이어붙이기\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 7단계 결과\r\n\t */\r\n\tprivate String step7(String new_id)\r\n\t{\r\n\t\tint more = 3 - new_id.length();\r\n\t\t\r\n\t\t// 필요한 글자가 하나 이상 있을 경우\r\n\t\tif (more > 0)\r\n\t\t{\r\n\t\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\t\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(new_id);\r\n\t\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\t\r\n\t\t\treturn builder.toString();\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn new_id;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n전체 코드는 위와 같다.\r\n\r\n정규식에 대한 기초적인 이해가 있다면 쉽게 풀 수 있지만, 그렇지 않다면 조금 귀찮은 과정을 거쳐야할 것이다.","url":["2021-12-14-programmers-a0002","2021","12","14","programmers-a0002"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 로또의 최고 순위와 최저 순위 (77484)","excerpt":"로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:10:14+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0001.md","content":"\r\n# 로또의 최고 순위와 최저 순위\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [로또의 최고 순위와 최저 순위](https://programmers.co.kr/learn/courses/30/lessons/77484)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.\r\n\r\n|   순위   |   당첨 내용   |\r\n| :------: | :-----------: |\r\n|    1     | 6개 번호 일치 |\r\n|    2     | 5개 번호 일치 |\r\n|    3     | 4개 번호 일치 |\r\n|    4     | 3개 번호 일치 |\r\n|    5     | 2개 번호 일치 |\r\n| 6 (낙첨) |     그 외     |\r\n\r\n로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.\r\n\r\n알아볼 수 없는 번호를 `0`으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 `44, 1, 0, 0, 31 25`라고 가정해보겠습니다. 당첨 번호 6개가 `31, 10, 45, 1, 6, 19`라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.\r\n\r\n|   당첨 번호    |  31   |  10   |  45   |   1   |   6   |  19   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 |  31   | 0→10  |  44   |   1   |  0→6  |  25   | 4개 번호 일치, 3등 |\r\n| 최저 순위 번호 |  31   | 0→11  |  44   |   1   |  0→7  |  25   | 2개 번호 일치, 5등 |\r\n\r\n* 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.\r\n  * 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.\r\n  * 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.\r\n\r\n민우가 구매한 로또 번호를 담은 배열 `lottos`, 당첨 번호를 담은 배열 `win_nums`가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `lottos`는 길이 6인 정수 배열입니다.\r\n* `lottos`의 모든 원소는 0 이상 45 이하인 정수입니다.\r\n  * 0은 알아볼 수 없는 숫자를 의미합니다.\r\n  * 0을 제외한 다른 숫자들은 `lottos`에 2개 이상 담겨있지 않습니다.\r\n  * `lottos`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n* `win_nums`은 길이 6인 정수 배열입니다.\r\n* `win_nums`의 모든 원소는 1 이상 45 이하인 정수입니다.\r\n  * `win_nums`에는 같은 숫자가 2개 이상 담겨있지 않습니다.\r\n  * `win_nums`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|        lottos         |         win_nums         | result |\r\n| :-------------------: | :----------------------: | :----: |\r\n| [44, 1, 0, 0, 31, 25] |  [31, 10, 45, 1, 6, 19]  | [3, 5] |\r\n|  [0, 0, 0, 0, 0, 0]   | [38, 19, 20, 40, 15, 25] | [1, 6] |\r\n| [45, 4, 35, 20, 3, 9] |  [20, 9, 3, 45, 4, 35]   | [1, 1] |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.\r\n\r\n|   당첨 번호    |  38   |  19   |  20   |  40   |  15   |  25   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 | 0→38  | 0→19  | 0→20  | 0→40  | 0→15  | 0→25  | 6개 번호 일치, 1등 |\r\n| 최저 순위 번호 | 0→21  | 0→22  | 0→23  | 0→24  | 0→26  | 0→27  | 0개 번호 일치, 6등 |\r\n\r\n**입출력 예 #3**\r\n\r\n민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n로또의 일부 번호가 지워져 있으며, 이 경우 가질 수 있는 가장 높은 등수와 낮은 등수를 구하는 문제.\r\n\r\n* **가장 높은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수 + 지워진 번호의 갯수\r\n* **가장 낮은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수\r\n\r\n즉, 정확히 표시된 번호 중 당첨된 번호와 지워진 번호를 구분하는 것이 관건이다. 이후 이 갯수를 연산하여 답을 도출할 수 있을 것이다.\r\n\r\n지워진 번호는 `0`으로 표시되므로, `0`일 경우 지워진 번호로 체크하고, 유효한 번호를 가질 경우 `win_nums`와 비교하여 당첨 여부를 확인한다.\r\n\r\n``` java\r\nfor (int lotto : lottos)\r\n{\r\n\t// 번호를 알아볼 수 있을 경우\r\n\tif (lotto > 0)\r\n\t{\r\n\t\tfor (int win_num : win_nums)\r\n\t\t{\r\n\t\t\t// 당첨된 번호일 경우\r\n\t\t\tif (lotto == win_num)\r\n\t\t\t{\r\n\t\t\t\t// 당첨된 번호 카운팅\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 없을 경우\r\n\telse\r\n\t{\r\n\t\t// 지워진 번호 카운팅\r\n\t}\r\n}\r\n```\r\n\r\n위와 같은 로직으로 구성하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 로또의 최고 순위와 최저 순위 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Mon 23:35:13\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param lottos: [int[]] 로또 번호\r\n\t * @param win_nums: [int[]] 당첨 번호\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] lottos, int[] win_nums)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\tint zeros = 0;\r\n\t\t\r\n\t\tfor (int lotto : lottos)\r\n\t\t{\r\n\t\t\t// 번호를 알아볼 수 있을 경우\r\n\t\t\tif (lotto > 0)\r\n\t\t\t{\r\n\t\t\t\tfor (int win_num : win_nums)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 당첨된 번호일 경우\r\n\t\t\t\t\tif (lotto == win_num)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanswer++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 없을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tzeros++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { prize(answer + zeros), prize(answer) };\r\n\t}\r\n\t\r\n\t/**\r\n\t * 순위 반환 메서드\r\n\t *\r\n\t * @param num: [int] 당첨 갯수\r\n\t *\r\n\t * @return [int] 등수\r\n\t */\r\n\tprivate int prize(int num)\r\n\t{\r\n\t\treturn switch (num)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 6 -> 1;\r\n\t\t\t\t\tcase 5 -> 2;\r\n\t\t\t\t\tcase 4 -> 3;\r\n\t\t\t\t\tcase 3 -> 4;\r\n\t\t\t\t\tcase 2 -> 5;\r\n\t\t\t\t\tdefault -> 6;\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다. 당첨된 번호를 `answer`에 카운팅하고, 지워진 번호를 `zeros`에 카운팅한다.\r\n\r\n이후 가장 높은 등수 `answer + zeros`, 가장 낮은 등수 `answer`를 계산하여 배열로 반환한다.\r\n\r\n등수는 `prize` 메서드를 사용하여 얻는다.","url":["2021-12-14-programmers-a0001","2021","12","14","programmers-a0001"]}],"data":{"header":{"title":"[프로그래머스 / JAVA] Level 1 폰켓몬 (1845)","excerpt":"당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T02:01:09+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0017.md","content":"<h1 id=\"폰켓몬\">폰켓몬 <a href=\"#폰켓몬\">🔗</a></h1>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">랭크</th>\n<th align=\"center\">사용 언어</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">Level 1</td>\n<td align=\"center\"><img src=\"https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange\" alt=\"JAVA\"></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>🔗 <a href=\"https://programmers.co.kr/learn/courses/30/lessons/1845\" target=\"_blank\">폰켓몬</a></p>\n<h2 id=\"문제-설명\">문제 설명 <a href=\"#문제-설명\">🔗</a></h2><p>당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.\n홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.</p>\n<ol>\n<li>첫 번째(3번), 두 번째(1번) 폰켓몬을 선택</li>\n<li>첫 번째(3번), 세 번째(2번) 폰켓몬을 선택</li>\n<li>첫 번째(3번), 네 번째(3번) 폰켓몬을 선택</li>\n<li>두 번째(1번), 세 번째(2번) 폰켓몬을 선택</li>\n<li>두 번째(1번), 네 번째(3번) 폰켓몬을 선택</li>\n<li>세 번째(2번), 네 번째(3번) 폰켓몬을 선택</li>\n</ol>\n<p>이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.</p>\n<p>당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 <code class=\"inline-code\">nums</code>가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 <code class=\"inline-code\">solution</code> 함수를 완성해주세요.</p>\n<h2 id=\"제한사항\">제한사항 <a href=\"#제한사항\">🔗</a></h2><ul>\n<li><code class=\"inline-code\">nums</code>는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.</li>\n<li><code class=\"inline-code\">nums</code>의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.</li>\n<li>폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.</li>\n<li>가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.</li>\n</ul>\n<h2 id=\"입출력-예\">입출력 예 <a href=\"#입출력-예\">🔗</a></h2>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">nums</th>\n<th align=\"center\">result</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">{ 3, 1, 2, 3 }</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">{ 3, 3, 3, 2, 2, 4 }</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">{ 3, 3, 3, 2, 2, 2 }</td>\n<td align=\"center\">2</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<h3 id=\"입출력-예 설명\">입출력 예 설명 <a href=\"#입출력-예 설명\">🔗</a></h3><p><strong>입출력 예 #1</strong></p>\n<p>문제의 예시와 같습니다.</p>\n<p><strong>입출력 예 #2</strong></p>\n<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.</p>\n<p><strong>입출력 예 #3</strong></p>\n<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.</p>\n<h1 id=\"풀이\">풀이 <a href=\"#풀이\">🔗</a></h1><p>N개의 폰켓몬 중 그 절반인 N / 2개의 폰켓몬을 가져갈 수 있다. N개 중 N / 2의 폰켓몬을 고르는 경우의 수 중에서 가장 많은 종류의 폰켓몬을 선택했을 때, 폰켓몬 종류 갯수를 요구하는 알고리즘이다.</p>\n<p>얼핏 보면 복잡해보일 수 있으나, 조금만 생각해보면 매우 간단하게 풀 수 있는 문제다.</p>\n<p>서로 다른 종류의 폰켓몬 N개가 있을 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 N / 2다.</p>\n<p>반면, N개의 폰켓몬이 있고, 종류는 고작 두가지일 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 2가 한계다.</p>\n<p>즉, 폰켓몬 배열 <code class=\"inline-code\">nums</code>에서 폰켓몬의 종류와 <code class=\"inline-code\">nums.length / 2</code> 중 더 작은 값을 반환하면 된다.</p>\n<ul>\n<li>[1, 2, 3, 4, 5, 1] - 종류는 5개, N / 2는 3이므로, 가져갈 수 있는 최대 종류는 3개</li>\n<li>[1, 1, 1, 1, 2, 2, 3, 3] - 종류는 3개, N / 2는 4이므로, 가져갈 수 있는 최대 종류는 3개</li>\n</ul>\n<p>폰켓몬의 종류를 구하기 위해 고유값만을 저장하는 <code class=\"inline-code\">HashSet</code>을 활용하는 것이 적절해보인다.</p>\n<p><code class=\"inline-code\">HashSet</code>에 폰켓몬을 삽입하여 종류의 갯수를 얻어내고, 배열의 길이 / 2와 비교하여 더 작은 값을 반환하자.</p>\n<h2 id=\"코드\">코드 <a href=\"#코드\">🔗</a></h2>\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 폰켓몬 클래스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.12.11 Sat 01:56:08</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 해답 반환 메서드</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param nums: [int[]] 폰켓몬 종류 배열</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @return [int] 폰켓몬 종류 갯수</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>        <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>        </td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>            set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23>        </td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t","url":["2021-12-15-programmers-a0017","2021","12","15","programmers-a0017"],"toc":[{"text":"폰켓몬","tag":"폰켓몬","depth":1},{"text":"문제 설명","tag":"문제-설명","depth":2},{"text":"제한사항","tag":"제한사항","depth":2},{"text":"입출력 예","tag":"입출력-예","depth":2},{"text":"입출력 예 설명","tag":"입출력-예 설명","depth":3},{"text":"풀이","tag":"풀이","depth":1},{"text":"코드","tag":"코드","depth":2}]},"hash":"1edbd4e5eb6"},"__N_SSG":true}