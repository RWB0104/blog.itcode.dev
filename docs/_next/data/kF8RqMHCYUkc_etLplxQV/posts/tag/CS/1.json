{"pageProps":{"posts":[{"header":{"title":"[SSL] Windows 10에서 Let's Encrypt로 SSL 인증서 무료 발급받기","excerpt":"SSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다. 이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-20T00:35:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","Tomcat(톰캣)"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-20-apply-ssl.md","content":"\r\n# 개요\r\n\r\nSSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다.\r\n\r\n이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.\r\n\r\n# Tomcat에 인증서 적용하기\r\n\r\nTomcat에 인증서를 적용한다. Tomcat Native가 설치되어있는지, 없는지에 따라 방법이 다르다.\r\n\r\n> <b class=\"orange-400\">Tomcat Native</b>  \r\n> Tomcat의 성능 향상을 위해 C, JAVA 같은 네이티브 모듈이 추가된다. Windows의 경우 dll 파일 하나만 옮기면 된다.\r\n\r\nTomcat Native가 적용되어 있다면 `pem` 파일을 바로 적용할 수 있으며, 아니라면 `pem`을 `jks`와 같은 호환 가능한 확장자로 적절히 변경해야한다.\r\n\r\n# Tomcat Native 설치방법\r\n\r\nOS에 따라 Tomcat Native를 설치하는 방법이 다르다. Tomcat Native를 설치하지 않고도 SSL을 적용할 수 있으니, 관심이 없다면 이 단계를 패스해도 무방하다.\r\n\r\n## Windows 10\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 Tomcat Native 라이브러리를 다운로드 받는다. 중간에 [Native 1.2.30 Windows Binaries.zip]을 다운로드 받으면 된다.\r\n\r\n압축 풀면 [bin] 폴더에 `tcnative-1.dll` 파일이 있을텐데, 해당 DLL을 `$TOMCAT_HOME/bin`에 옮기는 것으로 설치가 끝난다.\r\n\r\n## Linux(CentOS 7 이상)\r\n\r\n``` bash\r\nyum -y install tomcat-native\r\n```\r\n\r\nCentOS 7을 기준으로 위 명령어를 입력하면 된다. 만약 위와 같은 명령어를 사용할 수 없다면 직접 [이 링크](https://tomcat.apache.org/download-native.cgi)에서 컴파일해서 적용해야한다.\r\n\r\n## Linux(컴파일)\r\n\r\n직접 소스를 컴파일해서 사용한다. <span class=\"pink-400\">CentOS</span>를 기준으로 설명한다.\r\n\r\n``` bash\r\nyum install apr-devel openssl-devel\r\n```\r\n\r\n혹은 <span class=\"pink-400\">Devian</span> 계열일 경우\r\n\r\n``` bash\r\napt-get install libapr1.0-dev libssl-dev\r\n```\r\n\r\n컴파일 이전에 위 도구들이 설치되어있어야 한다.\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 [Native 1.2.30 Source Release tar.gz]를 다운로드 받아 압축을 푼다.\r\n\r\n``` bash\r\ntar -zxvf Native 1.2.30 Source Release tar.gz\r\n```\r\n\r\n압축은 위 명령어로 해제하면 되며, OS에 따라 명령어가 다를 수 있다.\r\n\r\n``` bash\r\ncd ${압축 해제 경로}\r\n./configure --with-apr=/usr --prefix=${현재경로} --with-java-home=${JAVA_HOME}\r\nmake\r\nmake install\r\n```\r\n\r\n위 명령어를 순차적으로 입력해주면 된다.\r\n\r\n# SSL 인증서 적용하기\r\n\r\nSSL 인증서를 적용하자. <span class=\"orange-400\">Tomcat Native</span> 적용 여부에 따라 방법이 다르다.\r\n\r\n## Tomcat Native로 PEM 파일 적용하기\r\n\r\n`$TOMCAT/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tSSLCertificateFile=\"example.com-crt.pem\"\r\n\tSSLCertificateKeyFile=\"example.com-key.pem\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n위와 같이 수정해주면 된다. `SSLCertificateFile`에 `crt.pem` 파일을, `SSLCertificateKeyFile`에 `key.pem` 파일 경로를 지정한다.\r\n\r\n## 일반 Tomcat에 PEM to JKS로 변환하여 적용하기\r\n\r\n어떠한 이유로든 Tomcat Native를 설치하지 못 할 경우, <span class=\"red-400\">일반 Tomcat은 PEM 파일을 인식할 수가 없다.</span> 따라서 Tomcat이 지원하는 포맷으로 변환하여 사용해야한다. 이 문서에선 `.jks` 파일으로 변환하여 적용한다.\r\n\r\n준비물은 아래와 같다.\r\n\r\n* OpenSSL\r\n* keytool (JAVA 깔면 있음)\r\n\r\n[OpenSSL](https://www.openssl.org/source/)은 직접 설치해야하고, <span class=\"orange-400\">keytool</span>은 `$JAVA_HOME/bin`에 있으므로 JAVA가 있다면 따로 설치하지 않아도 된다.\r\n\r\n``` batch\r\n# pem to p12\r\nopenssl pkcs12 -export -out {name}.p12 -in {crt}.pem -inkey {key}.pem\r\n\r\n# p12 to jks\r\nkeytool -importkeystore -srckeystore {name}.p12 -srcstoretype pkcs12 -destkeystore {name}.jks -deststoretype jks\r\n```\r\n\r\n위 명령어를 순서대로 입력하면 된다. <span class=\"red-400\">변환 과정에서 인증서에 저장할 비밀번호를 요구한다. 추후 웹서버에 해당 비밀번호를 제공</span>해야하니, 잘 기억해두자.\r\n\r\n4개였던 `.pem`파일과 달리 `.jks`는 심플하게 하나만 생성된다. 생성이 완료되면 `$TOMCAT/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tkeystoreFile=\"example.com.jks\"\r\n\tkeystorePass=\"비밀번호\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n`keystoreFile`에 생성한 `.jks` 파일을, `keystorePass`에 변환 과정에서 입력한 비밀번호를 입력한다.\r\n\r\n# 확인\r\n\r\n본 문서에선 SSL 포트를 `443`으로 설정했다. SSL의 기본 포트는 443이므로, 별도의 포트 표시를 하지 않아도 자동으로 연결될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130097706-8a3cc174-e35d-46db-9f60-caa585a59d98.png)\r\n\r\n이제 톰캣을 기동하여, 도메인에 접속해보자. 인증서 정보가 확인되면 성공이다.\r\n\r\n참고로, 인증서는 도메인을 기준으로 동작한다. 만약 `localhost` 내지는 `127.0.0.1`, IP를 입력하여 들어오면 인증서 오류가 뜨니 참고할 것.\r\n\r\n# 정리\r\n\r\n이로써 SSL 적용이 완료됐다. 처음엔 뭔가 복잡해보여도, 한 번 해두면 크게 어려운 부분은 없다.\r\n\r\nLet's Encrypt는 DV 인증서를 무료로 받을 수 있는 가장 쉽고 빠른 방법이므로, SSL이 필요하다면 적극적으로 활용해보자.","url":["2021-08-20-apply-ssl","2021","08","20","apply-ssl"]},{"header":{"title":"[SSL] Tomcat에 SSL 적용하기","excerpt":"도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다. 테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-19T23:37:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-19-lets-encrypt.md","content":"\r\n# 개요\r\n\r\n도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다.\r\n\r\n테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.\r\n\r\n하지만 무료 답게 제약사항이 존재하기도 한다. 유효기간이 매우 짧다던가, 등록할 수 있는 도메인에 한계가 있다던가, 하지만 <span class=\"green-600\">Let's Encrypt</span>를 활용하면 별다른 제약 없이 SSL을 발급받을 수 있다. 이전에 설명했던 <span class=\"lightBlue-600\">Freenom</span>과 달리, 이쪽은 실서버에 적용해도 아무런 문제없이 사용할 수 있다. 덕분에 소규모 사이트의 인증서를 잘 살펴보면 심심치않게 발급기관이 <span class=\"green-600\">Let's Encrypt</span>임을 확인할 수 있다.\r\n\r\n# Let's Encrypt!\r\n\r\n<span class=\"green-600\">Let's Encrypt</span>를 통해 SSL을 발급받아보자. 환경은 아래와 같다. <span class=\"blue-600\">Windows 10</span>을 기준으로 진행한다.\r\n\r\n사실 Let's Encrypt는 SSL을 발급해주는 기관으로, Let's Encrypt에서 회원가입하고 뭐 제출하고 이런 방식이 아니다. Let's Encrypt와 통신하여 SSL을 발급해주는 프로그램들이 많이 있으니 이걸 다운로드 받으면 된다.\r\n\r\n[지원하는 프로그램 목록](https://letsencrypt.org/ko/docs/client-options/)을 확인해보자. 그 중 우리는 Windows 10용으로 빌드된 <span class=\"primary\">win-acme</span>를 사용한다.\r\n\r\n필요한 준비물은 아래와 같다.\r\n\r\n* Windows 10\r\n* 자신의 아이피와 연결된 도메인\r\n* 80포트가 접속 가능한 네트워크 환경\r\n  * 불가능하다면 DNS 설정이 가능함\r\n* WAS (여기선 Tomcat을 사용)\r\n\r\n위 준비물이 없으면 SSL 발급을 진행하기 어렵다.\r\n\r\n## 1. win-acme 다운로드\r\n\r\n아래의 사이트에서 win-acme를 다운로드 받는다.\r\n\r\n<br />\r\n\r\n<p align=\"center\"><a href=\"https://www.win-acme.com/\" target=\"_blank\">다운로드</a></p>\r\n\r\n<br />\r\n\r\n압축을 해제한다. `wacs.exe`를 실행하면 아래와 같은 창이 뜰 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130079131-3eb9c5de-c1bc-4919-a921-e4c7c7f28a3d.png)\r\n\r\n## 2. 발급 방법 선택\r\n\r\n명령어를 입력하여 발급을 진행할 것이다.\r\n\r\n* <span class=\"green-300\">Create certificate (default settings)</span>: 기본 옵션으로 SSL 발급 (N)\r\n* <span class=\"green-600\">Create certificate (full settings)</span>: 직접 옵션을 선택하여 SSL 발급 (M)\r\n* <span class=\"green-300\">Run renewals</span>: 갱신 (R)\r\n* <span class=\"green-300\">Manage renewals</span>: 갱신 관리 (A)\r\n* <span class=\"green-300\">More options...</span>: 더 많은 옵션 (O)\r\n* <span class=\"green-300\">Quit</span>: 종료 (Q)\r\n\r\n[M]을 입력하여 직접 옵션을 선택하여 SSL을 발급한다. 대소문자는 따로 구분하지 않으니 그냥 입력해도 된다.\r\n\r\n## 3. 도메인 입력 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080688-2bbbc350-399a-4bc3-b619-732d4b25ae58.png)\r\n\r\n* <span class=\"grey-600\">Read site bindings from IIS</span>: IIS에서 바인딩 (1)\r\n* <span class=\"green-600\">Manual input</span>: 직접 입력 (2)\r\n* <span class=\"green-300\">CSR created by another program</span>: 다른 프로그램에서 만든 CSR (3)\r\n* <span class=\"green-300\">Abort</span>: 중단 (C)\r\n\r\n우리는 [2]를 입력하여 직접 도메인을 입력한다.\r\n\r\n## 4. 도메인 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080746-f57c8f5f-6243-4c9d-b5ca-a6859fcb30ec.png)\r\n\r\n인증받을 도메인을 입력한다. 다수의 도메인을 하나의 인증서로 만들 수도 있으며, 이 경우 쉼표(,)로 구분하면 된다.\r\n\r\n``` batch\r\nexample.com\r\n```\r\n\r\n하나의 도메인을 인증받는다면 위와 같이 입력한다.\r\n\r\n``` batch\r\nexample.com,www.example.com,admin.example.com\r\n```\r\n\r\n여러 도메인을 인증받는다면 위와 같이 쉼표로 구분하여 입력한다.\r\n\r\n입력한 모든 도메인이 인증되어야하니 참고할 것. 도메인을 입력하면 도메인에 대한 별칭을 입력하라고 하는데, 그냥 아무것도 입력하지 말고 [Enter] 눌러서 다음으로 넘어가자.\r\n\r\n## 5. 인증 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130081483-11eef349-d3e7-4e81-9498-67355eb2632f.png)\r\n\r\n* <span class=\"green-600\">Save verification files on (network) path</span>: 네트워크 경로에 인증 파일 저장 (1)\r\n* <span class=\"grey-600\">Serve verification files from memory</span>: 메모리에 인증 파일 저장 (2)\r\n* <span class=\"green-300\">Upload verification files via FTP(S)</span>: FTP를 통한 인증 파일 업로드 (3)\r\n* <span class=\"green-300\">Upload verification files via SSH-FTP</span>: SSH-FTP를 통한 인증 파일 업로드 (4)\r\n* <span class=\"green-300\">Upload verification files via WebDav</span>: WebDav를 통한 인증 파일 업로드 (5)\r\n* <span class=\"green-300\">Create verification records manually (auto-renew not possible)</span>: 수동으로 인증 레코드 생성 (자동 갱신 불가능) (6)\r\n* <span class=\"green-300\">Create verification records acme-dns</span>: acme-dns를 통한 인증 레코드 생성 (7)\r\n* <span class=\"green-300\">Create verification records with your own script</span>: 본인 소유의 스크립트를 통해 인증 레코드 생성 (8)\r\n* <span class=\"grey-600\">Answer TLS verification request from win-acme</span>: win-acme의 TLS 인증요청 응답 (9)\r\n\r\n1번은 이후 입력할 웹루트 경로에 인증파일을 생성해주고, 3 ~ 5번은 제공해주는 파일을 직접 업로드한다. 6 ~ 8번은 DNS 레코드 설정이 필요하다.\r\n\r\n통상 1번이 가장 쉬우니, 본 문서에는 1번으로 진행한다.\r\n\r\n## 6. 웹루트 경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130083363-c4e34aeb-6041-4895-9e4c-71085514f51f.png)\r\n\r\n웹루트 경로를 입력한다. 예를 들어, `https://example.com` 도메인이 있다면, 이 도메인의 파일들이 위치한 경로를 입력해야한다.\r\n\r\n만약 순정 <span class=\"amber-400\">Tomcat</span>이라면 `$TOMCAT_HOME/webapps/ROOT`가 될 것이다.\r\n\r\n환경마다 다르니, 적절히 입력해주면 된다. 이 때 반드시 <span class=\"red-600\">80포트로 접속이 가능해야함에 주의</span>한다.\r\n\r\n만약 80포트 사용이 불가능하다면 DNS 설정으로 인증하는 6 ~ 8번을 시도하자. 이메일 인증은 지원하지 않는다.\r\n\r\n웹 설정을 복사할거냐고 물어보는데, 하지말자.\r\n\r\n## 7. CSR 유형 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084201-636a0f36-ac1a-4aaa-b17d-948248b2600c.png)\r\n\r\n* <span class=\"green-300\">Elliptic Curve key</span>: 타원곡선 암호화 (1)\r\n* <span class=\"green-600\">RSA Key</span>: 비대칭 암호화 (2)\r\n\r\n[2]를 선택한다.\r\n\r\n## 8. 인증서 저장 방식 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084595-c96c3c33-ddde-4b95-b395-5e073d6b4eba.png)\r\n\r\n* <span class=\"green-300\">IIS Central Certificate Store</span>: IIS용 인증서 (.pfx) (1)\r\n* <span class=\"green-600\">PEM encoded files</span>: 아파치 계열용 인증서 (.pem) (2)\r\n* <span class=\"green-300\">PFX archive</span>: .pfx 파일 (3)\r\n* <span class=\"grey-600\">Windows Certificate Store</span>: 윈도우 인증서 저장소 (4)\r\n* <span class=\"green-300\">No (additional) store steps</span>: (추가적인) 인증서 미저장 (2)\r\n\r\n본 문서에선 Tomcat을 기준으로 설명하므로 [2]를 선택한다.\r\n\r\n## 9. 저장경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085226-7f89895e-ad04-4851-9b6f-5922eb749f36.png)\r\n\r\n원하는 저장경로를 입력한다. 편한 경로로 입력하자.\r\n\r\n## 10. 키파일 암호 입력 방식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085398-cc5e9c1e-6b1c-4b20-ba3d-d62caf3b02e3.png)\r\n\r\n* <span class=\"green-300\">None</span>: 안 함 (1)\r\n* <span class=\"green-600\">Type/paste in console</span>: 콘솔에서 입력/붙여넣기 (2)\r\n* <span class=\"green-300\">Search in vault</span>: vault에서 검색 (3)\r\n\r\n[2]를 선택한다.\r\n\r\n원하는 비밀번호를 입력한다. 입력하면 해당 비밀번호를 추후 사용하도록 valut에 저장할 것이냐고 묻는다. 원하는대로 하자.\r\n\r\n저장하게 되면 아마 [3]을 통해 이전의 암호를 사용할 수 있을 것 같다.\r\n\r\n## 11. 추가 인증서 저장 방식 선택\r\n\r\n8번과 같은 과정. 추가로 다른 확장자의 인증서가 필요하면 더 하면 된다.\r\n\r\n이 문서에선 필요 없으므로, [5]를 눌러 더 생성하지 않고 넘어간다.\r\n\r\n## 12. 추가 옵션\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086251-6744a758-1f4a-44b3-9bc1-ed260fac4d67.png)\r\n\r\n* <span class=\"grey-300\">Create or update https bindings in IIS</span>: IIS에 HTTPS 바인딩 생성 혹은 갱신 (1)\r\n* <span class=\"grey-300\">Create or update ftps bindings in IIS</span>: IIS에 FTPS(보안 FTP) 바인딩 생성 혹은 갱신 (2)\r\n* <span class=\"green-300\">Start external scripts or program</span>: 외부 스크립트 실행 (3)\r\n* <span class=\"green-600\"></span>: 추가적인 설치 과정 없음 (4)\r\n\r\n[4] 별도로 할게 없으므로 넘어가자.\r\n\r\n## 13. 도메인 인증\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086813-01c8e143-e2dd-4b3b-ad41-d89292d07607.png)\r\n\r\n아까 입력했던 도메인에 대한 인증을 수행한다. 도메인의 유효성만 검증하므로 DV 인증서라고 할 수 있다.\r\n\r\n아까 입력했던 웹루트에 `.well-known` 폴더가 생성됐을 것이다.\r\n\r\n`http://www.kapoo.ga/.well-known/{hash}/{file}`로 접근해서 실제 자신이 랜덤으로 생성한 파일의 정보와 일치한지 확인한다. 맞다면 해당 도메인이 유효하다고 판단한다.\r\n\r\n나중에 특정 작업 수행할 거냐고 물어보는 대답엔 아니라고 하자.\r\n\r\n## 14. 인증서 확인\r\n\r\n9번 과정에서 입력한 저장 경로로 가보면 `pem` 파일이 생성되었을 것이다.\r\n\r\n* example.com-chain.pem: 서명과 CA 중간 인증서를 통합한 인증서\r\n* example.com-chain-only.pem: CA의 중간 인증서\r\n* example.com-crt.pem: 서명된 인증서\r\n* example.com-key.pem: 인증서 개인키\r\n\r\n위 네 파일이 생성되면 정상적으로 SSL을 발급받은 것이다. 이를 웹서버, WAS 등에 적용하면 된다.\r\n\r\n# 정리\r\n\r\nLet's Encrypt를 통해 SSL을 무료로 발급받았다. 무료지만 무려 1년의 유효기간을 가지며, 발급 시 자동갱신 스크립트도 자동으로 추가된다.\r\n\r\n무료임에도 불구하고 환경만 잘 구축해두면, SSL은 거의 신경쓰지 않아도 된다. 이러한 편의성 때문에 무료임에도 많은 곳에서 Let's Encrypt를 사용한다.\r\n\r\n다음 장에서는 이 인증서를 직접 Tomcat에 적용해본다.","url":["2021-08-19-lets-encrypt","2021","08","19","lets-encrypt"]},{"header":{"title":"[SSL] Freenom을 활용한 무료 도메인 발급하기","excerpt":"이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다. SSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다. 위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다. 이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다. TLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T23:44:43","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","도메인"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-freenom-domain.md","content":"\r\n# 개요\r\n\r\n이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다.\r\n\r\nSSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다.\r\n\r\n* [가비아](https://www.gabia.com/)\r\n* [후이즈](https://whois.co.kr/)\r\n* [카페24](https://www.cafe24.com/)\r\n\r\n위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다.\r\n\r\n이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다.\r\n\r\nTLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.\r\n\r\n> **TLD?**  \r\n> com, net과 같이 URL 마지막에 오는 최상위도메인을 뜻한다. TLD에 대한 내용은 이전에 작성한 게시글 <a href=\"/2021/05/29/uri-url-urn#TLD(Top-Level Domain, 최상위 도메인)\">URI? URL? URN? 리소스 식별자 구분하기</a>에서 확인 가능하다.\r\n\r\n# Freenom으로 무료 도메인 받기\r\n\r\n물론 위 방법으로 도메인을 발급받아도 좋지만, 여기엔 돈이 든다. 만약 본인이 실제 웹을 배포할 생각이라면 당연히 도메인을 구입하는 게 맞다.\r\n\r\n하지만 도메인 연결, SSL 적용 등 단순 테스트 목적이라면 적은 비용이라도 좀 아깝다는 생각이 들게 된다.\r\n\r\n다행히 [Freenom](https://www.freenom.com/)에서 무료 도메인을 발급해주니, 단순 테스트 목적으로 부담없이 사용할 수 있다.\r\n\r\n## 주의사항\r\n\r\nFrenom을 사용하는 데 몇 가지 주의사항이 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">1. 사용 가능한 TLD가 제한적임</p>\r\n\r\n주로 사용하는 TLD는 `com`, `net` 등이 있지만, Freenom은 `ga`, `ml` 등 특정한 ccTLD만 지원한다.\r\n\r\n* `tk (Tokelau)`: 뉴질랜드령 토켈라우제도\r\n* `ml (Mali)`: 말리\r\n* `ga (Gabon)`: 가봉\r\n* `gq (Equatorial Guinea)`: 적도 기니\r\n* `cf (Central African Republic)`: 중앙아프리카 공화국\r\n\r\n대중적인 TLD를 선택할 순 없지만, 무료이니 감안하자. 어차피 후술할 이유로 실제 서비스에 적용하기엔 무리가 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">2. 연장 시기를 놓치면 유료화</p>\r\n\r\n발급받은 도메인은 최대 1년 단위로 연장해야한다. 연장은 만료일로부터 2주 안에 신청이 가능하다.\r\n\r\n연장하는데 비용은 들지 않으나, 문제는 연장 시기를 놓쳐 만료될 경우다. 이렇게 만료된 도메인은 새로 발급받아야하는데, <span class=\"purple-600\">Special Domain</span>으로 분류되어 약 9$ 정도의 비용을 요구한다.\r\n\r\n9$이면 괜찮은 TLD의 도메인을 발급받을 수 있을 정도의 금액이므로 여기서 구매할 이유도 딱히 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large red-600\">3. 인기 도메인 강제 하이재킹</p>\r\n\r\nFreenom 도메인을 <span class=\"red-400\">실제 서비스에 사용하면 안되는 결정적인 이유.</span>\r\n\r\n만약, 당신의 서비스에 Freenom 도메인을 적용했는데, 운 좋게 서비스의 인기가 많아졌다고 가정하자. 인가가 많아지면 덩달아 접속량도 많아지는 건 당연지사.\r\n\r\n문제는 Freenom에서 이를 모니터링한다는 점이다. 단순 모니터링해서 접속자 통계를 제공해주면 좋겠지만, 무료인데 그런 서비스를 제공할리가 없다.\r\n\r\n실상은 도메인이 일정 트래픽 이상을 발생시키면 <span class=\"purple-600\">Special Domain</span> 어쩌고 하면서 <span class=\"red-400\">유료로 전환</span>시켜버린다.\r\n\r\n2번이야 연장하지 않은 귀책사유라도 있지, 이건 그냥 도메인 강탈이라서 답도 없다. 트래픽이 많으면 다음 갱신이 불가능하다 이런 것도 아니고, 그냥 <span class=\"red-400\">트래픽이 많은 도메인은 언제든 뺏길 수 있다.</span>\r\n\r\n도메인이야 다시 발급받으면 된다지만, 이미 사용하던 사람들에게 도메인의 변경으로 혼란을 주고, 서비스의 신뢰성을 훼손하게 되므로 서비스 운영에 지대한 악영향을 미친다.\r\n\r\n# 도메인 발급 방법\r\n\r\n아래의 절차에 따라 도메인을 발급받자. 외국 소재 사이트다보니, 사이트 속도가 좀 느릴 수도 있으니 참고할 것.\r\n\r\n## 1. 회원가입\r\n\r\n[Freenom](https://www.freenom.com/)에 접속하여 회원가입을 진행한다. Google 소셜 로그인을 지원하니, 이쪽을 시도해도 좋다.\r\n\r\n## 2. 사용 가능한 도메인 검색\r\n\r\n검색창에서 원하는 도메인명을 검색한다. [Services] -> [Register a New Domain]을 메뉴를 선택하면 검색 페이지가 뜬다. \r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129911927-51d23984-87d3-47e9-88bf-e13abf2dff8a.png)\r\n\r\n<span class=\"blue-400\">rwb0104</span>의 경우 5개의 무료 도메인 중 5개 전부 적용이 가능하다.\r\n\r\n## 3. 무료 TLD 선택\r\n\r\n앞서 언급했듯이, 무료 도메인은 총 5개가 있다.\r\n\r\n이 중 원하는 TLD를 선택하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129912910-869d2ce9-d312-4cf6-85bf-4aa534ea87d8.png)\r\n\r\n여기에선 `tk` TLD를 선택한다. 위의 [<span class=\"green-A400\">Checkout</span>] 버튼을 클릭하여 다음으로 넘어간다.\r\n\r\n## 4. 옵션 선택\r\n\r\n도메인 옵션을 선택한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913319-c648e9cd-f097-4761-bede-685b5732039f.png)\r\n\r\n보다시피 별건 없고, 반드시 우측 콤보박스에서 [Period]를 12개월로 맞추자. 최대 12개월까지 무료로 사용 가능하며, 만료일자 기준으로 2주 안에 갱신이 가능하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913740-d8f36236-2136-477f-8375-e20e435156a1.png)\r\n\r\n[<span class=\"green-A400\">Use DNS</span>]를 선택하여 자신의 IP를 입력하자.\r\n\r\n자신의 실제 IP는 [여기](https://www.findip.kr/)에서 확인할 수 있다. 192.168.0.x과 같은 사설 IP는 입력하면 안 된다.\r\n\r\n위 사진은 `rwb0104.tk`와 `www.rwb0104.tk`에 매칭되는 아이피를 연결하는 설정이다. 앞의 `www`와 같은 서브도메인은 필요에 따라 DNS 설정을 통해 추가할 수도, 삭제할 수도 있으니 크게 신경쓰지 않아도 된다.\r\n\r\n모든 설정을 완료했다면 [<span class=\"lightBlue-A400\">Continue</span>]를 클릭하여 진행한다.\r\n\r\n## 5. 구매\r\n\r\n100원이든 0원이든 일단 \"구매\"는 하는 셈이니, 절차상 구매 약관에 따라 구매한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914504-abad20fc-e84d-4040-a003-1b82e6ba8080.png)\r\n\r\n$0.00 달러임을 확인하자. 문제가 없다면 약관에 동의하고 [<span class=\"lightBlue-A400\">Complete Order</span>]를 클릭한다.\r\n\r\n구매 확인서가 나오는데, 어차피 무료로 구매했으므로 신경쓰지 말고 넘어가자.\r\n\r\n## 6. 발급받은 도메인 확인\r\n\r\n[Services] -> [My Domains]에서 발급받은 도메인 목록을 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914950-4ecd1040-82eb-4a35-b402-4914ea1013c1.png)\r\n\r\n[Manage Domain] 버튼을 클릭하면 도메인 설정을 변경하거나 삭제할 수 있다.\r\n\r\n# 도메인을 활용해 접속하기\r\n\r\n이제 도메인을 사용해 내 서버에 접속하자.\r\n\r\n아무런 설정을 건드리지 않은 Tomcat을 기동한다. 통상 `xxx.xxx.xxx.xxx:8080` 혹은 `localhost:8080`으로 접속했겠지만, 이제 IP `xxx.xxx.xxx.xxx`가 도메인과 연결되어 있으므로, 해당 도메인으로 접속해보자.\r\n\r\n`rwb0104.tk:8080` 이렇게 접속해서 문제없이 접속되면 도메인이 정상적으로 IP와 연동된 것이다.\r\n\r\n## 연결이 되지 않아요!\r\n\r\n* `xxx.xxx.xxx.xxx:8080`으로 접속되는지 확인할 것\r\n  * 접속이 될 경우 외부에서 문제없이 접속되므로, 도메인에 연결한 IP가 올바른지 확인\r\n  * 접속되지 않을 경우 애초에 외부에서 접속되지 않는 것이므로 방화벽이나 포트 통신에 문제가 없는지 확인\r\n\r\n# 정리\r\n\r\nFreenom은 실제로 쓰긴 굉장히 난감한 단점을 가진다. 그럼에도 불구하고 도메인 관련 테스트나 공부할 땐 또 이만한 사이트가 없는 것 같다.\r\n\r\n이제 도메인까지 발급받았으니, SSL 인증서를 발급받는 방법에 대해 다뤄보자.","url":["2021-08-18-freenom-domain","2021","08","18","freenom-domain"]},{"header":{"title":"[SSL] SSL 인증서","excerpt":"이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다. SSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다. 그렇다면, 해당 도메인에 SSL이 적용되어 https를 사용할 수 있는 이유는 무엇일까?","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T10:55:24","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl-license.md","content":"\r\n# 개요\r\n\r\n이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다.\r\n\r\nSSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다.\r\n\r\n그렇다면, 해당 도메인에 SSL이 적용되어 `https`를 사용할 수 있는 이유는 무엇일까?\r\n\r\n# SSL 인증서\r\n\r\n이는 바로 인증서의 존재 덕분이다. 해당 사이트에 SSL이 적용되었는지 여부는 HandShake의 과정 중 ServerHello에서 받은 인증서 정보를 통해 확인할 수 있다.\r\n\r\nSSL 인증서엔 도메인명, 회사 정보, 서버 공개키가 포함되어있으며, 이 정보를 통해 도메인의 사이트의 유효성 확인, 암호화 통신이 가능하다.\r\n\r\n# SSL 인증서 종류\r\n\r\nSSL 인증서는 인증서 심사의 수준에 따라 DV, OV, EV 세 가지로 구분할 수 있다.\r\n\r\n## DV(Domain Validation)\r\n\r\n<span class=\"pink-600\">DV</span>는 오로지 <span class=\"pink-400\">도메인의 소유만을 검증하여 발급하는 인증서</span>다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820828-2bcf1d36-c954-471d-a7ce-e5facfa27859.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명 (*일 경우 와일드 카드)\r\n\r\n인증서 정보의 주체를 보면 도메인 정보인 CN외에 다른 정보는 확인할 수 없다.\r\n\r\nDV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n도메인 외의 소유자 등에 대한 다른 요인은 전혀 심사에 반영되지 않으므로, <span class=\"green-400\">발급 절차가 간단하고 금방 발급</span>된다. 또한 <span class=\"green-400\">금액 역시 대체적으로 저렴</span>한 편. 하지만 <span class=\"red-400\">신뢰성은 다른 인증서에 비해 떨어진다.</span>\r\n\r\n이 도메인이 실제함은 보증하지만, 그 이상의 요인은 보증하지 않기 때문이다. 혹여 누군가가 불법적인 일을 위해 페이퍼 컴퍼니를 만들고, 사이트를 그럴듯하게 꾸며놓아도 DV 인증서는 SSL을 발급해준다. 심사 기준이 오로지 도메인이기 때문에 발생하는 문제.\r\n\r\n물론 이는 어디까지나 단순한 \"믿음\"의 영역으로, <span class=\"green-400\">DV 인증서의 암호화 알고리즘이 다른 인증서에 비해 취약한 것도 아니기 때문에 보안 자체엔 전혀 문제가 없다.</span>\r\n\r\n신뢰에 기반하는 쇼핑몰, 금융업 등의 서비스에선 가급적 지양해야할 인증서.\r\n\r\n반대로 신뢰성을 그렇게 크게 요구하지 않는 <span class=\"lightBlue-400\">개인 프로젝트</span>, <span class=\"lightBlue-400\">소규모 사이트</span> 등엔 시간적으로나 경제적으로나 DV가 적합하다. DV 인증서를 직접 보고 싶다면, 소규모 개인 사이트나 블로그에 들어가면 된다. 블로그의 경우 GitHub나 NAVER 같은 플랫폼 연계가 아닌, 실제 본인이 서버를 임대해서 플랫폼 없이 직접 배포하는 그런 블로그에 들어가야 한다.\r\n\r\n### E-Mail\r\n\r\n<span class=\"orange-400\">도메인 소유주의 이메일에 인증 메일을 발송하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\n이 이메일은 아무거나 지정할 수 없고, 도메인을 발급받은 DNS 사이트에 등록된 이메일만 가능하다.\r\n\r\n타 인증방식과 다르게 <span class=\"green-400\">HTTP 80포트를 사용하지 못 해도 인증이 가능한 방식</span>이다. 만약 어떠한 이유로든 외부에서 자신의 사이트에 80포트로 접속할 수 없는 경우, 이 방법 외에 다른 인증은 불가능하다.\r\n\r\n### DNS 레코드\r\n\r\n<span class=\"orange-400\">DNS 설정을 추가하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\nDNS 설정의 A 레코드에 CA에서 임의로 생성한 URL을 추가한다. 해당 URL로 접근했을 때, HTTP 응답 코드가 200일 경우 인증된다.\r\n\r\nDNS 설정은 도메인 소유주만 관리할 수 있으므로, CNAME이 추가되면 도메인 소유주라 간주할 수 있다.\r\n\r\n반드시 <span class=\"red-400\">80포트로 웹 페이지에 접속할 수 있어야한다.</span> 만약 본인의 네트워크 환경 특수성으로 인해 80포트가 외부로 개방되지 않을 수도 있다. 이 경우 포트포워딩을 사용해서 외부의 80포트를 내부의 다른 포트로 라우팅해주면 된다. 최악의 경우 80포트 자체의 연결이 막혔거나, 본인이 포트포워딩을 마음대로 설정할 수 없는 경우는 이 방법으로 인증할 수 없다.\r\n\r\n### HTTP 요청\r\n\r\n웹 ROOT 경로에 `.well-known` 폴더를 생성하여 내부에 임시 파일을 생성한다. 임시 파일은 랜덤한 해쉬값이다. 이를 웹 서버에 배포하면 브라우저 상에서 해당 경로를 통해 파일에 접근할 수 있을 것이다.\r\n\r\n<span class=\"orange-400\">HTTP 요청은 이러한 방식으로 소유주에게 특정 파일을 서버에 업로드할 것을 요구하여, 해당 파일 접근 가능 여부를 통해 소유주임을 인증</span>한다.\r\n\r\n마찬가지로, <span class=\"red-400\">80포트 접근이 가능해야만 할 수 있는 인증</span>방법.\r\n\r\n## OV(Organization Validation)\r\n\r\n<span class=\"pink-600\">OV</span>는 <span class=\"pink-400\">도메인 뿐만 아니라, 해당 도메인을 소유한 회사, 기업에 대해 검증하여 발급</span>하는 인증서다.\r\n\r\n내가 제출한 도메인이 유효한지와는 별개로 <span class=\"orange-400\">도메인을 소유한 단체, 회사에 대한 검증까지 진행</span>한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820836-ac84d888-46cc-4877-a060-bea4df121e7c.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명\r\n* <span class=\"orange-400\">O(Organization)</span>: 기관명\r\n* <span class=\"orange-400\">L(Locality)</span>: 지역(시군구)\r\n* <span class=\"orange-400\">S(StateOrProvinceName)</span>: 주(시도)\r\n* <span class=\"orange-400\">C(CountryName)</span>: 국가\r\n\r\n인증서의 주체를 보면 도메인 정보 외에도 이를 소유한 회사/기관의 이름, 지역, 국가 등의 정보를 확인할 수 있다.\r\n\r\nOV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.2</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n자신의 단체/회사가 실존하는지를 입증하기 위해 사업자 등록증 같은 서류를 추가로 제출해야한다.\r\n\r\n소유주에 대한 검증 및 서류가 오가게 되므로, <span class=\"red-400\">발급이 즉시 이루어지진 못한다. 비용도 더 비싸며 족히 1 ~ 3일 정도는 소요</span>되는 편. 하지만 소유주에 대한 인증 덕분에 <span class=\"green-400\">보편적인 신뢰성을 제공</span>한다.\r\n\r\n대부분의 사기업 페이지에 적합한 인증서. OV 인증서는 <span class=\"lightBlue-400\">대부분의 사이트에 적용</span>되어 있으므로, 대충 번듯한 사이트 하나 들어가서 보면 된다. 지금 이 블로그도 GitHub가 주체라 OV 인증서를 확인할 수 있으니 참고할 것.\r\n\r\n## EV(Extended Validation)\r\n\r\n<span class=\"pink-400\">DV, OV인증과 더불어 법인 운영 담당자의 재직 증명, 법인 운영 기간 등 디테일한 요인을 검증</span>하여 발급하는 인증서다.\r\n\r\nOV의 경우 회사가 실재하는지를 검증한다면, <span class=\"pink-400\">EV</span>는 회사가 정상적으로 운영되는지를 검증한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820838-a87a8221-7785-49be-a3c2-26d0041b3295.png)\r\n\r\n인증서의 주체를 보면 도메인 정보, 회사 정보 외에도 다양한 정보가 추가되었음을 알 수 있다.\r\n\r\nEV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820842-41c97a59-f306-48d7-abfc-e6a06fd8ccf4.png)\r\n\r\n또한 EV 인증서는 다른 인증서와 달리 인증서 자체에 회사 서명을 표시해준다. 위 사진을 기준으로 좌측이 EV, 우측이 OV 혹은 DV. Microsoft Chromium Edge 기준으로 위와 같이 표시해준다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820843-1c77482f-bf84-47c4-a46b-ecfdf8149398.png)\r\n\r\n그 뿐만 아니라, IE로 접속했을 경우 주소창에 <span class=\"green-600\">Green Bar</span>를 적용하여 해당 도메인에 EV가 적용되었음을 시각적으로 알려준다. Chromium 기반 브라우저의 경우 시각적으로 표현해주진 않으니 참고할 것.\r\n\r\n인증서의 까다로운 심사절차로 인해 <span class=\"green-400\">발급하는데 걸리는 시간은 2주가 넘어가기도 하며, 비용 또한 매우 비싸다.</span> 하지만 <span class=\"red-400\">매우 강도 높은 신뢰성을 제공</span>한다.\r\n\r\n위와 같은 신뢰성 때문에, 이러한 신뢰성 보증이 필요한 공공기관, 금융권, 쇼핑몰과 같은 페이지에 사용된다. EV 인증서를 직접 보고싶다면, 아무 은행 홈페이지나 들어가보자.\r\n\r\n# 정리\r\n\r\nSSL이 적용되었는지 여부는 해당 사이트에 SSL 인증서가 있는지 여부를 통해 확인할 수 있다. 겉보기엔 SSL 인증서가 거기거 거기같지만 사실 그 종류만 해도 여러가지가 있으며, 인증서의 주체, 정책을 통해 현재 접속 중인 사이트의 SSL 종류를 확인할 수 있다.\r\n\r\nSSL을 적용하는 사이트의 성향에 따라 적합한 SSL 인증서를 발급받도록 하자.\r\n\r\n다음 장에서는 SSL 인증을 받기 위한 사전작업인 도메인 발급을 받아본다.","url":["2021-08-18-about-ssl-license","2021","08","18","about-ssl-license"]},{"header":{"title":"[SSL] SSL이란?","excerpt":"웹을 배포해본 적이 있다면 SSL에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 https://로 시작하며, http://와 달리 보안(Secure)을 의미하는 s가 붙는다. 지금 이 사이트의 주소도 https://rwb0104.github.io로 SSL이 적용된 걸 확인할 수 있다. NAVER나 Google도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T00:26:08","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","TLS"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl.md","content":"\r\n# 개요\r\n\r\n웹을 배포해본 적이 있다면 <span class=\"pink-600\">SSL</span>에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 `https://`로 시작하며, `http://`와 달리 <span class=\"blue-400\">보안(Secure)</span>을 의미하는 `s`가 붙는다. 지금 이 사이트의 주소도 [https://rwb0104.github.io](https://rwb0104.github.io)로 SSL이 적용된 걸 확인할 수 있다. [NAVER](https://naver.com)나 [Google](https://google.com)도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.\r\n\r\n# SSL(Secure Socket Layer)\r\n\r\n그렇다면 이 <span class=\"pink-600\">SSL</span>이란 놈은 뭘까? SSL은 Secure Socket Layer의 약자로, 직역하면 암호화 소켓층이다. 1994년 Netscape사에서 처음 개발되어 3.0 버전까지 존재한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129691442-090810ed-30c5-4245-aa9d-9dd785f621a6.png)\r\n\r\nSSL이란, <span class=\"amber-400\">웹 서버와 클라이언트의 통신 암호화 프로토콜</span>이다.\r\n\r\nSSL이 적용되지 않은 통신의 경우, 위 그림과 같이 평문(Plain Text)가 그대로 전송된다. 만약 제 3자가 어떠한 방식으로든 통신 패킷을 탈취할 경우, 그 내용을 쉽게 확인할 수 있다.\r\n\r\n통신 내용에 시덥잖은 것만 있다면 다행이겠지만, 사용자의 개인 정보나, 결제 정보와 같은 민감한 정보의 통신이라면 얘기가 달라진다.\r\n\r\nSSL을 적용한다면 이러한 문제를 기술적으로 해결할 수 있다. 요청을 암호화해서 보내므로 통신 패킷이 탈취되도 복호화 키가 없으면 원래 내용을 알 수 없기 때문이다.\r\n\r\n## TLS(Transport Layer Security)\r\n\r\nSSL을 접하다보면 <span class=\"pink-600\">TLS</span>라는 개념도 접하게 된다. 찾다보면 SSL이랑 TLS랑 혼재되어있기도 하고.\r\n\r\nSSL은 1996년에 3.0 버전이 출시되었으며, 보안취약점으로 인해 현재는 퇴출된 상태다.\r\n\r\nTLS는 국제 인터넷 표준화 기구(IETF)에서 개발한 것으로, SSL 3.0의 보안취약점을 보완한 통신 보안 프로토콜이다. 현재 TLS는 2018년 1.3 버전이 출시됏다.\r\n\r\nSSL을 보완한 것이 TLS지만, 인터넷에 적용되는 통신 보안 프로토콜을 전부 통틀어서 SSL이라 부른다.\r\n\r\n실상은 2015년에 SSL의 마지막 버전인 3.0 마저 금지됐다. 현재 사용 중인 프로토콜은 모두 TLS다.\r\n\r\n# SSL의 특징\r\n\r\n1. URL 프로토콜은 `https`이며, 기본 포트는 `443`이다.\r\n2. 통신 데이터가 암호화되어, 패킷이 탈취되는 사고가 발생해도 데이터를 지킬 수 있다.\r\n3. SSL 인증서를 통해 도메인의 신뢰성을 검증할 수 있다.\r\n4. 데이터 송/수신 과정에서 암/복호화가 발생하므로 속도가 느리다.\r\n\r\n# SSL의 원리\r\n\r\nSSL의 통신하는 원리는 아래와 같으며, 이러한 일련의 과정을 HandShake라 한다. 클라이언트와 서버 간의 요청/응답을 반복하며 통신에 필요한 사전 작업을 하는게 마치 악수 같아 붙여졌다고 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752108-1423e7cf-3c4c-4e4c-a77a-7a76d208d7f8.png)\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">1. ClientHello 요청</p>\r\n\r\n클라이언트가 특정 주소에 접근하면, 해당하는 서버에 요청을 보낸다. [NAVER](https://naver.com)에 접근하면 네이버 서버에 요청을 보내게 된다.\r\n\r\n* 난수 데이터\r\n* 암호화 프로토콜 정보 (프로토콜, 버전 등)\r\n* 클라이언트가 사용 가능한 암호화 기법\r\n* 세션 아이디\r\n* 기타 확장 정보\r\n\r\n이 요청에는 위와 같은 정보들이 포함되어있다. 클라이언트의 주요 정보를 서버에 전송하여, 해당 클라이언트를 식별하고, 어떤 암호화를 사용할 수 있는 지 등의 정보를 서버가 인지하도록 한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">2. ServerHello 응답</p>\r\n\r\n서버가 ClientHello 요청을 받으면, 위의 정보를 담아 클라이언트에게 일종의 화답을 보낸다.\r\n\r\n* 난수 데이터 (ClientHello의 데이터와 다름)\r\n* 서버가 사용할 암호화 기법\r\n* 인증서\r\n  * CA\r\n  * 도메인\r\n  * 공개키\r\n\r\n난수 데이터는 ClientHello에서 보낸 데이터과 아무런 상관관계가 없는 별개의 데이터다.\r\n\r\n클라이언트가 사용 가능하다고 통보한 암호화 기법 중 서버에서 활용할 암호화 기법을 전달하여 동일한 암호화 기법으로 송수신할 수 있도록 선언한다.\r\n\r\n인증서 정보와 함께, 서버와의 암호화 통신을 위한 서버 공개키가 전달된다. 서버의 공개키로 데이터를 암호화하면 서버는 이를 받아 개인키로 복호화하여 요청을 분석할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">3. 인증서 검토</p>\r\n\r\n서버가 전달한 인증서가, 실제 해당 서버의 인증서인지, 신뢰할 수 있는 CA에서 발급된 것인지, 실제 해당 CA에서 발급받았는지 등 인증서를 검토한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752361-4831de06-e99b-4f0c-9862-fe1f8ab5642a.png)\r\n\r\n인증서에 이상이 없다면 주소창에 위와 같이 표시된다. (Microsoft Chromium Edge 기준)\r\n\r\n만약 문제가 있다면 아래와 같은 창을 보게 될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752602-f9967221-3b82-487f-91c4-7fefc1cf3e94.png)\r\n\r\n이는 브라우저가 사용자에게 보내는 경고문으로, 해당 사이트의 인증서가 올바르지 않으므로 신뢰할 수 없다고 경고하는 것이다.\r\n\r\n물론 사이트 관리자의 실수로 인증서가 만료됐거나, 잘못된 인증서를 교체해서 발생한 사소한 이유일 수도 있다. 하지만 낮선 사이트를 접속하는데 이와 같은 경고가 뜬다면, 정상적인 방법으로 인증서를 발급받을 수 없는 사이트일 가능성이 있으므로 접근을 자제하자.\r\n\r\n악의가 없는 사이트일지라도, 사용자의 데이터는 보호해주지 못 하니 주의할 것.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">4. Premaster Secret 송수신</p>\r\n\r\nClientHello, ServerHello에서 송수신한 난수 데이터를 조합하여 Premaster Secret을 생성한다.\r\n\r\n이를 ServerHello에서 전달받았던 공개키로 암호화한다. 이 데이터는 서버가 가진 개인키로만 복호화가 가능하다. 즉, 이 데이터는 탈취된다 하더라도 그 내용이 보호된다.\r\n\r\n서버는 수신된 데이터를 복호화하여 클라이언트와 동일한 Premaster Secret을 저장할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">5. 통신 키 생성</p>\r\n\r\n보유한 Premaster Secret을 토대로 Master Secret, Session Key를 생성한다. 이를 통해 클라이언트와 서버가 동일한 키를 보유하게 되므로 자신들끼리의 암호화 통신이 가능하다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">6. 데이터 송수신</p>\r\n\r\n필요한 데이터는 저장된 Session Key를 통한 대칭키 암호화 방식으로 암/복호화하여 통신한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">7. 세션 종료</p>\r\n\r\n클라이언트와의 연결이 끊겼을 경우 사용했던 Session Key는 폐기한다.\r\n\r\n# 정리\r\n\r\nSSL은 통신 패킷을 암호화하여 패킷 탈취, 정보 누출 등을 방지하기 위한 보안 프로토콜이다.\r\n\r\n현재는 모두 TLS로 교체되었지만, SSL 자체가 고유명사되어 넓은 의미의 통신 보안 프로토콜을 명칭하는 의미로 쓰인다.\r\n\r\n현대에 이르러서는 웹 배포에 있어서 필수적인 사항이므로, 내용을 잘 이해하자.\r\n\r\n다음 장에서는 SSL 인증서에 대해 다룬다.","url":["2021-08-18-about-ssl","2021","08","18","about-ssl"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙이다. 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다. 위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다. 왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, Method1을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다. 하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-16T19:24:57","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-16-interface-segregation-principle.md","content":"\r\n# 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n\r\n<span class=\"orange-400\">인터페이스 분리 원칙</span>이란 <span class=\"red-600\">객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다</span>는 원칙이다.\r\n\r\n구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128585790-a761f795-b4da-4a52-865d-d2dd4b858f20.png)\r\n\r\n위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다.\r\n\r\n왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, `Method1`을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다.\r\n\r\n하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.\r\n\r\n# 코드로 보는 인터페이스 분리 원칙\r\n\r\n예시를 통해 인터페이스 분리 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 인터페이스 분리 원칙을 준수하지 않은 코드\r\n\r\n예를 들어, 스마트폰이라는 객체가 있다고 가정하자. 이 스마트폰 객체는 비교적 최신에 나온 덕분에 일반적인 스마트폰 기능 외에도 무선 충전, AR 뷰어, 생체인식 등의 다채로운 기능을 포함하고 있다.\r\n\r\n이를 가지고 S20을 구현하면 스마트폰 객체의 동작 모두가 필요하므로 ISP를 만족한다. 그러나 S2를 구현할 경우, 무선 충전, 생체인식과 같은 기능을 제공하지 않는다. 그럼에도 불구하고 부모 객체인 스마트폰에 이러한 인터페이스가 포함되어 있으므로, S2 입장에서는 필요하지도 않은 기능을 구현해야하는 낭비가 발생한다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\nabstract public class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선 충전\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tabstract public void biometrics();\r\n}\r\n```\r\n\r\n위와 같이 구현된 `SmartPhone` 객체가 있다. 생체인식을 담당하는 `biometrics()` 메소드의 경우, 기기에 등록된 생체정보를 활용해야 하므로 추상 메소드로 선언되어있다. 이 객체를 상속하여 `S20`과 `S2`를 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"S20 생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20`은 모든 기능이 필요하기 때문에, `SmartPhone`의 모든 메소드를 사용해야하므로, 불필요한 메소드가 없는 상태다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 무선충전, AR, 생체인식이 지원되지 않는 기기다. 그럼에도 불구하고 `SmartPhone`의 상속으로 인해 해당 기능의 메소드를 강제로 상속받게 된다. 더군다나 `biometrics()`의 경우 추상 메소드이므로 필요하지도 않은 기능을 구현까지 해야한다. 이러한 상속의 특징은 부모 객체의 규모가 매우 클 경우, 개발 편의성의 극심한 저하로 이뤄진다. 필요하지도 않은 수십개의 메소드를 일일히 오버라이딩하여 적절한 처리를 해준다고 생각해보자.\r\n\r\n## 인터페이스 분리 원칙을 준수한 코드\r\n\r\n객체의 특성을 확장을 통해 다른 객체를 편하게 구현하기 위한 것이 상속인데, 위와 같은 상황은 전혀 편하지 않다. 이는 부모 객체의 설계가 잘 못 됐을 수도 있고, 취지에 맞지 않는 객체를 상속했을 수도 있다. 이유야 어찌됐든 해결해야한다는 사실엔 변함이 없다.\r\n\r\n그렇다면 이 현상은 어떻게 해결할 수 있을까? 객체의 메소드를 각각 인터페이스로 만들면 된다. 각 객체는 필요한 인스턴스만 상속하면 되므로 필요한 동작만을 상속/구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\npublic class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n}\r\n```\r\n\r\n`SmartPhone` 객체는 모든 스마트폰에 적용되는 보편적인 동작만을 가지도록 변경했다.\r\n\r\n``` java\r\n/**\r\n * 무선충전 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:23:33\r\n */\r\npublic interface WirelessChargable\r\n{\r\n\t/**\r\n\t * 무선충전 추상 함수\r\n\t */\r\n\tvoid wirelessCharge();\r\n}\r\n\r\n/**\r\n * AR 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:24:29\r\n */\r\npublic interface ARable\r\n{\r\n\t/**\r\n\t * AR 추상 함수\r\n\t */\r\n\tvoid ar();\r\n}\r\n\r\n/**\r\n * 생체인식 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:25:08\r\n */\r\npublic interface Biometricsable\r\n{\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tvoid biometrics();\r\n}\r\n```\r\n\r\n각 기능의 인터페이스는 위와 같다. 원래 `SmartPhone`의 객체의 메소드였던 각 기능은 인터페이스 단위로 나뉘어졌음에 주목하자.\r\n\r\n이를 통해 `S20`과 `S2` 모두 필요한 객체만을 상속받아 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone implements WirelessChargable, ARable, Biometricsable\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선충전 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20` 객체의 코드다. `SmartPhone`을 상속받았으며, 인터페이스로 `WirelessChargable`, `ARable`, `Biometricsable`을 모두 상속받아 구현하고 있다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\t@Override\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(\"In S2\");\r\n\t\t\r\n\t\tsuper.message(number, text);\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 특수 기능이 구현되어있지 않으므로, 기본적인 `SmartPhone` 객체만을 상속받아 구현된다.\r\n\r\n인터페이스는 다중 상속을 지원하므로, 필요한 기능을 인터페이스로 나누면 해당 기능만을 상속받을 수 있다. 그 밖에 추후 업데이트 등을 통해 추가적인 기능이 탑재된다면, 같은 원리로 인터페이스를 설계해서 사용하면 필요한 객체에 필요한 기능을 쉽게 추가할 수 있다.\r\n\r\n# 정리\r\n\r\n인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙이다. 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제가한다. 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킨다.\r\n\r\n객체를 상속할 땐 해당 객체가 상속 받는 객체에 적합한 객체인지, 의존적인 기능이 없는 지 판단하여 올바른 객체를 구현, 상속하도록 하자.","url":["2021-08-16-interface-segregation-principle","2021","08","16","interface-segregation-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-15T13:42:11","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-15-liskov-subsitution-principle.md","content":"\r\n# 리스코프 치환 원칙 (Liskov Subsitution Principle)\r\n\r\n<span class=\"orange-400\">리스코프 치환 원칙</span>은 부모 객체와 이를 상속한 자식 객체가 있을 때 <span class=\"red-600\">부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다</span>는 원칙이다.\r\n\r\n객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.\r\n\r\n리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.\r\n\r\n# 코드로 보는 리스코프 치환 원칙\r\n\r\n리스코프 치환 원칙을 설명할 때 많이 사용하는 예제로 직사각형과 정사각형의 관계가 있다.\r\n\r\n## 리스코프 치환 원칙을 위배한 코드\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\npublic class Rectangle\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n`Rectangle`은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.\r\n\r\n정사각형 역시 넓게 보면 직사각형의 한 종류이니, <span class=\"red-400\">직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있을 것이라 생각했다.</span>\r\n\r\n``` java\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\npublic class Square extends Rectangle\r\n{\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\t@Override\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tsuper.setWidth(width);\r\n\t\tsuper.setHeight(getWidth());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\t@Override\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tsuper.setHeight(height);\r\n\t\tsuper.setWidth(getHeight());\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 정사각형 객체 `Square`를 `Rectangle`의 상속을 통해 쉽게 구현할 수 있었다.\r\n\r\n정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치시켜주도록 오버라이딩을 수행했다.\r\n\r\n구현한 `Rectangle`의 넓이를 구해보자.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Rectangle();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n```\r\n\r\n`Rectangle`의 넓이를 구하는 소스는 이와 같다. 너비가 10, 높이가 5로 할당됐으므로 넓이 50이 정상적으로 반환된다.\r\n\r\n리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, `Rectangle`을 상속받은 `Square`로 대체하여 넓이를 구해보자.\r\n\r\n`Square`가 `Rectangle`을 완전히 대체했다면 동일한 결과인 50이 반환되어야 한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Square();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n25\r\n```\r\n\r\n어째서인지 넓이는 50이 아닌 25로 반환됐다. 자세히 살펴보니, 마지막에 수행된 `setHeight(5)`가 객체의 너비/높이를 모두 5로 할당했다. 그러니 넓이도 당연히 25가 출력될 수밖에 없었던 걸로 보인다. 즉, 이 객체는 리스코프 치환 원칙에 위배되는 코드다.\r\n\r\n곰곰히 생각해보면, 직사각형과 정사각형은 상속관계가 전혀 될 수 없다. 사각형의 특징을 서로 갖고있긴 하지만, 두 사각형 모두 사각형의 한 종류일 뿐으로, 하나가 다른 하나를 완전히 포함하지 못 하는 구조다.\r\n\r\n이렇게 잘못된 객체를 상속하거나, 올바르게 확장하지 못 할 경우 겉으로 보기엔 정상적이지만 올바른 객체는 아니다.\r\n\r\n## 리스코프 치환 원칙을 준수한 코드\r\n\r\n그렇다면 이 코드를 어떻게 리스코프 치환 원칙에 부합하게끔 구성할 수 있을까?\r\n\r\n답은 올바른 상속과 구현에 있다. 앞서 설명했다시피, 직사각형과 정사각형은 상속의 관계가 성립되기 어렵다. 따라서 이보다 더 상위 개념인 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속받으면 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 사각형 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:39:02\r\n */\r\npublic class Shape\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n위와 같이 `Shape`라는 사각형 객체를 구현한다.\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\nclass Rectangle extends Shape\r\n{\r\n\t/**\r\n\t * Rectangle 생성자 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic Rectangle(int width, int height)\r\n\t{\r\n\t\tsetWidth(width);\r\n\t\tsetHeight(height);\r\n\t}\r\n}\r\n\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\nclass Square extends Shape\r\n{\r\n\t/**\r\n\t * Square 생성자 함수\r\n\t *\r\n\t * @param length: [int] 길이\r\n\t */\r\n\tpublic Square(int length)\r\n\t{\r\n\t\tsetWidth(length);\r\n\t\tsetHeight(length);\r\n\t}\r\n}\r\n```\r\n\r\n`Shape`를 상속받는 두 사각형 `Rectangle`과 `Square` 객체는 위와 같다. `Rectangle`은 인스턴스 생성 시 `width`와 `height`를 파라미터로 받으며, `Square`는 각 변의 길이가 모두 동일하므로 `length` 하나만을 파라미터로 받는다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tShape rectangle = new Rectangle(10, 5);\r\n\t\tShape square = new Square(5);\r\n\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t\tSystem.out.println(square.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n25\r\n```\r\n\r\n이제 더 이상 `Rectangle`과 `Square`가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.\r\n\r\n# 정리\r\n\r\n리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고한다. 위의 직사각형과 정사각형의 케이스처럼 올바르지 못한 상속관계는 제거하고, 부모 객체의 동작을 완벽하게 대체할 수 있는 관계만 상속하도록 코드를 설계해야한다.\r\n\r\n리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요하다.\r\n\r\n부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙.\r\n","url":["2021-08-15-liskov-subsitution-principle","2021","08","15","liskov-subsitution-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 개방-폐쇄 원칙 (Open-Closed Principle)","excerpt":"개방 폐쇄 원칙이란 객체를 다룸에 있어서 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미. 좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다. 만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다. 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-14T04:04:40","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-14-open-closed-principle.md","content":"\r\n# 개방-폐쇄 원칙 (Open-Closed Principle)\r\n\r\n<span class=\"orange-400\">개방 폐쇄 원칙</span>이란 객체를 다룸에 있어서 <span class=\"red-600\">객체의 확장은 개방적으로, 객체의 수정은 폐쇄적</span>으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미.\r\n\r\n좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다.\r\n\r\n만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다.\r\n\r\n이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.\r\n\r\n# 코드로 보는 개방-폐쇄 원칙\r\n\r\n<br />\r\n<p class=\"large grey-600\" align=\"center\"><i>If...</i></p>\r\n<br />\r\n\r\n저명한 IT업체에서 일하는 당신. 어느덧 정년을 바라보고 있다. 노후 대비를 위해 작은 편의점의 점주로 새로운 시작을 하는 당신. 예전부터 봐뒀던 곳에 적지 않은 비용을 지불하기까지 했다.\r\n\r\n다행히 안목이 틀리지 않았는지, 아침은 아침대로, 새벽은 새벽대로 끊임없는 유동인구 덕분에 생각했던 것 이상으로 수입이 들어오고 있다. 좀 더 일찍 시작했어도 됐으려나...\r\n\r\n여기저기 신경쓰다보니 초기 비용이 여의치 않아, POS기기는 저렴한 걸 선택했다. 영업사원이 사용 카드가 어쩌네 넌지시 얘기한 거 같은데, 그래봐야 POS가 거기서 거기겠지 뭐.\r\n\r\n<br />\r\n\r\n요즘 들어 매체에 신생 카드 업체에 대한 주제가 끊이질 않는다. 공격적인 혜택과 이전 카드에선 찾아볼 수 없었던 아기자기한 디자인이 그렇게 인기랜다. 이름이 초콜릿뱅크였나..? 혜택은 좋은데, 카드에 저런 디자인이 무슨 소용이람.\r\n\r\n<br />\r\n\r\n요즘들어 그 초코 뭐시긴가 하는 카드를 쓰는 사람이 많아졌다. 문제는 저 놈의 POS기가 새로운 카드는 전혀 인식을 못 한다. 이 문제 때문에 이번 주에만 반 이상이 넘는 고객을 돌려보냈다. 매출도 문제지만, 손님한테 아쉬운 소리하면서 사과하는 게 더 고역이다.\r\n\r\nPOS 업체에 전화해봤는데, 구조 상 그런거라며 계약 이전에 다 설명하고 서명받은 내용이란다. 난 그런 기억이 없는데....? 어쨌든 내게 남은 선택지라곤 지금 유지비용의 두 배 가까이 되는 신규 POS로 교체하던가, 위약금을 물고 새로운 POS 업체로 갈아타는 것 뿐이다. 이 문제 때문에 잠을 통 잘 수가 없다.\r\n\r\n<br />\r\n\r\n그래도 명색이 개발자인 당신. 어쩌면 내가 해결할 수도 있지 않을까? 수 십년 간의 경험을 토대로 기억을 되짚어가며 기기를 분석해보기 시작했다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param card : [Object] 카드 객체\r\n\t * @param name : [String] 카드사명\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Object card, String name, int price)\r\n\t{\r\n\t\tboolean result;\r\n\t\t\r\n\t\tswitch (card.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\t\r\n\t\t\tdefault -> {\r\n\t\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n다행히 아직 감이 죽진 않았는지, 어렵지 않게 관련 모듈을 특정할 수 있었다. 카드 리더기에서 카드 인식 시 카드 정보가 담긴 객체를 `Object`로 캐스팅하여 전송한다. 정보 구분을 위해 카드사명까지 같이 전송하는 모양이다.\r\n\r\n딱 봐도 난감하기 그지없는 구조다. 실제로 초콜릿뱅크의 카드 정보는 리더기에서 잘 전달되고 있으나, `purchase` 메소드에서 초콜릿뱅크 카드를 구분하는 로직이 없어서 결제가 되지 않는다.\r\n\r\n``` java\r\npublic boolean purchase(String card, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\t// 신생 업체가 생길 때마다 해당 업체를 구분하는 로직을 추가한다.\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\tcase \"D\" -> result = ((CardD) card).send(price);\r\n\t\tcase \"E\" -> result = ((CardE) card).send(price);\r\n\t\tcase \"F\" -> result = ((CardF) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n```\r\n그렇다면 `case` 구문에서 초콜릿뱅크를 구분하여 결제 정보를 전송하면 해결되지 않을까? 이 방식을 쓴다면 급한 불은 끌 수 있겠지만, 후에 또 다른 신생업체가 생기면 같은 문제가 반복될 게 뻔하다.\r\n\r\n이 방법은 매우 비효율적이다. 동작의 범위만 넓혔을 뿐, 근본적인 문제는 전혀 해결되지 않는다.\r\n\r\n당신은 이 코드를 좀 더 객체지향의 관점으로 접근하여 리팩토링을 실시한다.\r\n\r\n``` java\r\n/**\r\n * 결제 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:28:22\r\n */\r\npublic interface Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\tboolean send(int price);\r\n}\r\n```\r\n\r\n공통된 형태로 로직을 수행하기 위해 `Purchasable` 인터페이스를 구현했다. 또한 리더기에서 전송하는 모든 카드 객체는 `Purchasable`를 상속받도록 강제했다.\r\n\r\n``` java\r\n/**\r\n * A 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:36:11\r\n */\r\nclass CardA implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * B 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:38:00\r\n */\r\nclass CardB implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * C 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:39:51\r\n */\r\nclass CardC implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n이제 리더기에서 전달하는 모든 카드 객체는 `Purchasable` 인터페이스를 상속받는다. 카드 객체를 부모 객체인 `Purchasable`로 다룰 수 있을 것이다. 각 카드 객체의 동작에 전송이 각각 구현되어있어, 타 객체의 코드에 의존하지 않는다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param purchasable : [Purchasable] Purchasable 인터페이스\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Purchasable purchasable, int price)\r\n\t{\r\n\t\treturn purchasable.send(price);\r\n\t}\r\n}\r\n```\r\n\r\n이제 결제 함수를 리팩토링 해보자. `CardA`, `CarB`, `CardC` 등 각각 개별적인 객체지만, 이제 `Purchasable`이라는 부모 객체가 있으므로 이를 묶을 수 있다. 우리는 리더기에서 주는 인터페이스 객체만 받아서 해당 객체의 `send`를 호출하면 된다.\r\n\r\n성공적으로 리팩토링을 마친 당신. 이제 어떤 카드든 결제가 가능하고 리더기가 정상적으로 인식만 한다면 결제를 진행할 수 있게됐다.\r\n\r\n당신이 한 각고의 노력과 빠른 대처로 인해 얼마 안 가 다시금 매출을 정상화시킬 수 있었다.\r\n\r\n# 정리\r\n\r\n리팩토링 전과 후를 비교해보자.\r\n\r\n``` java\r\npublic boolean purchase(Object card, String name, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n\r\npublic boolean purchase(Purchasable purchasable, int price)\r\n{\r\n\treturn purchasable.send(price);\r\n}\r\n```\r\n\r\n위는 이전 코드, 아래는 리팩토링한 코드다. <span class=\"amber-600\">기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다</span>는 의미를 여기에서 찾을 수 있다.\r\n\r\n리팩토링 이전 코드의 경우, 새로운 카드 인식. 즉, 기능 추가를 위해선 코드의 추가가 요구됐다. 다시 말해, <span class=\"red-600\">기능을 확장하기 위해선 코드의 수정이 필요</span>하다는 의미다.\r\n\r\n반대로 리팩토링 후의 코드를 보자. `Purchasable`라는 통합된 인터페이스를 사용하기 때문에 카드 추가에 따라 코드 단계에서 대응할 필요가 없다. 즉, <span class=\"red-600\">코드의 변경 없이 기능이 확장</span>된다.\r\n\r\n단일 책임 원칙과 마찬가지로, 비슷한 형태의 분기가 반복될 경우 개방-폐쇄 원칙을 준수하지 않았을 가능성이 높다. 이는 곧 높은 리팩토링 비용으로 직결되니, 이를 잘 준수하여 독립적인 모듈을 설계하자.","url":["2021-08-14-open-closed-principle","2021","08","14","open-closed-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)","excerpt":"올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-13T01:37:48","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-13-single-responsibility-principle.md","content":"\r\n# 객체지향 5원칙\r\n\r\n올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 <span class=\"amber-600\">객체지향 5원칙</span>(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다.\r\n\r\n이 다섯가지 원칙은 아래와 같다.\r\n\r\n1. 단일 책임 원칙 (Single Responsibility Principle)\r\n2. 개방-폐쇄 원칙 (Open-Closed Principle)\r\n3. 리스코프 치환 원칙 (Liskov Substitution Principle)\r\n4. 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n5. 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n각 원칙의 영어 앞글자를 따 <span class=\"primary\">SOLID</span>원칙이라고도 한다.\r\n\r\n# 단일 책임 원칙 (Single Responsibility Principle)\r\n\r\n<span class=\"orange-400\">단일 책임 원칙</span>이란 <span class=\"orange-400\">하나의 객체는 반드시 하나의 동작만의 책임을 갖는다</span>는 원칙이다.\r\n\r\n모듈화가 강해질수록 다른 객체와의 의존/연관성이 줄어든다. 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어나며, 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게된다.\r\n\r\n객체가 담당하는 동작. 즉, 책임이 많아질 수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다. 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.\r\n\r\n# 코드로 보는 단일 책임 원칙\r\n\r\n자동차는 휠의 구동 특성에 따라 전륜(FWD), 후륜(RWD), 사륜(AWD)로 나뉘며, 그 특성은 아래와 같다.\r\n\r\n* 전륜 구동인 경우 앞의 두 바퀴에만 동력을 전달한다.\r\n* 후륜 구동인 경우 뒤의 두 바퀴에만 동력을 전달한다.\r\n* 사륜 구동인 경우 전체 바퀴에 동력을 전달한다.\r\n\r\n이를 객체로 구현해보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\npublic class Car\r\n{\r\n\tprivate final String WD;\r\n\t\r\n\tprivate final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tswitch (WD.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"FWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"RWD\" -> {\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"AWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n여기 `Car` 객체가 있다. `Car`는 생성 시 파라미터로 <span class=\"orange-400\">휠 구동 방식</span>을 받는다.\r\n\r\n`Car`에는 주행 동작을 구현하는 `run()`메소드가 있으며, 이 메소드는 파라미터로 <span class=\"orange-400\">동력</span>을 받는다. 이후 휠 구동 방식에 따라 올바른 휠에 동력을 할당하고 휠의 상태를 출력한다.\r\n\r\n휠의 구동 방식 별 동작이 하나의 책임으로 본다면 이 객체가 짊어지는 책임은 무려 세 가지나 된다. 이렇게 하나의 객체에 너무 많은 책임이 몰려있을 경우, 프로젝트에서 해당 객체의 의존성이 높아지게된다. 이러한 현상은 객체지향의 주요 특징 중 하나인 캡슐화를 정면으로 부정한다. 그 뿐만 아니라, 각자의 코드가 서로 의존될 경우, 코드 수정에 따른 영향도 역시 높아지고, 범위 또한 넓어진다.\r\n\r\n위의 예시는 단일 책임 원칙을 설명하기 위한 단순한 예시로, 만약 코드의 규모가 크거나 복잡성이 심하다면 코드 수정 시 마다 오만가지 오류가 발생할 것이다. 그 뿐만 아니라 코드가 변경되는 과정에서 이미 정해진 코드의 리팩토링도 필요할 수 있다. 리팩토링이 리팩토링을 부르는 참사가 일어날 수도 있다. 여기서부터 코드가 지저분해지기 쉽다.\r\n\r\n단일 책임 원칙은 바로 이와 같은 상황을 방지하고자 수립된 원칙으로, <span class=\"red-400\">1객체 = 1책임</span>으로 최대한 객체를 간결하고 명확하게 설계할 것을 요구한다. 위 코드의 책임을 줄여 단일 책임 원칙을 지키려면 어떻게 해야할까?\r\n\r\n``` java\r\n/**\r\n * 자동차 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\nabstract public class Car\r\n{\r\n\tprotected final String WD;\r\n\t\r\n\tprotected final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tabstract public void run(int power);\r\n}\r\n```\r\n\r\n우선 공통된 인터페이스 내지는 상위 객체를 구현할 필요가 있다. 이 객체의 경우 생성자가 필요하므로 인터페이스 보단 상위 객체가 적합하다.\r\n\r\n> **네? 인터페이스 차별이요??**  \r\n> 인터페이스는 일반적인 객체 혹은 추상 객체와 달리 생성자를 강제할 수 없습니다.\r\n\r\n객체 `Car`를 상위 객체에 적용될 수 있게끔 구현한다. `run()` 메소드는 훨 구동 타입에 따라 동작이 달라지므로, `abstract` 지시자를 통해 추상 메소드로 선언한다. 해당 객체의 인스턴스를 생성하거나, 상속받는 객체가 직접 구현하게 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 전륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:03:13\r\n */\r\nclass FrontWheelCar extends Car\r\n{\r\n\t/**\r\n\t * FrontWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic FrontWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 후륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\nclass RearWheelCar extends Car\r\n{\r\n\t/**\r\n\t * RearWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic RearWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 사륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\npublic class AllWheelCar extends Car\r\n{\r\n\t/**\r\n\t * AllWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic AllWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n전륜, 후륜, 사륜에 해당하는 객체를 생성한다. 이 세 객체는 모두 `Car`에 포함되므로 `Car`를 상속받아 구현한다. 각 객체의 `run()` 메소드에 동작을 구현함으로써, 각각의 객체가 하나의 책임을 가지게 된다.\r\n\r\n이렇게 객체별로 책임을 나누면, 코드 변경 시에도 해당하는 객체만 수정하면 되므로, 의존성이 낮아져 올바른 모듈화를 구현할 수 있다. 그 뿐만 아니라 코드가 간결해져 유지보수가 쉬워질 뿐만 아니라 수정에 따른 영향도도 매우 작아진다.\r\n\r\n# 정리\r\n\r\n코드를 설계하다보면 하나의 객체가 너무 많은 동작을 담당하는 경우가 자주 발생한다. 필자 또한 무의식적으로 하나의 객체/메소드에 너무 많은 책임을 할당하는 일이 비일비재했다. 단일 책임 원칙은 이러한 개발 방향을 올바르게 잡아준다.\r\n\r\n가급적 단일 책임 원칙을 고수하여 올바른 객체를 구현할 수 있도록 해보자.","url":["2021-08-13-single-responsibility-principle","2021","08","13","single-responsibility-principle"]},{"header":{"title":"[OOP] 객체지향의 특징 - 다형성(Polymorphism)","excerpt":"객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다. 하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-12T00:32:42","type":"posts","category":"CS","tag":["CS","객체지향","다형성"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-12-polymorphism.md","content":"\r\n# 다형성 (Polymorphism)\r\n\r\n객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다.\r\n\r\n하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.\r\n\r\n> **One for One!**  \r\n> 하나의 파라미터는 반드시 하나의 타입만을 가진다. `public void run(String param)`은 반드시 문자열 타입만을 파라미터로 받는다.\r\n\r\n그말인즉슨, 동일한 메소드는 존재할 수 없으니, 해당 메소드에 입력할 수 있는 각각의 파라미터 타입도 하나로 고정된다. 하지만 `System.out.println()` 메소드를 보자. CLI 콘솔에 데이터를 출력하는 메소드로, JAVA를 다룬다면 안 써본 사람은 없는 메소드다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tSystem.out.println(\"문자열 데이터\");\r\n\t\tSystem.out.println(123456);\r\n\t\tSystem.out.println(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` out\r\n문자열 데이터\r\n123456\r\ntrue\r\n```\r\n\r\n<br />\r\n<p class=\"grey-600\" align=\"center\"><i>아니 아깐 동일한 메소드는 존재할 수 없다매요;;</i></p>\r\n<br />\r\n\r\n분명히 아까 <span class=\"pink-400\">동일한 이름을 가진 메소드는 동일한 객체에서 존재할 수 없다</span>고 했었다. 그럼에도 불구하고 `System.out.println()`의 경우, 메소드명은 동일한데 여러 타입을 보란듯이 받아서 처리하고 있다. 어떻게 된걸까? 유명한 메소드는 예외사항이라도 적용되는걸까?\r\n\r\n`System.out.println()`이 여러 타입을 처리할 수 있는 이유는 해당 메소드에 <span class=\"teal-400\">다형성</span>이 적용되어있기 때문이다. 다형성이란, 하나의 객체 혹은 메소드가 여러 타입을 참조할 수 있음을 의미한다. 다형성은 크게 <span class=\"amber-400\">객체의 다형성</span>과, <span class=\"amber-400\">메소드의 다형성</span>으로 구분된다.\r\n\r\n## 다형성의 예제\r\n\r\n코드를 통해 다형성을 알아보자.\r\n\r\n### 객체의 다형성\r\n\r\n먼저, 객체에 적용되는 다형성이다. 객체의 경우 상속된 객체의 인스턴스 생성 시, 다형성을 적용할 수 있다.\r\n\r\n객체의 다형성은 <span class=\"red-400\">객체가 상속된 부모 객체의 인스턴스로 할당</span>될 수 있음을 의미한다.\r\n\r\n``` java\r\nclass TV\r\n{\r\n\t// 메소드\r\n}\r\n\r\nclass SmartTV extends TV\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\n위와 같은 두 객체가 있다고 가정하자. `SmartTV`는 `TV`를 상속받아 구현된 객체다. 이 경우 `SmartTV`는 다형성을 적용할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tTV tv = new TV();\r\n\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tSmartTV smart = new SmartTV();\r\n\r\n\t\t// SmartTV는 TV의 자식 객체이므로 다형성이 적용되어 허용\r\n\t\tTV tv2 = new SmartTV();\r\n\r\n\t\t// 불가능\r\n\t\tSmartTV smart2 = new TV();\r\n\t}\r\n}\r\n```\r\n\r\n다른건 명확하므로 필요없고, 12번째 줄을 자세히 보자. `TV`와 `SmartTV`는 엄연히 다른 객체임에도 불구하고 인스턴스가 정상적으로 생성된다.\r\n\r\n이는 객체의 다형성이 적용된 결과로, `SmartTV`는 `TV`를 상속받아 만들어진 객체다. 즉 `SmartTV`는 `TV`를 온전히 포함하고 있으므로 `TV`의 인스턴스로 생성이 가능하다. 이러한 객체의 다형성은 객체를 상속했을 때 뿐만 아니라, 인터페이스를 상속할때도 가능하다.\r\n\r\n#### 다형성이 적용된 인스턴스\r\n\r\n객체의 다형성을 다룰 때 주의할 점이 한 가지 있다. 우리는 위에서 `SmartTV` 객체를 `TV`로 생성했다. 뭐 다형성 어쩌고로 인해 인스턴스가 정상적으로 생성됨은 알겠는데, 이 `TV`인듯 `SmartTV`인듯한 인스턴스는 어떻게 동작할까?\r\n\r\n이렇게 생성된 인스턴스 `tv2`는 `SmartTV`에 선언된 메소드들 중 `TV`에 선언된 메소드와 일치하는 메소드만 사용 가능하다.\r\n\r\n``` java\r\ninterface Movable\r\n{\r\n\tvoid move(boolean direction);\r\n}\r\n\r\nclass Unit implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n\r\n\tpublic void work(String act)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n이번엔 인터페이스를 예시로 들어보자. 움직임에 대한 동작이 기술되어있는 인터페이스 `Movable`과 이를 상속받은 `Unit` 객체가 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = new Unit();\r\n\r\n\t\t// Movable에 존재하는 메소드이므로 호출 가능\r\n\t\tmovable.move(true);\r\n\r\n\t\t// Movable엔 없는 Unit만의 고유 메소드이므로 호출 불가능\r\n\t\tmovable.work(\"run\");\r\n\t}\r\n}\r\n```\r\n\r\n객체의 다형성으로 인해 `Unit` 객체를 `Movable`로 생성할 수 있음은 잘 알 것이다. `movable`이라는 인스턴스를 만들고 `move()`, `work()` 메소드를 각각 호출해보자.\r\n\r\n`move()`의 경우 `Movable` 인터페이스에서 상속받아 구현한 메소드고, `work()`는 `Unit`에서 직접 생성한 메소드다. 이 경우 `Unit`의 메소드를 호출할 수 있지만, `Movable`에 선언된 메소드만 호출 가능하다. 즉, `Unit`과 `Movable` 객체 간에 겹치는 메소드만 사용이 호출이 가능하다. 이 때 메소드의 동작은 `Unit`의 메소드로 동작한다.\r\n\r\n객체의 다형성을 사용하면 동일한 객체를 상속받은 여러 객체들을 다루기 매우 편리하다.\r\n\r\n``` java\r\nclass UnitA implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\twork(\"run\");\r\n\t}\r\n\r\n\tprivate void work(String act)\r\n\t{\r\n\t\tSystem.out.println(\"work: \" + act);\r\n\t}\r\n}\r\n\r\nclass UnitB implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tdoing(3);\r\n\t}\r\n\r\n\tprivate void doing(int num)\r\n\t{\r\n\t\tSystem.out.println(\"doing: \" + num);\r\n\t}\r\n}\r\n\r\nclass UnitC implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tactive(true);\r\n\t}\r\n\r\n\tprivate void active(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(\"active: \" + flag);\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 동일한 인터페이스 `Movable`을 상속받은 여러 객체가 있다고 가정하자. 이 객체들은 각각 개별적인 객체지만, `Movable`을 상속받았으므로, 세 객체 모두 다형성을 통해 `Movable` 인스턴스로 할당할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = switch (new Random().nextInt(3))\r\n\t\t{\r\n\t\t\tcase 0 -> new UnitA();\r\n\t\t\tcase 1 -> new UnitB();\r\n\t\t\tcase 2 -> new UnitC();\r\n\t\t\tdefault -> null;\r\n\t\t};\r\n\t\t\r\n\t\tmovable.move(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n# 실행 시마다 달라짐\r\nwork: run\r\n```\r\n\r\n실행 시마다 `UnitA`, `UnitB`, `UnitC` 중 무작위로 선택된 객체의 인스턴스를 `Movable`에 할당한다. 서로 같은 객체임에도 `Movable`이라는 부모 객체로 인스턴스를 할당하여 공통된 메소드를 호출할 수 있다. 호출된 공통 메소드인 `move()` 내부에는 `Unit` 고유의 메소드가 포함되어도 상관없다.\r\n\r\n이처럼 메소드의 입력으로 여러 타입의 파라미터가 와야할 경우, 이 파라미터들이 동일한 객체를 상속하고 있다면 다형성을 적용하여 공통된 타입으로 다룰 수 있다.\r\n\r\n### 메소드의 다형성\r\n\r\n메소드 역시 다형성을 적용할 수 있다. 객체의 다형성은 객체 자신의 타입과 연관되지만, 메소드의 다형성은 메소드가 사용하는 파라미터의 타입과 연관된다.\r\n\r\n메소드의 다형성은 <span class=\"red-400\">메소드가 서로 동일한 이름을 가지더라도, 입력받는 파라미터가 다르면 각각 개별적인 메소드로 취급</span>함을 의미한다.\r\n\r\n``` java\r\n/**\r\n * 컨버터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 23:46:44\r\n */\r\npublic class Converter\r\n{\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t */\r\n\tpublic void convert(int num)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"int: \").append(num));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param text: [String] 문자열\r\n\t */\r\n\tpublic void convert(String text)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"String: \").append(text));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param flag: [boolean] T/F\r\n\t */\r\n\tpublic void convert(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"boolean: \").append(flag));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t */\r\n\tpublic void convert(char c)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"char: \").append(c));\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `Converter` 클래스로, 메소드의 이름이 모두 `convert`로 동일함을 알 수 있다. 하지만 각각의 메소드 모두 매개변수가 다르다. 이 경우 다형성에 의해 각각의 메소드가 독립적인 메소드로 인정받게된다.\r\n\r\n다형성의 존재로 인해 코드의 일관성을 유지할 수 있다. 대표적으로 우리가 콘솔에 출력할 때 사용하는 `System.out.println()` 메소드가 이에 해당한다.\r\n\r\n``` java\r\npublic void println(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `System.out.println()`의 내부 소스다. 보다시피 이름이 동일하고, 동작까지도 콘솔에 출력하는 것으로 동일하지만 다형성으로 인해 각각의 메소드가 온전한 하나로 인정된다.\r\n\r\n만약 다형성이라는 개념이 없다면 어떨까? 동일한 동작을 함에도 매개변수가 달라진다는 이유만으로 비슷한 이름을 가진 메소드를 만들어야하고, 개발자는 각 매개변수에 맞게 메소드를 사용해야한다.\r\n\r\n``` java\r\npublic void printlnFloat(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnDouble(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnChar(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnString(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n즉, 위와 같은 설계가 강요된다. 코드를 설계하다보면 동일한 동작에 다양한 종류의 객체가 와야할 수도 있다. JAVA는 <span class=\"green-400\">하나의 매개변수 = 하나의 타입</span>이라는 원칙을 고수하므로, JavaScript와 같이 다양한 종류의 타입이 매개변수로 올 수 없다.\r\n\r\n다형성을 활용하면 이러한 문제를 효과적으로 타개할 수 있다. 동일한 이름으로 다양한 매개변수를 받는 메소드를 작성하면, 개발자는 이를 사용 시 별다른 타입 구분 없이 마치 동일한 메소드를 사용한다는 개발 경험을 제공한다.\r\n\r\n``` java\r\n// println(String x)\r\nSystem.out.println(\"text\");\r\n\r\n// println(double x)\r\nSystem.out.println(1.5D);\r\n```\r\n\r\n위와 같이 개발자가 별도로 타입을 구분하지 않고 사용해도, 컴파일 시 해당 매개변수를 받는 메소드가 자동으로 호출된다.\r\n\r\n#### 반환값이 다른 메소드의 다형성?\r\n\r\n호기심이 많다면 이런 케이스를 생각해볼 수 있다. 매개변수에 대한 다형성이 있으면, 메소드의 반환값에 대한 다형성도 있지 않을까? 좋은 발상이지만, 아쉽게도 다형성은 반드시 매개변수로만 구분한다. <span class=\"red-400\">반환값의 경우 다형성이 적용되지 않는다.</span>\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 경우, 매개변수가 `char[]`, `String`으로 각각 다르므로 다형성이 적용된다.\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic boolean println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n```\r\n\r\n반대로 위 경우는 메소드명과 매개변수는 동일하지만, 반환값이 다르다. 매개변수와 달리 <span class=\"red-400\">반환값은 다형성이 적용되지 않으므로, 중복된 메소드로 취급</span>된다. 따라서 위 소소는 컴파일 오류를 일으킨다.\r\n\r\n# 마무리\r\n\r\n객체의 다형성은 생산성에 초점이 맞춰져있다. 동일한 메소드로 여러 타입의 데이터를 처리하거나, 공통 상속된 객체를 처리함으로써 중복된 코드 소요를 제거하고 개발 편의성을 높여준다. 다형성을 적극적으로 활용하여 중복된 코드는 줄이고, 데이터 처리의 범위는 넓혀보자.","url":["2021-08-12-polymorphism","2021","08","12","polymorphism"]},{"header":{"title":"[OOP] 객체지향의 특징 - 상속(Inheritance)","excerpt":"나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다. 나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 상속이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-11T20:32:33","type":"posts","category":"CS","tag":["CS","객체지향","상속","추상"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-11-inheritance.md","content":"\r\n# 상속 (Inheritance)\r\n\r\n나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다.\r\n\r\n나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 **상속**이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.\r\n\r\n<p align=\"center\"><i><del>평범하게 살던 내가 콤퓨타 이세카이에선 상속자???!!?!?!</del></i></p>\r\n\r\n하지만 객체지향 언어에서는 누구나 필요에 의해 쉽게 상속받을 수 있다!\r\n\r\n객체지향 역시 동일한 개념이 존재한다. 객체지향에서의 <span class=\"teal-400\">상속</span>이란 <span class=\"blue-400\">객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용</span>하는 것을 의미한다.\r\n\r\n이 때 객체를 상속받은 객체는 <span class=\"teal-400\">자식</span>, 상속된 객체는 <span class=\"teal-400\">부모</span>라 칭한다.\r\n\r\n자식 객체는 상속된 부모 객체의 은닉화 구성에 따라 정해진 변수, 메소드에 접근할 수 있다. 또한 부모 객체가 <span class=\"teal-400\">추상 객체</span>일 경우 <span class=\"teal-400\">추상 메소드</span>와 <span class=\"teal-400\">오버라이딩</span>(Overriding)을 통해 부모 객체의 메소드를 구현하거나 다룰 수 있다.\r\n\r\n## 추상 객체\r\n\r\n<span class=\"teal-400\">추상 객체</span>는 하나 이상의 추상 메소드를 포함하는 객체다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\nJAVA로 표현한 추상 클래스는 위와 같으며, 클래스의 맨 앞에 `abstract` 키워드를 적어 해당 객체가 추상 객체임을 표현할 수 있다.\r\n\r\n## 추상 메소드\r\n\r\n<span class=\"teal-400\">추상 메소드</span>는 자식 객체에서 구현해야하는 메소드다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\tpublic void normalMethod()\r\n\t{\r\n\t\tSystem.out.println(\"일반 메소드\");\r\n\t}\r\n\r\n\tabstract public void abstractMethod();\r\n}\r\n```\r\n\r\n위는 JAVA로 표현한 추상 객체다. `normalMethod()`은 일반적인 메소드고, `abstractMethod()`는 추상 메소드다. 추상 메소드는 일반적인 메소드와 큰 차이가 있는데, 메소드의 동작이 기술되어있지 않다.\r\n\r\n추상 메소드의 구현은 자식 객체가 담당하며, 아래 단계에서 이루어진다.\r\n\r\n* 추상 객체의 인스턴스 생성 시\r\n* 추상 객체를 상속받을 시\r\n\r\n일반적인 메소드는 자신의 객체에서 선언되어있다. 하지만 추상 메소드의 경우, 추상 객체를 할당받으려는 객체에서 선언이 이루어진다. 이 경우 어떤 메리트가 있을까?\r\n\r\n예를 들어, 부모 객체 `Main`과 이를 상속받은 자식 객체 `Sub`가 있다고 가정하자. 만약 동작 구조 상 `abstractMethod()`에서 자식 객체의 변수나 메소드를 사용해야만 한다면?\r\n\r\n`normalMethod()` 처럼 동작이 이미 부모 객체에 선언되는 경우 자식 객체의 요소를 반영하기가 매우 어렵다. 인스턴스를 생성하는 방법도 있겠지만 어떤 객체를 상속받을 지 알 수 없는 경우, 예상되는 객체의 인스턴스를 전부 할당받아놓는 게 아니라면 불가능에 가깝다. 그리고 이 방법의 경우 메모리 낭비가 너무 심해진다.\r\n\r\n반면 `abstractMethod()` 같은 추상 메소드의 경우 자식 객체에서 구현되기 때문에 자식 객체의 변수나 메소드에 직접적으로 접근할 수 있다. 때문에 자식 객체의 요소를 활용해서 동작을 구현해야 할 경우, 해당 메소드를 추상으로 정의하면 자식 객체의 특성에 맞게 구현하기 용이하다.\r\n\r\n### 추상 메소드 구현 - 인스턴스 생성 시\r\n\r\nJAVA를 통해 `Main`의 인스턴스를 `Sub`에서 생성해보자.\r\n\r\n``` java\r\npublic class Sub\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tMain main = new Main()\r\n\t\t{\r\n\t\t\t@Override\r\n\t\t\tpublic void abstractMethod()\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(text());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"Sub 객체의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n원래대로라면 `abstractMethod()` 메소드는 `Sub` 객체의 `text()`에 접근할 수 없다. `text()`는 `private` 접근제어자를 가지기 때문이다.\r\n\r\n하지만 추상 메소드의 경우 구현이 `Sub`에서 이루어지기 때문에 `Sub`의 모든 요소에 직접적으로 접근할 수 있다. 즉, `private` 같은 내부 메소드까지 전부 접근 가능하다.\r\n\r\n### 추상 메소드 구현 - 상속 시\r\n\r\nJAVA를 통해 `Main`을 `Sub`에 상속시켜보자.\r\n\r\n``` java\r\npublic class Sub extends Main\r\n{\r\n\t@Override\r\n\tpublic void abstractMethod()\r\n\t{\r\n\t\tSystem.out.println(text());\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"자식 객체 Sub의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n부모 객체에 추상 메소드가 있을 경우, 자식 객체는 이를 반드시 오버라이딩해야한다. 그러지 않을 경우 컴파일 오류를 일으킨다.\r\n\r\n마찬가지로 메소드의 구현이 자식 객체에서 이루어지므로, 자식 객체의 모든 요소에 접근할 수 있다.\r\n\r\n추상 메소드는 이처럼 구현의 주체를 자식 객체에게 전가함으로써, 자식 객체의 요소에 제한없이 접근할 수 있다. 원래라면 `public` 등으로 열어줬어야 함에도 자식 객체 내부에서 구현이 이루어지기 때문에 접근제어자를 변경할 필요가 없다.\r\n\r\n# 상속의 예제\r\n\r\nJAVA를 통해 객체의 상속이 어떤식으로 이루어지고, 어떤식으로 사용되는지 알아보자.\r\n\r\n``` java\r\nimport java.util.Date;\r\n\r\n/**\r\n * 컴퓨터 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:19:19\r\n */\r\nabstract public class Computer\r\n{\r\n\tprivate final String OS;\r\n\t\r\n\t/**\r\n\t * Computer 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Computer(String os)\r\n\t{\r\n\t\tthis.OS = os;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\tpublic void startup()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - started at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - shutdown at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 추상 함수\r\n\t */\r\n\tabstract public void run();\r\n}\r\n```\r\n\r\n여기 `Computer`라는 추상 객체가 존재한다. 이 객체는 `OS`라는 상태와 `startup`, `shutdown`, `run`이라는 동작을 가진다.\r\n\r\n이 중 `run`은 좀 특별한데, 동작은 적혀있으나, 어떤식으로 동작하는지에 대한 명세는 정해져있지 않다.\r\n\r\n이는 <span class=\"teal-400\">추상 객체</span>의 특징 중 하나로, 추상 객체는 하나 이상의 <span class=\"teal-400\">추상 메서드</span>를 포함할 수 있다. 추상 메서드는 구현되지 않은 메서드로, **동작의 개념** 정도로만 이해하면 된다. <span class=\"red-400\">추상 메서드의 구현은 해당 객체를 상속받은 자식 객체에서 이루어진다.</span> 즉, `run` 추상 메소드는 자식마다 제각각으로 구현된 동작을 수행한다.\r\n\r\n아래의 두 클래스 `Asus`와 `Dell`은 `Computer` 추상 클래스를 상속받은 자식 클래스다.\r\n\r\n``` java\r\n/**\r\n * ASUS 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:24:50\r\n */\r\npublic class Asus extends Computer\r\n{\r\n\t/**\r\n\t * Asus 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Asus(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"ASUS 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\n/**\r\n * DELL 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:26:46\r\n */\r\npublic class Dell extends Computer\r\n{\r\n\t/**\r\n\t * Dell 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Dell(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void startup()\r\n\t{\r\n\t\tsuper.startup();\r\n\t\t\r\n\t\tSystem.out.println(\"시스템 안정화 수행\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\t@Override\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(\"시스템 프로세스 정리 수행\");\r\n\t\t\r\n\t\tsuper.shutdown();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"DELL 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n`Asus`와 `Dell` 모두 `Computer`를 상속받았음을 확인할 수 있다. 또한 모두 `run` 함수가 제각각 구현된 것 역시 확인할 수 있다.\r\n\r\n그런데 `Asus`와 달리 `Dell`은 부팅 시와 종료 시 각각 시스템의 안정성을 위한 사전/후 작업이 추가됐다.\r\n\r\n이러한 사전/후 작업을 구현하기 위해 `startup`, `shutdown`을 오버라이딩한다. 이 과정을 통해 시작과 종료 함수에 각각 원하는 동작을 추가한다.\r\n\r\n> **super?**  \r\n> 자식 클래스에서 부모 클래스를 호출할 때 `super` 키워드를 이용해 호출한다. `Dell`의 오버라이딩 메소드 동작에서 활용됨을 알 수 있다. `super.shutdown()`은 부모 클래스 `Computer`의 메소드인 `shutdown()`을 호출한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tDell dell = new Dell(\"Windows 10 Pro\");\r\n\t\tAsus asus = new Asus(\"Ubuntu 21.04\");\r\n\t\t\r\n\t\tdell.startup();\r\n\t\tdell.run();\r\n\t\tdell.shutdown();\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tasus.startup();\r\n\t\tasus.run();\r\n\t\tasus.shutdown();\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\nWindows 10 Pro - started at Fri Aug 06 22:54:39 KST 2021\r\n시스템 안정화 수행\r\nDELL 작업 수행\r\n시스템 프로세스 정리 수행\r\nWindows 10 Pro - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n\r\nUbuntu 21.04 - started at Fri Aug 06 22:54:39 KST 2021\r\nASUS 작업 수행\r\nUbuntu 21.04 - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n```\r\n\r\n`Asus`와 `Dell`의 메소드를 순서대로 수행하면 위와 같은 결과가 나온다. `Dell`의 시작, 종료 간 시스템 동작이 수행됨을 확인할 수 있다.\r\n\r\n# 정리\r\n\r\n객체지향은 모든 객체의 모듈화를 추구한다. 좋은 모듈화는 <span class=\"amber-400\">캡슐화</span>, <span class=\"amber-400\">은닉화</span>가 적절히 구현되고 유지되는 것을 지향한다.\r\n\r\n하지만 포장이 견고하면 뜯기 어렵듯이, 탄탄한 모듈화는 모듈이 경직된다. 재사용의 범위가 제한되는 것 뿐만 아니라, 이를 이용한 확장 또한 어려울 것이다. 만약 객체지향에 이 두 개념만 있었다면 개발자는 재사용성과 모듈화를 적절히 타협하며 객체를 구현했을 것이다.\r\n\r\n하지만 상속이라는 개념의 존재로 인해 객체에 지정된 모듈화를 전혀 해치지 않으면서 재사용성, 확장성을 보장받을 수 있다. 객체지향의 모듈화로 인한 딜레마를 상쇄하는 키치한 개념이 아닐 수 없다. 개인적으로는 객체지향의 특징 중 가장 중요한 특징이라고 생각한다. 물론 객체지향 중에서도 매우 어려운 개념이지만, 이를 잘 이해하면 조금 더 객체지향다운 코드를 짤 수 있을 것이다.","url":["2021-08-11-inheritance","2021","08","11","inheritance"]},{"header":{"title":"[OOP] 객체지향의 특징 - 캡슐화(Encapsulation)와 정보 은닉","excerpt":"객체. 즉, 클래스의 내부 변수와 메소드를 하나로 패키징하는 특징이다. 객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다. 캡슐화와 비슷한 개념으로 정보 은닉이라는 개념이 있다. 정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다. 이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-08T11:05:05","type":"posts","category":"CS","tag":["CS","객체지향","캡슐화","정보 은닉","접근제어자"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-08-encapulation.md","content":"\r\n# 캡슐화 (Encapsulation)\r\n\r\n객체. 즉, <span class=\"blue-400\">클래스의 내부 변수와 메소드를 하나로 패키징</span>하는 특징이다.\r\n\r\n객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다.\r\n\r\n<span class=\"primary\">캡슐화</span>와 비슷한 개념으로 <span class=\"primary\">정보 은닉</span>이라는 개념이 있다.\r\n\r\n정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다.\r\n\r\n이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.\r\n\r\n# 캡슐화의 예제\r\n\r\nJAVA의 경우 <span class=\"orange-700\">접근제어자</span>를 통해 객체의 캡슐화, 은닉화를 구현한다.\r\n\r\n* `public`: 다른 객체에서 해당 객체의 인스턴스를 생성하여 접근할 수 있다.\r\n* `protected`: 해당 객체를 상속받은 객체 내부에서 접근할 수 있다. 단순 인스턴스에선 접근할 수 없다.\r\n* `default`: 동일한 패키지 내의 객체에서 인스턴스를 생성하여 접근할 수 있다.\r\n* `private`: 선언된 객체 내부에서만 사용 가능하며, 외부에선 어떠한 방법으로든 해당 지시자를 가진 변수 혹은 메소드를 사용할 수 없다.\r\n\r\n대표적인 접근제어자는 위와 같으며, 이를 통해 <span class=\"red-400\">객체 내부의 상태와 동작의 접근 방법을 강제</span>할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\npublic class B\r\n{\r\n\tprivate void publicMethod()\r\n\t{\r\n\t\tSystem.out.println(\"public 메소드 접근\");\r\n\t}\r\n\r\n\tdefault void defaultMethod()\r\n\t{\r\n\t\tSystem.out.println(\"default 메소드 접근\");\r\n\t}\r\n\r\n\tprotected void protectedMethod()\r\n\t{\r\n\t\tSystem.out.println(\"protected 메소드 접근\");\r\n\t}\r\n\r\n\tprivate void privateMethod()\r\n\t{\r\n\t\tSystem.out.println(\"private 메소드 접근\");\r\n\t}\r\n}\r\n```\r\n\r\n## public 요소의 접근 방법\r\n\r\n`public`은 접근제어자 중 <span class=\"orange-400\">가장 개방적인 접근제어자</span>다. 이름부터가 공공(public)이니 말 다했다.\r\n\r\n별다른 조건 없이 객체 `A`에서 객체 `B`의 새로운 인스턴스를 생성하면 `A`에서 `B`의 `public` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `publicMethod()`에 정상적으로 접근 가능하다. 반드시 외부의 접근이 필요한 멤버 변수나 메소드에만 사용해야한다. 해당 접근제어자를 <span class=\"red-400\">남용할 경우 불필요한 요소를 개방</span>하게 되어 정보 은닉이 이루어지지 않는다.\r\n\r\n## protected 요소의 접근 방법\r\n\r\n`protected`는 상속과 연관된 접근제어자다. 이 제어자를 가진 요소는 <span class=\"orange-400\">해당 객체를 상속받은 객체만 접근</span>할 수 있다.\r\n\r\n객체 `A`에서 객체 `B`를 상속받는다. 이 때 자식 객체는 `A`, 부모 객체는 `B`가 된다. 상속을 받게 되면 `A`에서 `B`의 `protectedMethod` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A extends B\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tprotectedMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `protectedMethod()`에 정상적으로 접근 가능하다. `public`과 달리 별도의 인스턴스는 받지 않아도 된다. 이는 `A`가 `B`를 상속받기 때문에, `B`의 <span class=\"lightBlue-400\">멤버 변수와 메소드의 접근 권한을 일부 승계</span>하기 때문\r\n\r\n## default 요소의 접근 방법\r\n\r\n`default`는 제한적인 `public` 접근제어자라 할 수 있다. 이 제어자를 가진 요소는 <span class=\"orange-400\">동일한 패키지 내에서만 접근</span>할 수 있다.\r\n\r\n객체 `A`와 `B`가 동일한 패키지에 위치할 때, `A`에서 `B`의 새로운 인스턴스를 할당받으면 `defaultMethod()`에 접근할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n패키지가 같을 경우 `public`을, 패키지가 다를 경우 `private`과 같은 동작을 한다. 동일한 패키지 여부에 따라 개방/폐쇄가 갈린다. 만약 변수나 메소드에 <span class=\"lightBlue-400\">별다른 접근제어자를 지정하지 않았다면 이 제어자가 기본으로 적용</span>된다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tvoid defaultMethod()\r\n\t{\r\n\t\t// 접근제어자를 지정하지 않으면 default로 자동 지정\r\n\t}\r\n}\r\n```\r\n\r\n## private 요소의 접근 방법\r\n\r\n`private`는 반드시 <span class=\"orange-400\">선언된 객체 내부에서만 접근</span>할 수 있다. 즉, `B`가 아닌 어떤 클래스에서도 `privateMethod()`에 접근할 수 없다. 메소드 뿐만 아니라 멤버 변수도 마찬가지다. 은닉화를 위한 접근제어자로, <span class=\"red-400\">해당 접근제어자의 사용을 통해 내부 변수나 메소드를 은닉</span>할 수 있다.\r\n\r\n객체는 기본적으로 은닉화가 이루어져야한다. 객체를 구현할 때 개방/폐쇄의 명세를 디테일하게 명세하지 않았다면 일단은 `private`로 만드는 것이 좋다. 이후 설계 과정에서 적절한 개방이 필요할 경우 해당 메소드나 변수를 개방한다. 이와 같은 방식은 필요 시에 요소를 적절히 개방함으로써, 차후 프로젝트나 객체의 규모가 커짐에 따라 놓칠 수 있는 불필요한 개방을 미연에 방지할 수 있다. 즉, 올바른 캡슐화/은닉화를 구현하는데 용이한 방식이다.\r\n\r\n# 정리\r\n\r\n별다른 생각 없이 모든 메소드를 개방시킨 객체는 모듈이라 보기 어렵다. 반대로 모든 메소드를 은폐시킨 객체 역시 모듈로써의 의미가 전혀 없다. 즉, 객체가 모듈의 의미를 갖기 위해선 적절히 설계된 개방/폐쇄가 필요하다는 뜻이다.\r\n\r\n캡슐화와 정보 은닉을 메소드가 모듈로써의 의미를 갖게 헤주는 중요한 요소이다. 사용하는 언어의 접근제어자에 대한 이해를 통해 올바른 캡슐화, 정보 은닉을 지키는 객체를 구현하자.","url":["2021-08-08-encapulation","2021","08","08","encapulation"]},{"header":{"title":"[OOP] 객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"IT 업계에 종사하게 된다면 십중팔구 JAVA, C++, C# 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 객체지향언어라는 점이다. 물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, C의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"\r\n# OOP\r\n\r\nIT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.\r\n\r\n물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.\r\n\r\n# 객체지향에 대해 설명해보세요.\r\n\r\n제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.\r\n\r\n내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.\r\n\r\n## 객체\r\n\r\n**객체**지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 **객체**란 개념에 대해 이해할 필요가 있다.\r\n\r\n객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.\r\n\r\n모든 객체는 상태와 동작을 가진다. 예를 들어, **TV**를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.\r\n\r\nTV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.\r\n\r\n이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.\r\n\r\n국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.\r\n\r\n| 객체지향 |     JAVA      |\r\n| :------: | :-----------: |\r\n|   객체   |    클래스     |\r\n|   상태   |   멤버 변수   |\r\n|   동작   | 메소드 (함수) |\r\n\r\n여기 **자동차**라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.05 22:06:24\r\n */\r\npublic class Car\r\n{\r\n\t// 시동 여부\r\n\tprivate final boolean IS_STARTED = false;\r\n\t\r\n\t// 최대 속력\r\n\tprivate final int MAX_SPEED;\r\n\t\r\n\t// 현재 속력\r\n\tprivate int speed;\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param maxSpeed: [int] 최대 속도\r\n\t */\r\n\tpublic Car(int maxSpeed)\r\n\t{\r\n\t\tMAX_SPEED = maxSpeed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 결과\r\n\t */\r\n\tpublic boolean startUp()\r\n\t{\r\n\t\treturn !IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 종료 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 종료 결과\r\n\t */\r\n\tpublic boolean shutdown()\r\n\t{\r\n\t\treturn IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 현재 속도 반환 함수\r\n\t *\r\n\t * @return [int] 현재 속도\r\n\t */\r\n\tpublic int getSpeed()\r\n\t{\r\n\t\treturn speed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void upSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 가속된 값이 최대 속도를 넘지 않을 경우\r\n\t\t\tif (MAX_SPEED >= speed + amount)\r\n\t\t\t{\r\n\t\t\t\tspeed += amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가속된 값이 최대 속도를 넘을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = MAX_SPEED;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 감속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void downSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 감속된 값이 0보다 클 경우\r\n\t\t\tif (0 <= speed - amount)\r\n\t\t\t{\r\n\t\t\t\tspeed -= amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 감속된 값이 0보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.\r\n\r\n<br />\r\n\r\n* **멤버 변수** (상태)\r\n  * `IS_STARTED` 자동차 시동 여부\r\n  * `MAX_SPEED`: 최대 속도\r\n  * `speed`: 현재 속도\r\n\r\n<br />\r\n\r\n* **메소드** (동작)\r\n  * `startUp`: 엔진 시동\r\n  * `shutdown`: 엔진 정지\r\n  * `getSpeed`: 현재 속도 표시\r\n  * `upSpeed`: 가속\r\n  * `downSpeed`: 감속\r\n\r\n<br />\r\n\r\nCar 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.\r\n\r\nCar 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.\r\n\r\n## 객체지향\r\n\r\n객체**지향**이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.\r\n\r\n모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.\r\n\r\n일례로 JAVA는 `String`, `HashMap` 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.\r\n\r\n# 그래서 이걸 왜 쓰는데?\r\n\r\n객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.\r\n\r\n그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?\r\n\r\n객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.\r\n\r\n## 장점\r\n\r\n* <span class=\"green-400\">코드 재사용성</span>  \r\n모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.\r\n\r\n* <span class=\"green-400\">간편한 유지보수</span>  \r\n객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.\r\n\r\n* <span class=\"green-400\">큰 규모의 프로그래밍에 유리</span>  \r\n객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.\r\n\r\n## 단점\r\n\r\n* <span class=\"red-400\">비교적 느린 속도</span>  \r\n절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.\r\n\r\n* <span class=\"red-400\">높은 설계역량 요구</span>  \r\n모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.\r\n\r\n* <span class=\"red-400\">코드의 잠재적인 복잡성</span>  \r\n높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.\r\n\r\n# 객체지향을 사용하는 언어들\r\n\r\n* JAVA\r\n* C++\r\n* C#\r\n* Python\r\n* Simula 67\r\n* Delphi\r\n* Swift\r\n* Ruby\r\n* Perl\r\n\r\n<del class=\"grey-600\">대부분 아는 얼굴들이구만</del>\r\n\r\n# 정리\r\n\r\n기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.\r\n\r\n하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.\r\n\r\n객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.\r\n\r\n절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.\r\n\r\n요즘 AI 기술이 발달함에 따라 [Copilot](https://copilot.github.com/) 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.\r\n\r\n나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"]}],"categories":{"WEB":{"count":7,"flag":true},"CS":{"count":10,"flag":true},"알고리즘":{"count":30,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false},"잡담":{"count":1,"flag":false}},"images":["celeb1.webp","celeb10.webp","celeb11.webp","celeb12.webp","celeb13.webp","celeb14.webp","celeb15.webp","celeb16.webp","celeb2.webp","celeb3.webp","celeb4.webp","celeb5.webp","celeb6.webp","celeb7.webp","celeb8.webp","celeb9.webp","city1.webp","city10.webp","city11.webp","city12.webp","city13.webp","city14.webp","city15.webp","city2.webp","city3.webp","city4.jpg","city4.webp","city5.webp","city6.webp","city7.webp","city8.webp","city9.webp","code1.webp","code2.webp","code3.webp","funk1.webp","funk2.webp","funk3.webp","funk4.webp","funk5.webp","funk6.webp","game1.webp","signal.webp"],"tag":"CS","page":1},"__N_SSG":true}