{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)","excerpt":"올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-13T01:37:48","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-13-single-responsibility-principle.md","content":"\r\n# 객체지향 5원칙\r\n\r\n올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 <span class=\"amber-600\">객체지향 5원칙</span>(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다.\r\n\r\n이 다섯가지 원칙은 아래와 같다.\r\n\r\n1. 단일 책임 원칙 (Single Responsibility Principle)\r\n2. 개방-폐쇄 원칙 (Open-Closed Principle)\r\n3. 리스코프 치환 원칙 (Liskov Substitution Principle)\r\n4. 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n5. 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n각 원칙의 영어 앞글자를 따 <span class=\"primary\">SOLID</span>원칙이라고도 한다.\r\n\r\n# 단일 책임 원칙 (Single Responsibility Principle)\r\n\r\n<span class=\"orange-400\">단일 책임 원칙</span>이란 <span class=\"orange-400\">하나의 객체는 반드시 하나의 동작만의 책임을 갖는다</span>는 원칙이다.\r\n\r\n모듈화가 강해질수록 다른 객체와의 의존/연관성이 줄어든다. 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어나며, 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게된다.\r\n\r\n객체가 담당하는 동작. 즉, 책임이 많아질 수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다. 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.\r\n\r\n# 코드로 보는 단일 책임 원칙\r\n\r\n자동차는 휠의 구동 특성에 따라 전륜(FWD), 후륜(RWD), 사륜(AWD)로 나뉘며, 그 특성은 아래와 같다.\r\n\r\n* 전륜 구동인 경우 앞의 두 바퀴에만 동력을 전달한다.\r\n* 후륜 구동인 경우 뒤의 두 바퀴에만 동력을 전달한다.\r\n* 사륜 구동인 경우 전체 바퀴에 동력을 전달한다.\r\n\r\n이를 객체로 구현해보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\npublic class Car\r\n{\r\n\tprivate final String WD;\r\n\t\r\n\tprivate final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tswitch (WD.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"FWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"RWD\" -> {\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"AWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n여기 `Car` 객체가 있다. `Car`는 생성 시 파라미터로 <span class=\"orange-400\">휠 구동 방식</span>을 받는다.\r\n\r\n`Car`에는 주행 동작을 구현하는 `run()`메소드가 있으며, 이 메소드는 파라미터로 <span class=\"orange-400\">동력</span>을 받는다. 이후 휠 구동 방식에 따라 올바른 휠에 동력을 할당하고 휠의 상태를 출력한다.\r\n\r\n휠의 구동 방식 별 동작이 하나의 책임으로 본다면 이 객체가 짊어지는 책임은 무려 세 가지나 된다. 이렇게 하나의 객체에 너무 많은 책임이 몰려있을 경우, 프로젝트에서 해당 객체의 의존성이 높아지게된다. 이러한 현상은 객체지향의 주요 특징 중 하나인 캡슐화를 정면으로 부정한다. 그 뿐만 아니라, 각자의 코드가 서로 의존될 경우, 코드 수정에 따른 영향도 역시 높아지고, 범위 또한 넓어진다.\r\n\r\n위의 예시는 단일 책임 원칙을 설명하기 위한 단순한 예시로, 만약 코드의 규모가 크거나 복잡성이 심하다면 코드 수정 시 마다 오만가지 오류가 발생할 것이다. 그 뿐만 아니라 코드가 변경되는 과정에서 이미 정해진 코드의 리팩토링도 필요할 수 있다. 리팩토링이 리팩토링을 부르는 참사가 일어날 수도 있다. 여기서부터 코드가 지저분해지기 쉽다.\r\n\r\n단일 책임 원칙은 바로 이와 같은 상황을 방지하고자 수립된 원칙으로, <span class=\"red-400\">1객체 = 1책임</span>으로 최대한 객체를 간결하고 명확하게 설계할 것을 요구한다. 위 코드의 책임을 줄여 단일 책임 원칙을 지키려면 어떻게 해야할까?\r\n\r\n``` java\r\n/**\r\n * 자동차 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\nabstract public class Car\r\n{\r\n\tprotected final String WD;\r\n\t\r\n\tprotected final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tabstract public void run(int power);\r\n}\r\n```\r\n\r\n우선 공통된 인터페이스 내지는 상위 객체를 구현할 필요가 있다. 이 객체의 경우 생성자가 필요하므로 인터페이스 보단 상위 객체가 적합하다.\r\n\r\n> **네? 인터페이스 차별이요??**  \r\n> 인터페이스는 일반적인 객체 혹은 추상 객체와 달리 생성자를 강제할 수 없습니다.\r\n\r\n객체 `Car`를 상위 객체에 적용될 수 있게끔 구현한다. `run()` 메소드는 훨 구동 타입에 따라 동작이 달라지므로, `abstract` 지시자를 통해 추상 메소드로 선언한다. 해당 객체의 인스턴스를 생성하거나, 상속받는 객체가 직접 구현하게 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 전륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:03:13\r\n */\r\nclass FrontWheelCar extends Car\r\n{\r\n\t/**\r\n\t * FrontWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic FrontWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 후륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\nclass RearWheelCar extends Car\r\n{\r\n\t/**\r\n\t * RearWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic RearWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 사륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\npublic class AllWheelCar extends Car\r\n{\r\n\t/**\r\n\t * AllWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic AllWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n전륜, 후륜, 사륜에 해당하는 객체를 생성한다. 이 세 객체는 모두 `Car`에 포함되므로 `Car`를 상속받아 구현한다. 각 객체의 `run()` 메소드에 동작을 구현함으로써, 각각의 객체가 하나의 책임을 가지게 된다.\r\n\r\n이렇게 객체별로 책임을 나누면, 코드 변경 시에도 해당하는 객체만 수정하면 되므로, 의존성이 낮아져 올바른 모듈화를 구현할 수 있다. 그 뿐만 아니라 코드가 간결해져 유지보수가 쉬워질 뿐만 아니라 수정에 따른 영향도도 매우 작아진다.\r\n\r\n# 정리\r\n\r\n코드를 설계하다보면 하나의 객체가 너무 많은 동작을 담당하는 경우가 자주 발생한다. 필자 또한 무의식적으로 하나의 객체/메소드에 너무 많은 책임을 할당하는 일이 비일비재했다. 단일 책임 원칙은 이러한 개발 방향을 올바르게 잡아준다.\r\n\r\n가급적 단일 책임 원칙을 고수하여 올바른 객체를 구현할 수 있도록 해보자.","url":["2021-08-13-single-responsibility-principle","2021","08","13","single-responsibility-principle"]},"next":{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-15T13:42:11","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-15-liskov-subsitution-principle.md","content":"\r\n# 리스코프 치환 원칙 (Liskov Subsitution Principle)\r\n\r\n<span class=\"orange-400\">리스코프 치환 원칙</span>은 부모 객체와 이를 상속한 자식 객체가 있을 때 <span class=\"red-600\">부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다</span>는 원칙이다.\r\n\r\n객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.\r\n\r\n리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.\r\n\r\n# 코드로 보는 리스코프 치환 원칙\r\n\r\n리스코프 치환 원칙을 설명할 때 많이 사용하는 예제로 직사각형과 정사각형의 관계가 있다.\r\n\r\n## 리스코프 치환 원칙을 위배한 코드\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\npublic class Rectangle\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n`Rectangle`은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.\r\n\r\n정사각형 역시 넓게 보면 직사각형의 한 종류이니, <span class=\"red-400\">직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있을 것이라 생각했다.</span>\r\n\r\n``` java\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\npublic class Square extends Rectangle\r\n{\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\t@Override\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tsuper.setWidth(width);\r\n\t\tsuper.setHeight(getWidth());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\t@Override\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tsuper.setHeight(height);\r\n\t\tsuper.setWidth(getHeight());\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 정사각형 객체 `Square`를 `Rectangle`의 상속을 통해 쉽게 구현할 수 있었다.\r\n\r\n정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치시켜주도록 오버라이딩을 수행했다.\r\n\r\n구현한 `Rectangle`의 넓이를 구해보자.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Rectangle();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n```\r\n\r\n`Rectangle`의 넓이를 구하는 소스는 이와 같다. 너비가 10, 높이가 5로 할당됐으므로 넓이 50이 정상적으로 반환된다.\r\n\r\n리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, `Rectangle`을 상속받은 `Square`로 대체하여 넓이를 구해보자.\r\n\r\n`Square`가 `Rectangle`을 완전히 대체했다면 동일한 결과인 50이 반환되어야 한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Square();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n25\r\n```\r\n\r\n어째서인지 넓이는 50이 아닌 25로 반환됐다. 자세히 살펴보니, 마지막에 수행된 `setHeight(5)`가 객체의 너비/높이를 모두 5로 할당했다. 그러니 넓이도 당연히 25가 출력될 수밖에 없었던 걸로 보인다. 즉, 이 객체는 리스코프 치환 원칙에 위배되는 코드다.\r\n\r\n곰곰히 생각해보면, 직사각형과 정사각형은 상속관계가 전혀 될 수 없다. 사각형의 특징을 서로 갖고있긴 하지만, 두 사각형 모두 사각형의 한 종류일 뿐으로, 하나가 다른 하나를 완전히 포함하지 못 하는 구조다.\r\n\r\n이렇게 잘못된 객체를 상속하거나, 올바르게 확장하지 못 할 경우 겉으로 보기엔 정상적이지만 올바른 객체는 아니다.\r\n\r\n## 리스코프 치환 원칙을 준수한 코드\r\n\r\n그렇다면 이 코드를 어떻게 리스코프 치환 원칙에 부합하게끔 구성할 수 있을까?\r\n\r\n답은 올바른 상속과 구현에 있다. 앞서 설명했다시피, 직사각형과 정사각형은 상속의 관계가 성립되기 어렵다. 따라서 이보다 더 상위 개념인 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속받으면 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 사각형 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:39:02\r\n */\r\npublic class Shape\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n위와 같이 `Shape`라는 사각형 객체를 구현한다.\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\nclass Rectangle extends Shape\r\n{\r\n\t/**\r\n\t * Rectangle 생성자 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic Rectangle(int width, int height)\r\n\t{\r\n\t\tsetWidth(width);\r\n\t\tsetHeight(height);\r\n\t}\r\n}\r\n\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\nclass Square extends Shape\r\n{\r\n\t/**\r\n\t * Square 생성자 함수\r\n\t *\r\n\t * @param length: [int] 길이\r\n\t */\r\n\tpublic Square(int length)\r\n\t{\r\n\t\tsetWidth(length);\r\n\t\tsetHeight(length);\r\n\t}\r\n}\r\n```\r\n\r\n`Shape`를 상속받는 두 사각형 `Rectangle`과 `Square` 객체는 위와 같다. `Rectangle`은 인스턴스 생성 시 `width`와 `height`를 파라미터로 받으며, `Square`는 각 변의 길이가 모두 동일하므로 `length` 하나만을 파라미터로 받는다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tShape rectangle = new Rectangle(10, 5);\r\n\t\tShape square = new Square(5);\r\n\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t\tSystem.out.println(square.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n25\r\n```\r\n\r\n이제 더 이상 `Rectangle`과 `Square`가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.\r\n\r\n# 정리\r\n\r\n리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고한다. 위의 직사각형과 정사각형의 케이스처럼 올바르지 못한 상속관계는 제거하고, 부모 객체의 동작을 완벽하게 대체할 수 있는 관계만 상속하도록 코드를 설계해야한다.\r\n\r\n리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요하다.\r\n\r\n부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙.\r\n","url":["2021-08-15-liskov-subsitution-principle","2021","08","15","liskov-subsitution-principle"]}},"group":[{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙이다. 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다. 위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다. 왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, Method1을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다. 하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-16T19:24:57","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-16-interface-segregation-principle.md","content":"\r\n# 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n\r\n<span class=\"orange-400\">인터페이스 분리 원칙</span>이란 <span class=\"red-600\">객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다</span>는 원칙이다.\r\n\r\n구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128585790-a761f795-b4da-4a52-865d-d2dd4b858f20.png)\r\n\r\n위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다.\r\n\r\n왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, `Method1`을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다.\r\n\r\n하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.\r\n\r\n# 코드로 보는 인터페이스 분리 원칙\r\n\r\n예시를 통해 인터페이스 분리 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 인터페이스 분리 원칙을 준수하지 않은 코드\r\n\r\n예를 들어, 스마트폰이라는 객체가 있다고 가정하자. 이 스마트폰 객체는 비교적 최신에 나온 덕분에 일반적인 스마트폰 기능 외에도 무선 충전, AR 뷰어, 생체인식 등의 다채로운 기능을 포함하고 있다.\r\n\r\n이를 가지고 S20을 구현하면 스마트폰 객체의 동작 모두가 필요하므로 ISP를 만족한다. 그러나 S2를 구현할 경우, 무선 충전, 생체인식과 같은 기능을 제공하지 않는다. 그럼에도 불구하고 부모 객체인 스마트폰에 이러한 인터페이스가 포함되어 있으므로, S2 입장에서는 필요하지도 않은 기능을 구현해야하는 낭비가 발생한다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\nabstract public class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선 충전\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tabstract public void biometrics();\r\n}\r\n```\r\n\r\n위와 같이 구현된 `SmartPhone` 객체가 있다. 생체인식을 담당하는 `biometrics()` 메소드의 경우, 기기에 등록된 생체정보를 활용해야 하므로 추상 메소드로 선언되어있다. 이 객체를 상속하여 `S20`과 `S2`를 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"S20 생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20`은 모든 기능이 필요하기 때문에, `SmartPhone`의 모든 메소드를 사용해야하므로, 불필요한 메소드가 없는 상태다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 무선충전, AR, 생체인식이 지원되지 않는 기기다. 그럼에도 불구하고 `SmartPhone`의 상속으로 인해 해당 기능의 메소드를 강제로 상속받게 된다. 더군다나 `biometrics()`의 경우 추상 메소드이므로 필요하지도 않은 기능을 구현까지 해야한다. 이러한 상속의 특징은 부모 객체의 규모가 매우 클 경우, 개발 편의성의 극심한 저하로 이뤄진다. 필요하지도 않은 수십개의 메소드를 일일히 오버라이딩하여 적절한 처리를 해준다고 생각해보자.\r\n\r\n## 인터페이스 분리 원칙을 준수한 코드\r\n\r\n객체의 특성을 확장을 통해 다른 객체를 편하게 구현하기 위한 것이 상속인데, 위와 같은 상황은 전혀 편하지 않다. 이는 부모 객체의 설계가 잘 못 됐을 수도 있고, 취지에 맞지 않는 객체를 상속했을 수도 있다. 이유야 어찌됐든 해결해야한다는 사실엔 변함이 없다.\r\n\r\n그렇다면 이 현상은 어떻게 해결할 수 있을까? 객체의 메소드를 각각 인터페이스로 만들면 된다. 각 객체는 필요한 인스턴스만 상속하면 되므로 필요한 동작만을 상속/구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\npublic class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n}\r\n```\r\n\r\n`SmartPhone` 객체는 모든 스마트폰에 적용되는 보편적인 동작만을 가지도록 변경했다.\r\n\r\n``` java\r\n/**\r\n * 무선충전 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:23:33\r\n */\r\npublic interface WirelessChargable\r\n{\r\n\t/**\r\n\t * 무선충전 추상 함수\r\n\t */\r\n\tvoid wirelessCharge();\r\n}\r\n\r\n/**\r\n * AR 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:24:29\r\n */\r\npublic interface ARable\r\n{\r\n\t/**\r\n\t * AR 추상 함수\r\n\t */\r\n\tvoid ar();\r\n}\r\n\r\n/**\r\n * 생체인식 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:25:08\r\n */\r\npublic interface Biometricsable\r\n{\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tvoid biometrics();\r\n}\r\n```\r\n\r\n각 기능의 인터페이스는 위와 같다. 원래 `SmartPhone`의 객체의 메소드였던 각 기능은 인터페이스 단위로 나뉘어졌음에 주목하자.\r\n\r\n이를 통해 `S20`과 `S2` 모두 필요한 객체만을 상속받아 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone implements WirelessChargable, ARable, Biometricsable\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선충전 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20` 객체의 코드다. `SmartPhone`을 상속받았으며, 인터페이스로 `WirelessChargable`, `ARable`, `Biometricsable`을 모두 상속받아 구현하고 있다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\t@Override\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(\"In S2\");\r\n\t\t\r\n\t\tsuper.message(number, text);\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 특수 기능이 구현되어있지 않으므로, 기본적인 `SmartPhone` 객체만을 상속받아 구현된다.\r\n\r\n인터페이스는 다중 상속을 지원하므로, 필요한 기능을 인터페이스로 나누면 해당 기능만을 상속받을 수 있다. 그 밖에 추후 업데이트 등을 통해 추가적인 기능이 탑재된다면, 같은 원리로 인터페이스를 설계해서 사용하면 필요한 객체에 필요한 기능을 쉽게 추가할 수 있다.\r\n\r\n# 정리\r\n\r\n인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙이다. 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제가한다. 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킨다.\r\n\r\n객체를 상속할 땐 해당 객체가 상속 받는 객체에 적합한 객체인지, 의존적인 기능이 없는 지 판단하여 올바른 객체를 구현, 상속하도록 하자.","url":["2021-08-16-interface-segregation-principle","2021","08","16","interface-segregation-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-15T13:42:11","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-15-liskov-subsitution-principle.md","content":"\r\n# 리스코프 치환 원칙 (Liskov Subsitution Principle)\r\n\r\n<span class=\"orange-400\">리스코프 치환 원칙</span>은 부모 객체와 이를 상속한 자식 객체가 있을 때 <span class=\"red-600\">부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다</span>는 원칙이다.\r\n\r\n객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.\r\n\r\n리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.\r\n\r\n# 코드로 보는 리스코프 치환 원칙\r\n\r\n리스코프 치환 원칙을 설명할 때 많이 사용하는 예제로 직사각형과 정사각형의 관계가 있다.\r\n\r\n## 리스코프 치환 원칙을 위배한 코드\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\npublic class Rectangle\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n`Rectangle`은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.\r\n\r\n정사각형 역시 넓게 보면 직사각형의 한 종류이니, <span class=\"red-400\">직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있을 것이라 생각했다.</span>\r\n\r\n``` java\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\npublic class Square extends Rectangle\r\n{\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\t@Override\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tsuper.setWidth(width);\r\n\t\tsuper.setHeight(getWidth());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\t@Override\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tsuper.setHeight(height);\r\n\t\tsuper.setWidth(getHeight());\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 정사각형 객체 `Square`를 `Rectangle`의 상속을 통해 쉽게 구현할 수 있었다.\r\n\r\n정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치시켜주도록 오버라이딩을 수행했다.\r\n\r\n구현한 `Rectangle`의 넓이를 구해보자.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Rectangle();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n```\r\n\r\n`Rectangle`의 넓이를 구하는 소스는 이와 같다. 너비가 10, 높이가 5로 할당됐으므로 넓이 50이 정상적으로 반환된다.\r\n\r\n리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, `Rectangle`을 상속받은 `Square`로 대체하여 넓이를 구해보자.\r\n\r\n`Square`가 `Rectangle`을 완전히 대체했다면 동일한 결과인 50이 반환되어야 한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Square();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n25\r\n```\r\n\r\n어째서인지 넓이는 50이 아닌 25로 반환됐다. 자세히 살펴보니, 마지막에 수행된 `setHeight(5)`가 객체의 너비/높이를 모두 5로 할당했다. 그러니 넓이도 당연히 25가 출력될 수밖에 없었던 걸로 보인다. 즉, 이 객체는 리스코프 치환 원칙에 위배되는 코드다.\r\n\r\n곰곰히 생각해보면, 직사각형과 정사각형은 상속관계가 전혀 될 수 없다. 사각형의 특징을 서로 갖고있긴 하지만, 두 사각형 모두 사각형의 한 종류일 뿐으로, 하나가 다른 하나를 완전히 포함하지 못 하는 구조다.\r\n\r\n이렇게 잘못된 객체를 상속하거나, 올바르게 확장하지 못 할 경우 겉으로 보기엔 정상적이지만 올바른 객체는 아니다.\r\n\r\n## 리스코프 치환 원칙을 준수한 코드\r\n\r\n그렇다면 이 코드를 어떻게 리스코프 치환 원칙에 부합하게끔 구성할 수 있을까?\r\n\r\n답은 올바른 상속과 구현에 있다. 앞서 설명했다시피, 직사각형과 정사각형은 상속의 관계가 성립되기 어렵다. 따라서 이보다 더 상위 개념인 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속받으면 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 사각형 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:39:02\r\n */\r\npublic class Shape\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n위와 같이 `Shape`라는 사각형 객체를 구현한다.\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\nclass Rectangle extends Shape\r\n{\r\n\t/**\r\n\t * Rectangle 생성자 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic Rectangle(int width, int height)\r\n\t{\r\n\t\tsetWidth(width);\r\n\t\tsetHeight(height);\r\n\t}\r\n}\r\n\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\nclass Square extends Shape\r\n{\r\n\t/**\r\n\t * Square 생성자 함수\r\n\t *\r\n\t * @param length: [int] 길이\r\n\t */\r\n\tpublic Square(int length)\r\n\t{\r\n\t\tsetWidth(length);\r\n\t\tsetHeight(length);\r\n\t}\r\n}\r\n```\r\n\r\n`Shape`를 상속받는 두 사각형 `Rectangle`과 `Square` 객체는 위와 같다. `Rectangle`은 인스턴스 생성 시 `width`와 `height`를 파라미터로 받으며, `Square`는 각 변의 길이가 모두 동일하므로 `length` 하나만을 파라미터로 받는다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tShape rectangle = new Rectangle(10, 5);\r\n\t\tShape square = new Square(5);\r\n\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t\tSystem.out.println(square.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n25\r\n```\r\n\r\n이제 더 이상 `Rectangle`과 `Square`가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.\r\n\r\n# 정리\r\n\r\n리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고한다. 위의 직사각형과 정사각형의 케이스처럼 올바르지 못한 상속관계는 제거하고, 부모 객체의 동작을 완벽하게 대체할 수 있는 관계만 상속하도록 코드를 설계해야한다.\r\n\r\n리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요하다.\r\n\r\n부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙.\r\n","url":["2021-08-15-liskov-subsitution-principle","2021","08","15","liskov-subsitution-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)","excerpt":"올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-13T01:37:48","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-13-single-responsibility-principle.md","content":"\r\n# 객체지향 5원칙\r\n\r\n올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 <span class=\"amber-600\">객체지향 5원칙</span>(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다.\r\n\r\n이 다섯가지 원칙은 아래와 같다.\r\n\r\n1. 단일 책임 원칙 (Single Responsibility Principle)\r\n2. 개방-폐쇄 원칙 (Open-Closed Principle)\r\n3. 리스코프 치환 원칙 (Liskov Substitution Principle)\r\n4. 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n5. 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n각 원칙의 영어 앞글자를 따 <span class=\"primary\">SOLID</span>원칙이라고도 한다.\r\n\r\n# 단일 책임 원칙 (Single Responsibility Principle)\r\n\r\n<span class=\"orange-400\">단일 책임 원칙</span>이란 <span class=\"orange-400\">하나의 객체는 반드시 하나의 동작만의 책임을 갖는다</span>는 원칙이다.\r\n\r\n모듈화가 강해질수록 다른 객체와의 의존/연관성이 줄어든다. 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어나며, 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게된다.\r\n\r\n객체가 담당하는 동작. 즉, 책임이 많아질 수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다. 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.\r\n\r\n# 코드로 보는 단일 책임 원칙\r\n\r\n자동차는 휠의 구동 특성에 따라 전륜(FWD), 후륜(RWD), 사륜(AWD)로 나뉘며, 그 특성은 아래와 같다.\r\n\r\n* 전륜 구동인 경우 앞의 두 바퀴에만 동력을 전달한다.\r\n* 후륜 구동인 경우 뒤의 두 바퀴에만 동력을 전달한다.\r\n* 사륜 구동인 경우 전체 바퀴에 동력을 전달한다.\r\n\r\n이를 객체로 구현해보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\npublic class Car\r\n{\r\n\tprivate final String WD;\r\n\t\r\n\tprivate final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tswitch (WD.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"FWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"RWD\" -> {\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"AWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n여기 `Car` 객체가 있다. `Car`는 생성 시 파라미터로 <span class=\"orange-400\">휠 구동 방식</span>을 받는다.\r\n\r\n`Car`에는 주행 동작을 구현하는 `run()`메소드가 있으며, 이 메소드는 파라미터로 <span class=\"orange-400\">동력</span>을 받는다. 이후 휠 구동 방식에 따라 올바른 휠에 동력을 할당하고 휠의 상태를 출력한다.\r\n\r\n휠의 구동 방식 별 동작이 하나의 책임으로 본다면 이 객체가 짊어지는 책임은 무려 세 가지나 된다. 이렇게 하나의 객체에 너무 많은 책임이 몰려있을 경우, 프로젝트에서 해당 객체의 의존성이 높아지게된다. 이러한 현상은 객체지향의 주요 특징 중 하나인 캡슐화를 정면으로 부정한다. 그 뿐만 아니라, 각자의 코드가 서로 의존될 경우, 코드 수정에 따른 영향도 역시 높아지고, 범위 또한 넓어진다.\r\n\r\n위의 예시는 단일 책임 원칙을 설명하기 위한 단순한 예시로, 만약 코드의 규모가 크거나 복잡성이 심하다면 코드 수정 시 마다 오만가지 오류가 발생할 것이다. 그 뿐만 아니라 코드가 변경되는 과정에서 이미 정해진 코드의 리팩토링도 필요할 수 있다. 리팩토링이 리팩토링을 부르는 참사가 일어날 수도 있다. 여기서부터 코드가 지저분해지기 쉽다.\r\n\r\n단일 책임 원칙은 바로 이와 같은 상황을 방지하고자 수립된 원칙으로, <span class=\"red-400\">1객체 = 1책임</span>으로 최대한 객체를 간결하고 명확하게 설계할 것을 요구한다. 위 코드의 책임을 줄여 단일 책임 원칙을 지키려면 어떻게 해야할까?\r\n\r\n``` java\r\n/**\r\n * 자동차 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\nabstract public class Car\r\n{\r\n\tprotected final String WD;\r\n\t\r\n\tprotected final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tabstract public void run(int power);\r\n}\r\n```\r\n\r\n우선 공통된 인터페이스 내지는 상위 객체를 구현할 필요가 있다. 이 객체의 경우 생성자가 필요하므로 인터페이스 보단 상위 객체가 적합하다.\r\n\r\n> **네? 인터페이스 차별이요??**  \r\n> 인터페이스는 일반적인 객체 혹은 추상 객체와 달리 생성자를 강제할 수 없습니다.\r\n\r\n객체 `Car`를 상위 객체에 적용될 수 있게끔 구현한다. `run()` 메소드는 훨 구동 타입에 따라 동작이 달라지므로, `abstract` 지시자를 통해 추상 메소드로 선언한다. 해당 객체의 인스턴스를 생성하거나, 상속받는 객체가 직접 구현하게 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 전륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:03:13\r\n */\r\nclass FrontWheelCar extends Car\r\n{\r\n\t/**\r\n\t * FrontWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic FrontWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 후륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\nclass RearWheelCar extends Car\r\n{\r\n\t/**\r\n\t * RearWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic RearWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 사륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\npublic class AllWheelCar extends Car\r\n{\r\n\t/**\r\n\t * AllWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic AllWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n전륜, 후륜, 사륜에 해당하는 객체를 생성한다. 이 세 객체는 모두 `Car`에 포함되므로 `Car`를 상속받아 구현한다. 각 객체의 `run()` 메소드에 동작을 구현함으로써, 각각의 객체가 하나의 책임을 가지게 된다.\r\n\r\n이렇게 객체별로 책임을 나누면, 코드 변경 시에도 해당하는 객체만 수정하면 되므로, 의존성이 낮아져 올바른 모듈화를 구현할 수 있다. 그 뿐만 아니라 코드가 간결해져 유지보수가 쉬워질 뿐만 아니라 수정에 따른 영향도도 매우 작아진다.\r\n\r\n# 정리\r\n\r\n코드를 설계하다보면 하나의 객체가 너무 많은 동작을 담당하는 경우가 자주 발생한다. 필자 또한 무의식적으로 하나의 객체/메소드에 너무 많은 책임을 할당하는 일이 비일비재했다. 단일 책임 원칙은 이러한 개발 방향을 올바르게 잡아준다.\r\n\r\n가급적 단일 책임 원칙을 고수하여 올바른 객체를 구현할 수 있도록 해보자.","url":["2021-08-13-single-responsibility-principle","2021","08","13","single-responsibility-principle"]},{"header":{"title":"[OOP] 객체지향의 특징 - 다형성(Polymorphism)","excerpt":"객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다. 하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-12T00:32:42","type":"posts","category":"CS","tag":["CS","객체지향","다형성"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-12-polymorphism.md","content":"\r\n# 다형성 (Polymorphism)\r\n\r\n객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다.\r\n\r\n하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.\r\n\r\n> **One for One!**  \r\n> 하나의 파라미터는 반드시 하나의 타입만을 가진다. `public void run(String param)`은 반드시 문자열 타입만을 파라미터로 받는다.\r\n\r\n그말인즉슨, 동일한 메소드는 존재할 수 없으니, 해당 메소드에 입력할 수 있는 각각의 파라미터 타입도 하나로 고정된다. 하지만 `System.out.println()` 메소드를 보자. CLI 콘솔에 데이터를 출력하는 메소드로, JAVA를 다룬다면 안 써본 사람은 없는 메소드다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tSystem.out.println(\"문자열 데이터\");\r\n\t\tSystem.out.println(123456);\r\n\t\tSystem.out.println(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` out\r\n문자열 데이터\r\n123456\r\ntrue\r\n```\r\n\r\n<br />\r\n<p class=\"grey-600\" align=\"center\"><i>아니 아깐 동일한 메소드는 존재할 수 없다매요;;</i></p>\r\n<br />\r\n\r\n분명히 아까 <span class=\"pink-400\">동일한 이름을 가진 메소드는 동일한 객체에서 존재할 수 없다</span>고 했었다. 그럼에도 불구하고 `System.out.println()`의 경우, 메소드명은 동일한데 여러 타입을 보란듯이 받아서 처리하고 있다. 어떻게 된걸까? 유명한 메소드는 예외사항이라도 적용되는걸까?\r\n\r\n`System.out.println()`이 여러 타입을 처리할 수 있는 이유는 해당 메소드에 <span class=\"teal-400\">다형성</span>이 적용되어있기 때문이다. 다형성이란, 하나의 객체 혹은 메소드가 여러 타입을 참조할 수 있음을 의미한다. 다형성은 크게 <span class=\"amber-400\">객체의 다형성</span>과, <span class=\"amber-400\">메소드의 다형성</span>으로 구분된다.\r\n\r\n## 다형성의 예제\r\n\r\n코드를 통해 다형성을 알아보자.\r\n\r\n### 객체의 다형성\r\n\r\n먼저, 객체에 적용되는 다형성이다. 객체의 경우 상속된 객체의 인스턴스 생성 시, 다형성을 적용할 수 있다.\r\n\r\n객체의 다형성은 <span class=\"red-400\">객체가 상속된 부모 객체의 인스턴스로 할당</span>될 수 있음을 의미한다.\r\n\r\n``` java\r\nclass TV\r\n{\r\n\t// 메소드\r\n}\r\n\r\nclass SmartTV extends TV\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\n위와 같은 두 객체가 있다고 가정하자. `SmartTV`는 `TV`를 상속받아 구현된 객체다. 이 경우 `SmartTV`는 다형성을 적용할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tTV tv = new TV();\r\n\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tSmartTV smart = new SmartTV();\r\n\r\n\t\t// SmartTV는 TV의 자식 객체이므로 다형성이 적용되어 허용\r\n\t\tTV tv2 = new SmartTV();\r\n\r\n\t\t// 불가능\r\n\t\tSmartTV smart2 = new TV();\r\n\t}\r\n}\r\n```\r\n\r\n다른건 명확하므로 필요없고, 12번째 줄을 자세히 보자. `TV`와 `SmartTV`는 엄연히 다른 객체임에도 불구하고 인스턴스가 정상적으로 생성된다.\r\n\r\n이는 객체의 다형성이 적용된 결과로, `SmartTV`는 `TV`를 상속받아 만들어진 객체다. 즉 `SmartTV`는 `TV`를 온전히 포함하고 있으므로 `TV`의 인스턴스로 생성이 가능하다. 이러한 객체의 다형성은 객체를 상속했을 때 뿐만 아니라, 인터페이스를 상속할때도 가능하다.\r\n\r\n#### 다형성이 적용된 인스턴스\r\n\r\n객체의 다형성을 다룰 때 주의할 점이 한 가지 있다. 우리는 위에서 `SmartTV` 객체를 `TV`로 생성했다. 뭐 다형성 어쩌고로 인해 인스턴스가 정상적으로 생성됨은 알겠는데, 이 `TV`인듯 `SmartTV`인듯한 인스턴스는 어떻게 동작할까?\r\n\r\n이렇게 생성된 인스턴스 `tv2`는 `SmartTV`에 선언된 메소드들 중 `TV`에 선언된 메소드와 일치하는 메소드만 사용 가능하다.\r\n\r\n``` java\r\ninterface Movable\r\n{\r\n\tvoid move(boolean direction);\r\n}\r\n\r\nclass Unit implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n\r\n\tpublic void work(String act)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n이번엔 인터페이스를 예시로 들어보자. 움직임에 대한 동작이 기술되어있는 인터페이스 `Movable`과 이를 상속받은 `Unit` 객체가 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = new Unit();\r\n\r\n\t\t// Movable에 존재하는 메소드이므로 호출 가능\r\n\t\tmovable.move(true);\r\n\r\n\t\t// Movable엔 없는 Unit만의 고유 메소드이므로 호출 불가능\r\n\t\tmovable.work(\"run\");\r\n\t}\r\n}\r\n```\r\n\r\n객체의 다형성으로 인해 `Unit` 객체를 `Movable`로 생성할 수 있음은 잘 알 것이다. `movable`이라는 인스턴스를 만들고 `move()`, `work()` 메소드를 각각 호출해보자.\r\n\r\n`move()`의 경우 `Movable` 인터페이스에서 상속받아 구현한 메소드고, `work()`는 `Unit`에서 직접 생성한 메소드다. 이 경우 `Unit`의 메소드를 호출할 수 있지만, `Movable`에 선언된 메소드만 호출 가능하다. 즉, `Unit`과 `Movable` 객체 간에 겹치는 메소드만 사용이 호출이 가능하다. 이 때 메소드의 동작은 `Unit`의 메소드로 동작한다.\r\n\r\n객체의 다형성을 사용하면 동일한 객체를 상속받은 여러 객체들을 다루기 매우 편리하다.\r\n\r\n``` java\r\nclass UnitA implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\twork(\"run\");\r\n\t}\r\n\r\n\tprivate void work(String act)\r\n\t{\r\n\t\tSystem.out.println(\"work: \" + act);\r\n\t}\r\n}\r\n\r\nclass UnitB implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tdoing(3);\r\n\t}\r\n\r\n\tprivate void doing(int num)\r\n\t{\r\n\t\tSystem.out.println(\"doing: \" + num);\r\n\t}\r\n}\r\n\r\nclass UnitC implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tactive(true);\r\n\t}\r\n\r\n\tprivate void active(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(\"active: \" + flag);\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 동일한 인터페이스 `Movable`을 상속받은 여러 객체가 있다고 가정하자. 이 객체들은 각각 개별적인 객체지만, `Movable`을 상속받았으므로, 세 객체 모두 다형성을 통해 `Movable` 인스턴스로 할당할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = switch (new Random().nextInt(3))\r\n\t\t{\r\n\t\t\tcase 0 -> new UnitA();\r\n\t\t\tcase 1 -> new UnitB();\r\n\t\t\tcase 2 -> new UnitC();\r\n\t\t\tdefault -> null;\r\n\t\t};\r\n\t\t\r\n\t\tmovable.move(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n# 실행 시마다 달라짐\r\nwork: run\r\n```\r\n\r\n실행 시마다 `UnitA`, `UnitB`, `UnitC` 중 무작위로 선택된 객체의 인스턴스를 `Movable`에 할당한다. 서로 같은 객체임에도 `Movable`이라는 부모 객체로 인스턴스를 할당하여 공통된 메소드를 호출할 수 있다. 호출된 공통 메소드인 `move()` 내부에는 `Unit` 고유의 메소드가 포함되어도 상관없다.\r\n\r\n이처럼 메소드의 입력으로 여러 타입의 파라미터가 와야할 경우, 이 파라미터들이 동일한 객체를 상속하고 있다면 다형성을 적용하여 공통된 타입으로 다룰 수 있다.\r\n\r\n### 메소드의 다형성\r\n\r\n메소드 역시 다형성을 적용할 수 있다. 객체의 다형성은 객체 자신의 타입과 연관되지만, 메소드의 다형성은 메소드가 사용하는 파라미터의 타입과 연관된다.\r\n\r\n메소드의 다형성은 <span class=\"red-400\">메소드가 서로 동일한 이름을 가지더라도, 입력받는 파라미터가 다르면 각각 개별적인 메소드로 취급</span>함을 의미한다.\r\n\r\n``` java\r\n/**\r\n * 컨버터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 23:46:44\r\n */\r\npublic class Converter\r\n{\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t */\r\n\tpublic void convert(int num)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"int: \").append(num));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param text: [String] 문자열\r\n\t */\r\n\tpublic void convert(String text)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"String: \").append(text));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param flag: [boolean] T/F\r\n\t */\r\n\tpublic void convert(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"boolean: \").append(flag));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t */\r\n\tpublic void convert(char c)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"char: \").append(c));\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `Converter` 클래스로, 메소드의 이름이 모두 `convert`로 동일함을 알 수 있다. 하지만 각각의 메소드 모두 매개변수가 다르다. 이 경우 다형성에 의해 각각의 메소드가 독립적인 메소드로 인정받게된다.\r\n\r\n다형성의 존재로 인해 코드의 일관성을 유지할 수 있다. 대표적으로 우리가 콘솔에 출력할 때 사용하는 `System.out.println()` 메소드가 이에 해당한다.\r\n\r\n``` java\r\npublic void println(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `System.out.println()`의 내부 소스다. 보다시피 이름이 동일하고, 동작까지도 콘솔에 출력하는 것으로 동일하지만 다형성으로 인해 각각의 메소드가 온전한 하나로 인정된다.\r\n\r\n만약 다형성이라는 개념이 없다면 어떨까? 동일한 동작을 함에도 매개변수가 달라진다는 이유만으로 비슷한 이름을 가진 메소드를 만들어야하고, 개발자는 각 매개변수에 맞게 메소드를 사용해야한다.\r\n\r\n``` java\r\npublic void printlnFloat(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnDouble(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnChar(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnString(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n즉, 위와 같은 설계가 강요된다. 코드를 설계하다보면 동일한 동작에 다양한 종류의 객체가 와야할 수도 있다. JAVA는 <span class=\"green-400\">하나의 매개변수 = 하나의 타입</span>이라는 원칙을 고수하므로, JavaScript와 같이 다양한 종류의 타입이 매개변수로 올 수 없다.\r\n\r\n다형성을 활용하면 이러한 문제를 효과적으로 타개할 수 있다. 동일한 이름으로 다양한 매개변수를 받는 메소드를 작성하면, 개발자는 이를 사용 시 별다른 타입 구분 없이 마치 동일한 메소드를 사용한다는 개발 경험을 제공한다.\r\n\r\n``` java\r\n// println(String x)\r\nSystem.out.println(\"text\");\r\n\r\n// println(double x)\r\nSystem.out.println(1.5D);\r\n```\r\n\r\n위와 같이 개발자가 별도로 타입을 구분하지 않고 사용해도, 컴파일 시 해당 매개변수를 받는 메소드가 자동으로 호출된다.\r\n\r\n#### 반환값이 다른 메소드의 다형성?\r\n\r\n호기심이 많다면 이런 케이스를 생각해볼 수 있다. 매개변수에 대한 다형성이 있으면, 메소드의 반환값에 대한 다형성도 있지 않을까? 좋은 발상이지만, 아쉽게도 다형성은 반드시 매개변수로만 구분한다. <span class=\"red-400\">반환값의 경우 다형성이 적용되지 않는다.</span>\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 경우, 매개변수가 `char[]`, `String`으로 각각 다르므로 다형성이 적용된다.\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic boolean println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n```\r\n\r\n반대로 위 경우는 메소드명과 매개변수는 동일하지만, 반환값이 다르다. 매개변수와 달리 <span class=\"red-400\">반환값은 다형성이 적용되지 않으므로, 중복된 메소드로 취급</span>된다. 따라서 위 소소는 컴파일 오류를 일으킨다.\r\n\r\n# 마무리\r\n\r\n객체의 다형성은 생산성에 초점이 맞춰져있다. 동일한 메소드로 여러 타입의 데이터를 처리하거나, 공통 상속된 객체를 처리함으로써 중복된 코드 소요를 제거하고 개발 편의성을 높여준다. 다형성을 적극적으로 활용하여 중복된 코드는 줄이고, 데이터 처리의 범위는 넓혀보자.","url":["2021-08-12-polymorphism","2021","08","12","polymorphism"]},{"header":{"title":"[OOP] 객체지향의 특징 - 상속(Inheritance)","excerpt":"나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다. 나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 상속이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-11T20:32:33","type":"posts","category":"CS","tag":["CS","객체지향","상속","추상"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-11-inheritance.md","content":"\r\n# 상속 (Inheritance)\r\n\r\n나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다.\r\n\r\n나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 **상속**이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.\r\n\r\n<p align=\"center\"><i><del>평범하게 살던 내가 콤퓨타 이세카이에선 상속자???!!?!?!</del></i></p>\r\n\r\n하지만 객체지향 언어에서는 누구나 필요에 의해 쉽게 상속받을 수 있다!\r\n\r\n객체지향 역시 동일한 개념이 존재한다. 객체지향에서의 <span class=\"teal-400\">상속</span>이란 <span class=\"blue-400\">객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용</span>하는 것을 의미한다.\r\n\r\n이 때 객체를 상속받은 객체는 <span class=\"teal-400\">자식</span>, 상속된 객체는 <span class=\"teal-400\">부모</span>라 칭한다.\r\n\r\n자식 객체는 상속된 부모 객체의 은닉화 구성에 따라 정해진 변수, 메소드에 접근할 수 있다. 또한 부모 객체가 <span class=\"teal-400\">추상 객체</span>일 경우 <span class=\"teal-400\">추상 메소드</span>와 <span class=\"teal-400\">오버라이딩</span>(Overriding)을 통해 부모 객체의 메소드를 구현하거나 다룰 수 있다.\r\n\r\n## 추상 객체\r\n\r\n<span class=\"teal-400\">추상 객체</span>는 하나 이상의 추상 메소드를 포함하는 객체다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\nJAVA로 표현한 추상 클래스는 위와 같으며, 클래스의 맨 앞에 `abstract` 키워드를 적어 해당 객체가 추상 객체임을 표현할 수 있다.\r\n\r\n## 추상 메소드\r\n\r\n<span class=\"teal-400\">추상 메소드</span>는 자식 객체에서 구현해야하는 메소드다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\tpublic void normalMethod()\r\n\t{\r\n\t\tSystem.out.println(\"일반 메소드\");\r\n\t}\r\n\r\n\tabstract public void abstractMethod();\r\n}\r\n```\r\n\r\n위는 JAVA로 표현한 추상 객체다. `normalMethod()`은 일반적인 메소드고, `abstractMethod()`는 추상 메소드다. 추상 메소드는 일반적인 메소드와 큰 차이가 있는데, 메소드의 동작이 기술되어있지 않다.\r\n\r\n추상 메소드의 구현은 자식 객체가 담당하며, 아래 단계에서 이루어진다.\r\n\r\n* 추상 객체의 인스턴스 생성 시\r\n* 추상 객체를 상속받을 시\r\n\r\n일반적인 메소드는 자신의 객체에서 선언되어있다. 하지만 추상 메소드의 경우, 추상 객체를 할당받으려는 객체에서 선언이 이루어진다. 이 경우 어떤 메리트가 있을까?\r\n\r\n예를 들어, 부모 객체 `Main`과 이를 상속받은 자식 객체 `Sub`가 있다고 가정하자. 만약 동작 구조 상 `abstractMethod()`에서 자식 객체의 변수나 메소드를 사용해야만 한다면?\r\n\r\n`normalMethod()` 처럼 동작이 이미 부모 객체에 선언되는 경우 자식 객체의 요소를 반영하기가 매우 어렵다. 인스턴스를 생성하는 방법도 있겠지만 어떤 객체를 상속받을 지 알 수 없는 경우, 예상되는 객체의 인스턴스를 전부 할당받아놓는 게 아니라면 불가능에 가깝다. 그리고 이 방법의 경우 메모리 낭비가 너무 심해진다.\r\n\r\n반면 `abstractMethod()` 같은 추상 메소드의 경우 자식 객체에서 구현되기 때문에 자식 객체의 변수나 메소드에 직접적으로 접근할 수 있다. 때문에 자식 객체의 요소를 활용해서 동작을 구현해야 할 경우, 해당 메소드를 추상으로 정의하면 자식 객체의 특성에 맞게 구현하기 용이하다.\r\n\r\n### 추상 메소드 구현 - 인스턴스 생성 시\r\n\r\nJAVA를 통해 `Main`의 인스턴스를 `Sub`에서 생성해보자.\r\n\r\n``` java\r\npublic class Sub\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tMain main = new Main()\r\n\t\t{\r\n\t\t\t@Override\r\n\t\t\tpublic void abstractMethod()\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(text());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"Sub 객체의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n원래대로라면 `abstractMethod()` 메소드는 `Sub` 객체의 `text()`에 접근할 수 없다. `text()`는 `private` 접근제어자를 가지기 때문이다.\r\n\r\n하지만 추상 메소드의 경우 구현이 `Sub`에서 이루어지기 때문에 `Sub`의 모든 요소에 직접적으로 접근할 수 있다. 즉, `private` 같은 내부 메소드까지 전부 접근 가능하다.\r\n\r\n### 추상 메소드 구현 - 상속 시\r\n\r\nJAVA를 통해 `Main`을 `Sub`에 상속시켜보자.\r\n\r\n``` java\r\npublic class Sub extends Main\r\n{\r\n\t@Override\r\n\tpublic void abstractMethod()\r\n\t{\r\n\t\tSystem.out.println(text());\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"자식 객체 Sub의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n부모 객체에 추상 메소드가 있을 경우, 자식 객체는 이를 반드시 오버라이딩해야한다. 그러지 않을 경우 컴파일 오류를 일으킨다.\r\n\r\n마찬가지로 메소드의 구현이 자식 객체에서 이루어지므로, 자식 객체의 모든 요소에 접근할 수 있다.\r\n\r\n추상 메소드는 이처럼 구현의 주체를 자식 객체에게 전가함으로써, 자식 객체의 요소에 제한없이 접근할 수 있다. 원래라면 `public` 등으로 열어줬어야 함에도 자식 객체 내부에서 구현이 이루어지기 때문에 접근제어자를 변경할 필요가 없다.\r\n\r\n# 상속의 예제\r\n\r\nJAVA를 통해 객체의 상속이 어떤식으로 이루어지고, 어떤식으로 사용되는지 알아보자.\r\n\r\n``` java\r\nimport java.util.Date;\r\n\r\n/**\r\n * 컴퓨터 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:19:19\r\n */\r\nabstract public class Computer\r\n{\r\n\tprivate final String OS;\r\n\t\r\n\t/**\r\n\t * Computer 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Computer(String os)\r\n\t{\r\n\t\tthis.OS = os;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\tpublic void startup()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - started at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - shutdown at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 추상 함수\r\n\t */\r\n\tabstract public void run();\r\n}\r\n```\r\n\r\n여기 `Computer`라는 추상 객체가 존재한다. 이 객체는 `OS`라는 상태와 `startup`, `shutdown`, `run`이라는 동작을 가진다.\r\n\r\n이 중 `run`은 좀 특별한데, 동작은 적혀있으나, 어떤식으로 동작하는지에 대한 명세는 정해져있지 않다.\r\n\r\n이는 <span class=\"teal-400\">추상 객체</span>의 특징 중 하나로, 추상 객체는 하나 이상의 <span class=\"teal-400\">추상 메서드</span>를 포함할 수 있다. 추상 메서드는 구현되지 않은 메서드로, **동작의 개념** 정도로만 이해하면 된다. <span class=\"red-400\">추상 메서드의 구현은 해당 객체를 상속받은 자식 객체에서 이루어진다.</span> 즉, `run` 추상 메소드는 자식마다 제각각으로 구현된 동작을 수행한다.\r\n\r\n아래의 두 클래스 `Asus`와 `Dell`은 `Computer` 추상 클래스를 상속받은 자식 클래스다.\r\n\r\n``` java\r\n/**\r\n * ASUS 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:24:50\r\n */\r\npublic class Asus extends Computer\r\n{\r\n\t/**\r\n\t * Asus 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Asus(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"ASUS 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\n/**\r\n * DELL 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:26:46\r\n */\r\npublic class Dell extends Computer\r\n{\r\n\t/**\r\n\t * Dell 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Dell(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void startup()\r\n\t{\r\n\t\tsuper.startup();\r\n\t\t\r\n\t\tSystem.out.println(\"시스템 안정화 수행\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\t@Override\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(\"시스템 프로세스 정리 수행\");\r\n\t\t\r\n\t\tsuper.shutdown();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"DELL 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n`Asus`와 `Dell` 모두 `Computer`를 상속받았음을 확인할 수 있다. 또한 모두 `run` 함수가 제각각 구현된 것 역시 확인할 수 있다.\r\n\r\n그런데 `Asus`와 달리 `Dell`은 부팅 시와 종료 시 각각 시스템의 안정성을 위한 사전/후 작업이 추가됐다.\r\n\r\n이러한 사전/후 작업을 구현하기 위해 `startup`, `shutdown`을 오버라이딩한다. 이 과정을 통해 시작과 종료 함수에 각각 원하는 동작을 추가한다.\r\n\r\n> **super?**  \r\n> 자식 클래스에서 부모 클래스를 호출할 때 `super` 키워드를 이용해 호출한다. `Dell`의 오버라이딩 메소드 동작에서 활용됨을 알 수 있다. `super.shutdown()`은 부모 클래스 `Computer`의 메소드인 `shutdown()`을 호출한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tDell dell = new Dell(\"Windows 10 Pro\");\r\n\t\tAsus asus = new Asus(\"Ubuntu 21.04\");\r\n\t\t\r\n\t\tdell.startup();\r\n\t\tdell.run();\r\n\t\tdell.shutdown();\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tasus.startup();\r\n\t\tasus.run();\r\n\t\tasus.shutdown();\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\nWindows 10 Pro - started at Fri Aug 06 22:54:39 KST 2021\r\n시스템 안정화 수행\r\nDELL 작업 수행\r\n시스템 프로세스 정리 수행\r\nWindows 10 Pro - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n\r\nUbuntu 21.04 - started at Fri Aug 06 22:54:39 KST 2021\r\nASUS 작업 수행\r\nUbuntu 21.04 - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n```\r\n\r\n`Asus`와 `Dell`의 메소드를 순서대로 수행하면 위와 같은 결과가 나온다. `Dell`의 시작, 종료 간 시스템 동작이 수행됨을 확인할 수 있다.\r\n\r\n# 정리\r\n\r\n객체지향은 모든 객체의 모듈화를 추구한다. 좋은 모듈화는 <span class=\"amber-400\">캡슐화</span>, <span class=\"amber-400\">은닉화</span>가 적절히 구현되고 유지되는 것을 지향한다.\r\n\r\n하지만 포장이 견고하면 뜯기 어렵듯이, 탄탄한 모듈화는 모듈이 경직된다. 재사용의 범위가 제한되는 것 뿐만 아니라, 이를 이용한 확장 또한 어려울 것이다. 만약 객체지향에 이 두 개념만 있었다면 개발자는 재사용성과 모듈화를 적절히 타협하며 객체를 구현했을 것이다.\r\n\r\n하지만 상속이라는 개념의 존재로 인해 객체에 지정된 모듈화를 전혀 해치지 않으면서 재사용성, 확장성을 보장받을 수 있다. 객체지향의 모듈화로 인한 딜레마를 상쇄하는 키치한 개념이 아닐 수 없다. 개인적으로는 객체지향의 특징 중 가장 중요한 특징이라고 생각한다. 물론 객체지향 중에서도 매우 어려운 개념이지만, 이를 잘 이해하면 조금 더 객체지향다운 코드를 짤 수 있을 것이다.","url":["2021-08-11-inheritance","2021","08","11","inheritance"]},{"header":{"title":"[OOP] 객체지향의 특징 - 캡슐화(Encapsulation)와 정보 은닉","excerpt":"객체. 즉, 클래스의 내부 변수와 메소드를 하나로 패키징하는 특징이다. 객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다. 캡슐화와 비슷한 개념으로 정보 은닉이라는 개념이 있다. 정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다. 이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-08T11:05:05","type":"posts","category":"CS","tag":["CS","객체지향","캡슐화","정보 은닉","접근제어자"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-08-encapulation.md","content":"\r\n# 캡슐화 (Encapsulation)\r\n\r\n객체. 즉, <span class=\"blue-400\">클래스의 내부 변수와 메소드를 하나로 패키징</span>하는 특징이다.\r\n\r\n객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다.\r\n\r\n<span class=\"primary\">캡슐화</span>와 비슷한 개념으로 <span class=\"primary\">정보 은닉</span>이라는 개념이 있다.\r\n\r\n정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다.\r\n\r\n이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.\r\n\r\n# 캡슐화의 예제\r\n\r\nJAVA의 경우 <span class=\"orange-700\">접근제어자</span>를 통해 객체의 캡슐화, 은닉화를 구현한다.\r\n\r\n* `public`: 다른 객체에서 해당 객체의 인스턴스를 생성하여 접근할 수 있다.\r\n* `protected`: 해당 객체를 상속받은 객체 내부에서 접근할 수 있다. 단순 인스턴스에선 접근할 수 없다.\r\n* `default`: 동일한 패키지 내의 객체에서 인스턴스를 생성하여 접근할 수 있다.\r\n* `private`: 선언된 객체 내부에서만 사용 가능하며, 외부에선 어떠한 방법으로든 해당 지시자를 가진 변수 혹은 메소드를 사용할 수 없다.\r\n\r\n대표적인 접근제어자는 위와 같으며, 이를 통해 <span class=\"red-400\">객체 내부의 상태와 동작의 접근 방법을 강제</span>할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\npublic class B\r\n{\r\n\tprivate void publicMethod()\r\n\t{\r\n\t\tSystem.out.println(\"public 메소드 접근\");\r\n\t}\r\n\r\n\tdefault void defaultMethod()\r\n\t{\r\n\t\tSystem.out.println(\"default 메소드 접근\");\r\n\t}\r\n\r\n\tprotected void protectedMethod()\r\n\t{\r\n\t\tSystem.out.println(\"protected 메소드 접근\");\r\n\t}\r\n\r\n\tprivate void privateMethod()\r\n\t{\r\n\t\tSystem.out.println(\"private 메소드 접근\");\r\n\t}\r\n}\r\n```\r\n\r\n## public 요소의 접근 방법\r\n\r\n`public`은 접근제어자 중 <span class=\"orange-400\">가장 개방적인 접근제어자</span>다. 이름부터가 공공(public)이니 말 다했다.\r\n\r\n별다른 조건 없이 객체 `A`에서 객체 `B`의 새로운 인스턴스를 생성하면 `A`에서 `B`의 `public` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `publicMethod()`에 정상적으로 접근 가능하다. 반드시 외부의 접근이 필요한 멤버 변수나 메소드에만 사용해야한다. 해당 접근제어자를 <span class=\"red-400\">남용할 경우 불필요한 요소를 개방</span>하게 되어 정보 은닉이 이루어지지 않는다.\r\n\r\n## protected 요소의 접근 방법\r\n\r\n`protected`는 상속과 연관된 접근제어자다. 이 제어자를 가진 요소는 <span class=\"orange-400\">해당 객체를 상속받은 객체만 접근</span>할 수 있다.\r\n\r\n객체 `A`에서 객체 `B`를 상속받는다. 이 때 자식 객체는 `A`, 부모 객체는 `B`가 된다. 상속을 받게 되면 `A`에서 `B`의 `protectedMethod` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A extends B\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tprotectedMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `protectedMethod()`에 정상적으로 접근 가능하다. `public`과 달리 별도의 인스턴스는 받지 않아도 된다. 이는 `A`가 `B`를 상속받기 때문에, `B`의 <span class=\"lightBlue-400\">멤버 변수와 메소드의 접근 권한을 일부 승계</span>하기 때문\r\n\r\n## default 요소의 접근 방법\r\n\r\n`default`는 제한적인 `public` 접근제어자라 할 수 있다. 이 제어자를 가진 요소는 <span class=\"orange-400\">동일한 패키지 내에서만 접근</span>할 수 있다.\r\n\r\n객체 `A`와 `B`가 동일한 패키지에 위치할 때, `A`에서 `B`의 새로운 인스턴스를 할당받으면 `defaultMethod()`에 접근할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n패키지가 같을 경우 `public`을, 패키지가 다를 경우 `private`과 같은 동작을 한다. 동일한 패키지 여부에 따라 개방/폐쇄가 갈린다. 만약 변수나 메소드에 <span class=\"lightBlue-400\">별다른 접근제어자를 지정하지 않았다면 이 제어자가 기본으로 적용</span>된다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tvoid defaultMethod()\r\n\t{\r\n\t\t// 접근제어자를 지정하지 않으면 default로 자동 지정\r\n\t}\r\n}\r\n```\r\n\r\n## private 요소의 접근 방법\r\n\r\n`private`는 반드시 <span class=\"orange-400\">선언된 객체 내부에서만 접근</span>할 수 있다. 즉, `B`가 아닌 어떤 클래스에서도 `privateMethod()`에 접근할 수 없다. 메소드 뿐만 아니라 멤버 변수도 마찬가지다. 은닉화를 위한 접근제어자로, <span class=\"red-400\">해당 접근제어자의 사용을 통해 내부 변수나 메소드를 은닉</span>할 수 있다.\r\n\r\n객체는 기본적으로 은닉화가 이루어져야한다. 객체를 구현할 때 개방/폐쇄의 명세를 디테일하게 명세하지 않았다면 일단은 `private`로 만드는 것이 좋다. 이후 설계 과정에서 적절한 개방이 필요할 경우 해당 메소드나 변수를 개방한다. 이와 같은 방식은 필요 시에 요소를 적절히 개방함으로써, 차후 프로젝트나 객체의 규모가 커짐에 따라 놓칠 수 있는 불필요한 개방을 미연에 방지할 수 있다. 즉, 올바른 캡슐화/은닉화를 구현하는데 용이한 방식이다.\r\n\r\n# 정리\r\n\r\n별다른 생각 없이 모든 메소드를 개방시킨 객체는 모듈이라 보기 어렵다. 반대로 모든 메소드를 은폐시킨 객체 역시 모듈로써의 의미가 전혀 없다. 즉, 객체가 모듈의 의미를 갖기 위해선 적절히 설계된 개방/폐쇄가 필요하다는 뜻이다.\r\n\r\n캡슐화와 정보 은닉을 메소드가 모듈로써의 의미를 갖게 헤주는 중요한 요소이다. 사용하는 언어의 접근제어자에 대한 이해를 통해 올바른 캡슐화, 정보 은닉을 지키는 객체를 구현하자.","url":["2021-08-08-encapulation","2021","08","08","encapulation"]},{"header":{"title":"[OOP] 객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"IT 업계에 종사하게 된다면 십중팔구 JAVA, C++, C# 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 객체지향언어라는 점이다. 물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, C의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"\r\n# OOP\r\n\r\nIT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.\r\n\r\n물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.\r\n\r\n# 객체지향에 대해 설명해보세요.\r\n\r\n제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.\r\n\r\n내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.\r\n\r\n## 객체\r\n\r\n**객체**지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 **객체**란 개념에 대해 이해할 필요가 있다.\r\n\r\n객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.\r\n\r\n모든 객체는 상태와 동작을 가진다. 예를 들어, **TV**를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.\r\n\r\nTV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.\r\n\r\n이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.\r\n\r\n국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.\r\n\r\n| 객체지향 |     JAVA      |\r\n| :------: | :-----------: |\r\n|   객체   |    클래스     |\r\n|   상태   |   멤버 변수   |\r\n|   동작   | 메소드 (함수) |\r\n\r\n여기 **자동차**라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.05 22:06:24\r\n */\r\npublic class Car\r\n{\r\n\t// 시동 여부\r\n\tprivate final boolean IS_STARTED = false;\r\n\t\r\n\t// 최대 속력\r\n\tprivate final int MAX_SPEED;\r\n\t\r\n\t// 현재 속력\r\n\tprivate int speed;\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param maxSpeed: [int] 최대 속도\r\n\t */\r\n\tpublic Car(int maxSpeed)\r\n\t{\r\n\t\tMAX_SPEED = maxSpeed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 결과\r\n\t */\r\n\tpublic boolean startUp()\r\n\t{\r\n\t\treturn !IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 종료 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 종료 결과\r\n\t */\r\n\tpublic boolean shutdown()\r\n\t{\r\n\t\treturn IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 현재 속도 반환 함수\r\n\t *\r\n\t * @return [int] 현재 속도\r\n\t */\r\n\tpublic int getSpeed()\r\n\t{\r\n\t\treturn speed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void upSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 가속된 값이 최대 속도를 넘지 않을 경우\r\n\t\t\tif (MAX_SPEED >= speed + amount)\r\n\t\t\t{\r\n\t\t\t\tspeed += amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가속된 값이 최대 속도를 넘을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = MAX_SPEED;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 감속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void downSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 감속된 값이 0보다 클 경우\r\n\t\t\tif (0 <= speed - amount)\r\n\t\t\t{\r\n\t\t\t\tspeed -= amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 감속된 값이 0보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.\r\n\r\n<br />\r\n\r\n* **멤버 변수** (상태)\r\n  * `IS_STARTED` 자동차 시동 여부\r\n  * `MAX_SPEED`: 최대 속도\r\n  * `speed`: 현재 속도\r\n\r\n<br />\r\n\r\n* **메소드** (동작)\r\n  * `startUp`: 엔진 시동\r\n  * `shutdown`: 엔진 정지\r\n  * `getSpeed`: 현재 속도 표시\r\n  * `upSpeed`: 가속\r\n  * `downSpeed`: 감속\r\n\r\n<br />\r\n\r\nCar 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.\r\n\r\nCar 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.\r\n\r\n## 객체지향\r\n\r\n객체**지향**이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.\r\n\r\n모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.\r\n\r\n일례로 JAVA는 `String`, `HashMap` 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.\r\n\r\n# 그래서 이걸 왜 쓰는데?\r\n\r\n객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.\r\n\r\n그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?\r\n\r\n객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.\r\n\r\n## 장점\r\n\r\n* <span class=\"green-400\">코드 재사용성</span>  \r\n모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.\r\n\r\n* <span class=\"green-400\">간편한 유지보수</span>  \r\n객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.\r\n\r\n* <span class=\"green-400\">큰 규모의 프로그래밍에 유리</span>  \r\n객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.\r\n\r\n## 단점\r\n\r\n* <span class=\"red-400\">비교적 느린 속도</span>  \r\n절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.\r\n\r\n* <span class=\"red-400\">높은 설계역량 요구</span>  \r\n모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.\r\n\r\n* <span class=\"red-400\">코드의 잠재적인 복잡성</span>  \r\n높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.\r\n\r\n# 객체지향을 사용하는 언어들\r\n\r\n* JAVA\r\n* C++\r\n* C#\r\n* Python\r\n* Simula 67\r\n* Delphi\r\n* Swift\r\n* Ruby\r\n* Perl\r\n\r\n<del class=\"grey-600\">대부분 아는 얼굴들이구만</del>\r\n\r\n# 정리\r\n\r\n기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.\r\n\r\n하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.\r\n\r\n객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.\r\n\r\n절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.\r\n\r\n요즘 AI 기술이 발달함에 따라 [Copilot](https://copilot.github.com/) 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.\r\n\r\n나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"]}],"data":{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 개방-폐쇄 원칙 (Open-Closed Principle)","excerpt":"개방 폐쇄 원칙이란 객체를 다룸에 있어서 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미. 좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다. 만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다. 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-14T04:04:40","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-14-open-closed-principle.md","content":"<h1 id=\"개방-폐쇄-원칙 (Open-Closed Principle)\">개방-폐쇄 원칙 (Open-Closed Principle) <a href=\"#개방-폐쇄-원칙 (Open-Closed Principle)\">🔗</a></h1><p><span class=\"orange-400\">개방 폐쇄 원칙</span>이란 객체를 다룸에 있어서 <span class=\"red-600\">객체의 확장은 개방적으로, 객체의 수정은 폐쇄적</span>으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미.</p>\n<p>좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다.</p>\n<p>만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다.</p>\n<p>이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.</p>\n<h1 id=\"코드로-보는 개방-폐쇄 원칙\">코드로 보는 개방-폐쇄 원칙 <a href=\"#코드로-보는 개방-폐쇄 원칙\">🔗</a></h1><br />\n<p class=\"large grey-600\" align=\"center\"><i>If...</i></p>\n<br />\n\n<p>저명한 IT업체에서 일하는 당신. 어느덧 정년을 바라보고 있다. 노후 대비를 위해 작은 편의점의 점주로 새로운 시작을 하는 당신. 예전부터 봐뒀던 곳에 적지 않은 비용을 지불하기까지 했다.</p>\n<p>다행히 안목이 틀리지 않았는지, 아침은 아침대로, 새벽은 새벽대로 끊임없는 유동인구 덕분에 생각했던 것 이상으로 수입이 들어오고 있다. 좀 더 일찍 시작했어도 됐으려나...</p>\n<p>여기저기 신경쓰다보니 초기 비용이 여의치 않아, POS기기는 저렴한 걸 선택했다. 영업사원이 사용 카드가 어쩌네 넌지시 얘기한 거 같은데, 그래봐야 POS가 거기서 거기겠지 뭐.</p>\n<br />\n\n<p>요즘 들어 매체에 신생 카드 업체에 대한 주제가 끊이질 않는다. 공격적인 혜택과 이전 카드에선 찾아볼 수 없었던 아기자기한 디자인이 그렇게 인기랜다. 이름이 초콜릿뱅크였나..? 혜택은 좋은데, 카드에 저런 디자인이 무슨 소용이람.</p>\n<br />\n\n<p>요즘들어 그 초코 뭐시긴가 하는 카드를 쓰는 사람이 많아졌다. 문제는 저 놈의 POS기가 새로운 카드는 전혀 인식을 못 한다. 이 문제 때문에 이번 주에만 반 이상이 넘는 고객을 돌려보냈다. 매출도 문제지만, 손님한테 아쉬운 소리하면서 사과하는 게 더 고역이다.</p>\n<p>POS 업체에 전화해봤는데, 구조 상 그런거라며 계약 이전에 다 설명하고 서명받은 내용이란다. 난 그런 기억이 없는데....? 어쨌든 내게 남은 선택지라곤 지금 유지비용의 두 배 가까이 되는 신규 POS로 교체하던가, 위약금을 물고 새로운 POS 업체로 갈아타는 것 뿐이다. 이 문제 때문에 잠을 통 잘 수가 없다.</p>\n<br />\n\n<p>그래도 명색이 개발자인 당신. 어쩌면 내가 해결할 수도 있지 않을까? 수 십년 간의 경험을 토대로 기억을 되짚어가며 기기를 분석해보기 시작했다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 포스 클래스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:10:12</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Pos</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 결제 및 결과 반환 함수</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param card : [Object] 카드 객체</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     * @param name : [String] 카드사명</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 결제 결과</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">purchase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> card<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>        <span class=\"token keyword\">boolean</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>        </td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>card<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23>            <span class=\"token keyword\">case</span> <span class=\"token string\">\"A\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardA</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24>            <span class=\"token keyword\">case</span> <span class=\"token string\">\"B\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardB</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25>            <span class=\"token keyword\">case</span> <span class=\"token string\">\"C\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardC</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26>            </td></tr>\n<tr data-number=27><td class=\"line-number\" data-number=\"27\">27</td><td class=\"line-code\" data-number=27>            <span class=\"token keyword\">default</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=28><td class=\"line-number\" data-number=\"28\">28</td><td class=\"line-code\" data-number=28>                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"유효하지 않은 카드사\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=29><td class=\"line-number\" data-number=\"29\">29</td><td class=\"line-code\" data-number=29>                result <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=30><td class=\"line-number\" data-number=\"30\">30</td><td class=\"line-code\" data-number=30>            <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=31><td class=\"line-number\" data-number=\"31\">31</td><td class=\"line-code\" data-number=31>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=32><td class=\"line-number\" data-number=\"32\">32</td><td class=\"line-code\" data-number=32>        </td></tr>\n<tr data-number=33><td class=\"line-number\" data-number=\"33\">33</td><td class=\"line-code\" data-number=33>        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=34><td class=\"line-number\" data-number=\"34\">34</td><td class=\"line-code\" data-number=34>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=35><td class=\"line-number\" data-number=\"35\">35</td><td class=\"line-code\" data-number=35><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>다행히 아직 감이 죽진 않았는지, 어렵지 않게 관련 모듈을 특정할 수 있었다. 카드 리더기에서 카드 인식 시 카드 정보가 담긴 객체를 <code class=\"inline-code\">Object</code>로 캐스팅하여 전송한다. 정보 구분을 위해 카드사명까지 같이 전송하는 모양이다.</p>\n<p>딱 봐도 난감하기 그지없는 구조다. 실제로 초콜릿뱅크의 카드 정보는 리더기에서 잘 전달되고 있으나, <code class=\"inline-code\">purchase</code> 메소드에서 초콜릿뱅크 카드를 구분하는 로직이 없어서 결제가 되지 않는다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">purchase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> card<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    <span class=\"token keyword\">boolean</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    </td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>card<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>        <span class=\"token comment\" data-tag=\"new\">// 신생 업체가 생길 때마다 해당 업체를 구분하는 로직을 추가한다.</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"A\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardA</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"B\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardB</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"C\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardC</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"D\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardD</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"E\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardE</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"F\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardF</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>        </td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>        <span class=\"token keyword\">default</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"유효하지 않은 카드사\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>            result <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>    </td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>그렇다면 <code class=\"inline-code\">case</code> 구문에서 초콜릿뱅크를 구분하여 결제 정보를 전송하면 해결되지 않을까? 이 방식을 쓴다면 급한 불은 끌 수 있겠지만, 후에 또 다른 신생업체가 생기면 같은 문제가 반복될 게 뻔하다.</p>\n<p>이 방법은 매우 비효율적이다. 동작의 범위만 넓혔을 뿐, 근본적인 문제는 전혀 해결되지 않는다.</p>\n<p>당신은 이 코드를 좀 더 객체지향의 관점으로 접근하여 리팩토링을 실시한다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 결제 인터페이스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:28:22</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Purchasable</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 카드사 정보 전송 및 결과 반환 함수</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 전송 결과</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token keyword\">boolean</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>공통된 형태로 로직을 수행하기 위해 <code class=\"inline-code\">Purchasable</code> 인터페이스를 구현했다. 또한 리더기에서 전송하는 모든 카드 객체는 <code class=\"inline-code\">Purchasable</code>를 상속받도록 강제했다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * A 카드 객체</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:36:11</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">class</span> <span class=\"token class-name\">CardA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Purchasable</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 카드사 정보 전송 및 결과 반환 함수</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 전송 결과</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token annotation punctuation\">@Override</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSimpleName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span> <span class=\"token string\">\"원 결제 요청\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21><span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24><span class=\"token comment\" data-tag=\"new\"> * B 카드 객체</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=27><td class=\"line-number\" data-number=\"27\">27</td><td class=\"line-code\" data-number=27><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:38:00</span></td></tr>\n<tr data-number=28><td class=\"line-number\" data-number=\"28\">28</td><td class=\"line-code\" data-number=28><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=29><td class=\"line-number\" data-number=\"29\">29</td><td class=\"line-code\" data-number=29><span class=\"token keyword\">class</span> <span class=\"token class-name\">CardB</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Purchasable</span></td></tr>\n<tr data-number=30><td class=\"line-number\" data-number=\"30\">30</td><td class=\"line-code\" data-number=30><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=31><td class=\"line-number\" data-number=\"31\">31</td><td class=\"line-code\" data-number=31>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=32><td class=\"line-number\" data-number=\"32\">32</td><td class=\"line-code\" data-number=32><span class=\"token comment\" data-tag=\"new\">     * 카드사 정보 전송 및 결과 반환 함수</span></td></tr>\n<tr data-number=33><td class=\"line-number\" data-number=\"33\">33</td><td class=\"line-code\" data-number=33><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=34><td class=\"line-number\" data-number=\"34\">34</td><td class=\"line-code\" data-number=34><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=35><td class=\"line-number\" data-number=\"35\">35</td><td class=\"line-code\" data-number=35><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=36><td class=\"line-number\" data-number=\"36\">36</td><td class=\"line-code\" data-number=36><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 전송 결과</span></td></tr>\n<tr data-number=37><td class=\"line-number\" data-number=\"37\">37</td><td class=\"line-code\" data-number=37><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=38><td class=\"line-number\" data-number=\"38\">38</td><td class=\"line-code\" data-number=38>    <span class=\"token annotation punctuation\">@Override</span></td></tr>\n<tr data-number=39><td class=\"line-number\" data-number=\"39\">39</td><td class=\"line-code\" data-number=39>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=40><td class=\"line-number\" data-number=\"40\">40</td><td class=\"line-code\" data-number=40>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=41><td class=\"line-number\" data-number=\"41\">41</td><td class=\"line-code\" data-number=41>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSimpleName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span> <span class=\"token string\">\"원 결제 요청\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=42><td class=\"line-number\" data-number=\"42\">42</td><td class=\"line-code\" data-number=42>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=43><td class=\"line-number\" data-number=\"43\">43</td><td class=\"line-code\" data-number=43>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=44><td class=\"line-number\" data-number=\"44\">44</td><td class=\"line-code\" data-number=44><span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=45><td class=\"line-number\" data-number=\"45\">45</td><td class=\"line-code\" data-number=45></td></tr>\n<tr data-number=46><td class=\"line-number\" data-number=\"46\">46</td><td class=\"line-code\" data-number=46><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=47><td class=\"line-number\" data-number=\"47\">47</td><td class=\"line-code\" data-number=47><span class=\"token comment\" data-tag=\"new\"> * C 카드 객체</span></td></tr>\n<tr data-number=48><td class=\"line-number\" data-number=\"48\">48</td><td class=\"line-code\" data-number=48><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=49><td class=\"line-number\" data-number=\"49\">49</td><td class=\"line-code\" data-number=49><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=50><td class=\"line-number\" data-number=\"50\">50</td><td class=\"line-code\" data-number=50><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:39:51</span></td></tr>\n<tr data-number=51><td class=\"line-number\" data-number=\"51\">51</td><td class=\"line-code\" data-number=51><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=52><td class=\"line-number\" data-number=\"52\">52</td><td class=\"line-code\" data-number=52><span class=\"token keyword\">class</span> <span class=\"token class-name\">CardC</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Purchasable</span></td></tr>\n<tr data-number=53><td class=\"line-number\" data-number=\"53\">53</td><td class=\"line-code\" data-number=53><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=54><td class=\"line-number\" data-number=\"54\">54</td><td class=\"line-code\" data-number=54>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=55><td class=\"line-number\" data-number=\"55\">55</td><td class=\"line-code\" data-number=55><span class=\"token comment\" data-tag=\"new\">     * 카드사 정보 전송 및 결과 반환 함수</span></td></tr>\n<tr data-number=56><td class=\"line-number\" data-number=\"56\">56</td><td class=\"line-code\" data-number=56><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=57><td class=\"line-number\" data-number=\"57\">57</td><td class=\"line-code\" data-number=57><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=58><td class=\"line-number\" data-number=\"58\">58</td><td class=\"line-code\" data-number=58><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=59><td class=\"line-number\" data-number=\"59\">59</td><td class=\"line-code\" data-number=59><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 전송 결과</span></td></tr>\n<tr data-number=60><td class=\"line-number\" data-number=\"60\">60</td><td class=\"line-code\" data-number=60><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=61><td class=\"line-number\" data-number=\"61\">61</td><td class=\"line-code\" data-number=61>    <span class=\"token annotation punctuation\">@Override</span></td></tr>\n<tr data-number=62><td class=\"line-number\" data-number=\"62\">62</td><td class=\"line-code\" data-number=62>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=63><td class=\"line-number\" data-number=\"63\">63</td><td class=\"line-code\" data-number=63>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=64><td class=\"line-number\" data-number=\"64\">64</td><td class=\"line-code\" data-number=64>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSimpleName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span> <span class=\"token string\">\"원 결제 요청\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=65><td class=\"line-number\" data-number=\"65\">65</td><td class=\"line-code\" data-number=65>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=66><td class=\"line-number\" data-number=\"66\">66</td><td class=\"line-code\" data-number=66>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=67><td class=\"line-number\" data-number=\"67\">67</td><td class=\"line-code\" data-number=67><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>이제 리더기에서 전달하는 모든 카드 객체는 <code class=\"inline-code\">Purchasable</code> 인터페이스를 상속받는다. 카드 객체를 부모 객체인 <code class=\"inline-code\">Purchasable</code>로 다룰 수 있을 것이다. 각 카드 객체의 동작에 전송이 각각 구현되어있어, 타 객체의 코드에 의존하지 않는다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 포스 클래스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.08.14 Sat 02:10:12</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Pos</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 결제 및 결과 반환 함수</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param purchasable : [Purchasable] Purchasable 인터페이스</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     * @param price: [int] 금액</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 결제 결과</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">purchase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Purchasable</span> purchasable<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>        <span class=\"token keyword\">return</span> purchasable<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>이제 결제 함수를 리팩토링 해보자. <code class=\"inline-code\">CardA</code>, <code class=\"inline-code\">CarB</code>, <code class=\"inline-code\">CardC</code> 등 각각 개별적인 객체지만, 이제 <code class=\"inline-code\">Purchasable</code>이라는 부모 객체가 있으므로 이를 묶을 수 있다. 우리는 리더기에서 주는 인터페이스 객체만 받아서 해당 객체의 <code class=\"inline-code\">send</code>를 호출하면 된다.</p>\n<p>성공적으로 리팩토링을 마친 당신. 이제 어떤 카드든 결제가 가능하고 리더기가 정상적으로 인식만 한다면 결제를 진행할 수 있게됐다.</p>\n<p>당신이 한 각고의 노력과 빠른 대처로 인해 얼마 안 가 다시금 매출을 정상화시킬 수 있었다.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>리팩토링 전과 후를 비교해보자.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">purchase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> card<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    <span class=\"token keyword\">boolean</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    </td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>card<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"A\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardA</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"B\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardB</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>        <span class=\"token keyword\">case</span> <span class=\"token string\">\"C\"</span> <span class=\"token operator\">-></span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CardC</span><span class=\"token punctuation\">)</span> card<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>        </td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>        <span class=\"token keyword\">default</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"유효하지 않은 카드사\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>            result <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    </td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17><span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">purchase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Purchasable</span> purchasable<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> price<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>    <span class=\"token keyword\">return</span> purchasable<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위는 이전 코드, 아래는 리팩토링한 코드다. <span class=\"amber-600\">기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다</span>는 의미를 여기에서 찾을 수 있다.</p>\n<p>리팩토링 이전 코드의 경우, 새로운 카드 인식. 즉, 기능 추가를 위해선 코드의 추가가 요구됐다. 다시 말해, <span class=\"red-600\">기능을 확장하기 위해선 코드의 수정이 필요</span>하다는 의미다.</p>\n<p>반대로 리팩토링 후의 코드를 보자. <code class=\"inline-code\">Purchasable</code>라는 통합된 인터페이스를 사용하기 때문에 카드 추가에 따라 코드 단계에서 대응할 필요가 없다. 즉, <span class=\"red-600\">코드의 변경 없이 기능이 확장</span>된다.</p>\n<p>단일 책임 원칙과 마찬가지로, 비슷한 형태의 분기가 반복될 경우 개방-폐쇄 원칙을 준수하지 않았을 가능성이 높다. 이는 곧 높은 리팩토링 비용으로 직결되니, 이를 잘 준수하여 독립적인 모듈을 설계하자.</p>\n","url":["2021-08-14-open-closed-principle","2021","08","14","open-closed-principle"],"toc":[{"text":"개방-폐쇄 원칙 (Open-Closed Principle)","tag":"개방-폐쇄-원칙 (Open-Closed Principle)","depth":1},{"text":"코드로 보는 개방-폐쇄 원칙","tag":"코드로-보는 개방-폐쇄 원칙","depth":1},{"text":"정리","tag":"정리","depth":1}]},"hash":"876c218d90a"},"__N_SSG":true}